# 御程语言 CPU/GPU 调度系统设计文档

## 文档版本
- 版本：v1.1
- 日期：2024年
- 状态：规划设计
- 更新：增加手动+自动双模式设计

---

## 一、背景与目标

### 1.1 背景

现代CPU架构发展趋势：
```
Intel 12/13/14代：
├── 性能核心（P-core）：高性能，高功耗
├── 能效核心（E-core）：低功耗，适合后台任务
└── 混合架构需要智能调度

AMD Ryzen 7000/9000系列：
├── 多CCD设计
├── 不同核心频率
└── NUMA架构优化

ARM架构（Apple M系列/高通骁龙）：
├── 大核：性能优先
├── 小核：能效优先
└── 超大核：极致性能

GPU发展趋势：
├── 多GPU并行
├── 异构计算（CPU+GPU）
├── AI加速器集成
└── 统一内存架构
```

### 1.2 目标

```
核心目标：
├── 智能识别CPU核心类型（P-core/E-core）
├── 自动分配任务到合适的核心
├── 动态负载均衡
├── GPU任务调度
└── 异构计算支持

设计原则（核心：手动+自动双模式）：
├── 手动优先：用户可以精确控制每一个调度细节
├── 自动辅助：提供便捷的自动模式供选择
├── 灵活切换：运行时可动态切换手动/自动模式
├── 透明可控：自动模式的行为完全可预测、可干预
├── 跨平台：支持Windows/Linux/macOS
└── 安全可靠：权限控制，防止滥用

核心理念：
├── "用户是主人，系统是助手"
├── 手动模式：用户完全控制，系统只执行
├── 自动模式：系统智能决策，用户可干预
└── 混合模式：部分手动控制，部分自动决策
```

---

## 二、手动+自动双模式设计（核心特性）

### 2.1 设计理念

```
传统调度系统问题：
├── 全自动：用户无法干预，黑盒行为
├── 全手动：用户需要了解所有细节，负担重
└── 缺乏灵活性：无法根据场景动态调整

御程解决方案：手动+自动双模式
├── 手动模式：用户精确控制，适合专业场景
├── 自动模式：系统智能决策，适合快速开发
├── 混合模式：灵活组合，兼顾控制与便捷
└── 运行时切换：无需重启，动态调整
```

### 2.2 调度模式枚举

```御程
包 scheduler

枚举 调度模式 {
    手动模式                      // 用户完全控制
    自动模式                      // 系统智能决策
    混合模式                      // 部分手动+部分自动
}

结构 模式配置 {
    模式: 调度模式
    手动控制范围: 控制范围?        // 混合模式下指定手动控制的部分
    自动控制范围: 控制范围?        // 混合模式下指定自动控制的部分
    干预阈值: 小数                 // 自动模式下允许用户干预的阈值
    回退策略: 回退策略             // 自动决策失败时的处理
}

枚举 控制范围 {
    核心选择                      // 控制任务分配到哪些核心
    优先级设置                    // 控制任务优先级
    频率调节                      // 控制CPU频率
    GPU选择                       // 控制GPU选择
    内存分配                      // 控制内存分配策略
    全部                          // 控制所有方面
}

枚举 回退策略 {
    保持现状                      // 保持当前状态
    询问用户                      // 询问用户决策
    使用默认                      // 使用默认配置
    抛出错误                      // 抛出错误让用户处理
}
```

### 2.3 手动模式API

```御程
包 scheduler.manual

结构 手动调度器 {
    拓扑: CPU拓扑
    核心状态: 映射<整数, 核心状态>
    用户配置: 用户调度配置
}

结构 用户调度配置 {
    核心分配表: 映射<文本, 列表<整数>>    // 任务类型 -> 核心ID列表
    优先级表: 映射<文本, 任务优先级>       // 任务名称 -> 优先级
    频率设置: 映射<整数, 整数>             // 核心ID -> 目标频率
    GPU绑定: 映射<文本, 整数>              // 任务名称 -> GPU ID
    亲和性掩码: 映射<整数, 整数>           // 核心ID -> 亲和性掩码
}

// 手动模式：用户完全控制
副作用 func (调度器: 手动调度器) 提交任务(
    任务: 调度任务,
    指定核心: 列表<整数>,          // 必须指定
    指定优先级: 任务优先级,        // 必须指定
    指定GPU: 整数?                 // 可选
) -> 结果<文本, 错误> {
    // 验证核心是否可用
    循环 核心ID 在 指定核心 {
        如果 不是 调度器.核心可用(核心ID) {
            返回 失败(错误.核心不可用(核心ID))
        }
    }
    
    // 直接执行用户指令，不做任何修改
    定义 线程 = 创建线程(() => {
        设置线程亲和性(指定核心)
        设置线程优先级(指定优先级)
        任务.执行()
    })
    
    返回 成功(任务.ID)
}

// 手动设置核心频率
副作用 func (调度器: 手动调度器) 设置核心频率(核心ID: 整数, 频率: 整数) -> 结果<空, 错误> {
    // 需要管理员权限
    要求权限(权限级别.管理员)
    
    // 直接设置频率
    返回 系统设置频率(核心ID, 频率)
}

// 手动绑定任务到特定核心
副作用 func (调度器: 手动调度器) 绑定任务到核心(任务ID: 文本, 核心列表: 列表<整数>) -> 结果<空, 错误> {
    定义 任务 = 调度器.获取任务(任务ID)?
    返回 任务.迁移到核心(核心列表)
}

// 手动设置GPU亲和性
副作用 func (调度器: 手动调度器) 设置GPU亲和性(任务ID: 文本, GPU_ID: 整数) -> 结果<空, 错误> {
    定义 任务 = 调度器.获取任务(任务ID)?
    返回 任务.设置GPU(GPU_ID)
}
```

### 2.4 自动模式API

```御程
包 scheduler.auto

结构 自动调度器 {
    拓扑: CPU拓扑
    核心状态: 映射<整数, 核心状态>
    策略: 自动调度策略
    用户干预: 用户干预配置        // 允许用户干预自动决策
}

结构 用户干预配置 {
    允许干预: 布尔
    干预回调: func(决策上下文) -> 用户决策?
    超时行为: 超时行为
    最大干预次数: 整数
}

结构 决策上下文 {
    任务: 调度任务
    系统建议: 调度建议
    可选方案: 列表<调度建议>
    原因: 文本
}

结构 调度建议 {
    核心列表: 列表<整数>
    优先级: 任务优先级
    GPU_ID: 整数?
    预期性能: 小数
    预期能耗: 小数
}

枚举 用户决策 {
    接受建议                      // 接受系统建议
    选择方案(整数)                // 选择第N个备选方案
    自定义(调度建议)              // 用户自定义
    取消任务                      // 取消任务
}

枚举 超时行为 {
    使用建议                      // 超时后使用系统建议
    使用默认                      // 使用默认配置
    取消任务                      // 取消任务
}

// 自动模式：系统智能决策，但允许用户干预
副作用 func (调度器: 自动调度器) 提交任务(任务: 调度任务) -> 结果<文本, 错误> {
    // 系统生成建议
    定义 建议 = 调度器.生成建议(任务)
    
    // 检查是否需要用户干预
    如果 调度器.需要用户干预(建议) {
        定义 用户决策 = 调度器.请求用户干预(建议)
        
        匹配 用户决策 {
            为 用户决策.接受建议 => { /* 使用建议 */ }
            为 用户决策.选择方案(索引) => { 建议 = 建议.可选方案[索引] }
            为 用户决策.自定义(自定义建议) => { 建议 = 自定义建议 }
            为 用户决策.取消任务 => { 返回 失败(错误.用户取消) }
        }
    }
    
    // 执行调度
    返回 调度器.执行建议(任务, 建议)
}

// 自动生成调度建议
纯函数 func (调度器: 自动调度器) 生成建议(任务: 调度任务) -> 调度建议 {
    定义 建议 = 调度建议 {
        核心列表: [],
        优先级: 任务.优先级,
        GPU_ID: 空,
        预期性能: 0.0,
        预期能耗: 0.0
    }
    
    // 根据任务类型自动选择核心
    匹配 任务.类型 {
        为 任务类型.计算密集型 => {
            建议.核心列表 = 调度器.选择最佳P核心(任务.最大核心数)
            建议.预期性能 = 0.95
        }
        为 任务类型.IO密集型 => {
            建议.核心列表 = 调度器.选择最佳E核心(任务.最大核心数)
            建议.预期性能 = 0.85
            建议.预期能耗 = 0.3
        }
        为 任务类型.实时型 => {
            建议.核心列表 = 调度器.选择最低延迟核心()
            建议.优先级 = 任务优先级.实时
            建议.预期性能 = 0.99
        }
        默认 => {
            建议.核心列表 = 调度器.负载均衡选择(任务.最大核心数)
        }
    }
    
    返回 建议
}
```

### 2.5 混合模式API

```御程
包 scheduler.hybrid

结构 混合调度器 {
    手动部分: 手动控制器
    自动部分: 自动控制器
    模式边界: 模式边界配置
}

结构 模式边界配置 {
    手动控制: 列表<控制范围>      // 用户手动控制的部分
    自动控制: 列表<控制范围>      // 系统自动控制的部分
    冲突解决: 冲突解决策略
}

枚举 冲突解决策略 {
    手动优先                      // 冲突时以手动设置为准
    自动优先                      // 冲突时以自动决策为准
    抛出错误                      // 冲突时抛出错误
    询问用户                      // 冲突时询问用户
}

// 混合模式示例：用户控制核心选择，系统控制频率
副作用 func (调度器: 混合调度器) 提交任务(
    任务: 调度任务,
    手动核心: 列表<整数>?         // 用户手动指定核心（可选）
) -> 结果<文本, 错误> {
    定义 最终核心: 列表<整数>
    定义 最终频率: 整数
    
    // 核心选择：手动优先
    如果 手动核心 != 空 {
        最终核心 = 手动核心
    } 否则 {
        最终核心 = 调度器.自动部分.选择核心(任务)
    }
    
    // 频率设置：自动控制
    最终频率 = 调度器.自动部分.计算最佳频率(最终核心, 任务)
    
    // 执行
    返回 调度器.执行(任务, 最终核心, 最终频率)
}

// 运行时切换模式
副作用 func (调度器: 混合调度器) 切换模式(
    新模式: 调度模式,
    配置: 模式配置?
) -> 结果<空, 错误> {
    // 保存当前状态
    定义 当前状态 = 调度器.保存状态()
    
    // 切换模式
    调度器.当前模式 = 新模式
    
    // 应用新配置
    如果 配置 != 空 {
        调度器.应用配置(配置)
    }
    
    // 恢复可恢复的状态
    调度器.恢复状态(当前状态)
    
    返回 成功(空)
}
```

### 2.6 使用场景对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                        使用场景对比                                   │
├─────────────────┬─────────────────┬─────────────────────────────────┤
│     场景        │    推荐模式     │            原因                  │
├─────────────────┼─────────────────┼─────────────────────────────────┤
│ 游戏服务器      │     手动        │ 需要精确控制延迟和资源分配        │
│ 视频渲染        │     手动        │ 需要绑定特定GPU和核心             │
│ 科学计算        │     手动        │ 需要最大化利用特定核心            │
├─────────────────┼─────────────────┼─────────────────────────────────┤
│ Web服务         │     自动        │ 请求量大，自动负载均衡更高效      │
│ 日志处理        │     自动        │ 后台任务，自动分配到E-core        │
│ 批量数据处理    │     自动        │ 任务量大，自动调度更便捷          │
├─────────────────┼─────────────────┼─────────────────────────────────┤
│ 混合负载服务    │     混合        │ 核心任务手动，后台任务自动        │
│ 开发测试环境    │     混合        │ 关键测试手动，其他自动            │
│ 边缘计算设备    │     混合        │ 关键任务手动，节能任务自动        │
└─────────────────┴─────────────────┴─────────────────────────────────┘
```

---

## 三、系统架构

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Applications)                      │
│         用户程序 / AI应用 / 游戏引擎 / 数据处理               │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────┐
│                    调度API层 (Scheduler API)                  │
│   任务定义 / 优先级设置 / 亲和性控制 / 负载均衡策略           │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────┐
│                    调度引擎层 (Scheduler Engine)              │
│   CPU调度器 / GPU调度器 / 异构调度器 / 负载均衡器            │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────┐
│                    硬件抽象层 (HAL)                           │
│   CPU拓扑检测 / GPU检测 / 性能监控 / 电源管理                │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────┐
│                    操作系统层 (OS)                            │
│   Windows (API) / Linux (sysfs/cgroups) / macOS (IOKit)     │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心模块

```
yucheng-scheduler/
├── src/
│   ├── lib.yc                    # 库入口
│   ├── core/                     # 核心模块
│   │   ├── topology.yc           # CPU拓扑检测
│   │   ├── scheduler.yc          # 调度器核心
│   │   ├── task.yc               # 任务定义
│   │   └── affinity.yc           # 亲和性控制
│   ├── cpu/                      # CPU调度
│   │   ├── detector.yc           # 核心类型检测
│   │   ├── pcore.yc              # 性能核心管理
│   │   ├── ecore.yc              # 能效核心管理
│   │   ├── load_balancer.yc      # 负载均衡
│   │   └── power_manager.yc      # 电源管理
│   ├── gpu/                      # GPU调度
│   │   ├── detector.yc           # GPU检测
│   │   ├── queue.yc              # 任务队列
│   │   ├── memory.yc             # 显存管理
│   │   └── multi_gpu.yc          # 多GPU调度
│   ├── hetero/                   # 异构计算
│   │   ├── hybrid.yc             # CPU+GPU协同
│   │   ├── pipeline.yc           # 流水线调度
│   │   └── sync.yc               # 同步机制
│   ├── policy/                   # 调度策略
│   │   ├── performance.yc        # 性能优先
│   │   ├── power_save.yc         # 省电优先
│   │   ├── balanced.yc           # 平衡模式
│   │   └── custom.yc             # 自定义策略
│   └── monitor/                  # 监控系统
│       ├── metrics.yc            # 性能指标
│       ├── profiler.yc           # 性能分析
│       └── reporter.yc           # 报告生成
└── docs/
```

---

## 四、核心接口设计

### 4.1 CPU拓扑检测

```御程
包 scheduler

结构 CPU拓扑 {
    处理器列表: 列表<处理器>
    性能核心列表: 列表<整数>      // P-core ID列表
    能效核心列表: 列表<整数>      // E-core ID列表
    物理核心数: 整数
    逻辑核心数: 整数
    NUMA节点列表: 列表<NUMA节点>
    缓存层级: 列表<缓存信息>
}

结构 处理器 {
    ID: 整数                      // 逻辑处理器ID
    物理ID: 整数                  // 物理核心ID
    核心类型: 核心类型
    基础频率: 整数                // MHz
    最大频率: 整数                // MHz
    当前频率: 整数                // MHz
    缓存: 缓存信息
    NUMA节点: 整数
    在线: 布尔
}

枚举 核心类型 {
    性能核心                      // P-core (大核)
    能效核心                      // E-core (小核)
    超大核心                      // 超大核 (如ARM的X核心)
    未知
}

结构 NUMA节点 {
    ID: 整数
    处理器列表: 列表<整数>
    内存总量: 整数                // MB
    距离矩阵: 列表<整数>
}

结构 缓存信息 {
    级别: 整数                    // L1/L2/L3
    大小: 整数                    // KB
    共享核心数: 整数
    类型: 缓存类型
}

枚举 缓存类型 {
    数据缓存
    指令缓存
    统一缓存
}

副作用 func 检测CPU拓扑() -> 结果<CPU拓扑, 错误> {
    定义 拓扑 = CPU拓扑 {
        处理器列表: [],
        性能核心列表: [],
        能效核心列表: [],
        物理核心数: 0,
        逻辑核心数: 0,
        NUMA节点列表: [],
        缓存层级: []
    }
    
    // 检测处理器信息
    循环 ID 在 0..获取逻辑核心数() {
        定义 处理器 = 检测处理器(ID)?
        拓扑.处理器列表.添加(处理器)
        
        匹配 处理器.核心类型 {
            为 核心类型.性能核心 => 拓扑.性能核心列表.添加(ID)
            为 核心类型.能效核心 => 拓扑.能效核心列表.添加(ID)
            _ => {}
        }
    }
    
    拓扑.物理核心数 = 获取物理核心数()
    拓扑.逻辑核心数 = 拓扑.处理器列表.长度()
    
    返回 成功(拓扑)
}

副作用 func 检测处理器(ID: 整数) -> 结果<处理器, 错误> {
    // Windows实现
    #[cfg(target_os = "windows")]
    {
        使用 GetSystemInfo 和 CallNtPowerInformation
        检测核心类型和频率信息
    }
    
    // Linux实现
    #[cfg(target_os = "linux")]
    {
        读取 /sys/devices/system/cpu/cpu{ID}/ 目录
        检测 core_id, physical_package_id, frequency
        通过 cpuid 指令检测核心类型
    }
    
    // macOS实现
    #[cfg(target_os = "macos")]
    {
        使用 sysctl 和 IOKit 检测
    }
}
```

### 4.2 任务定义

```御程
包 scheduler

结构 调度任务 {
    ID: 文本
    名称: 文本
    类型: 任务类型
    优先级: 任务优先级
    核心偏好: 核心偏好
    亲和性: 列表<整数>?          // 指定核心ID列表
    最小核心数: 整数
    最大核心数: 整数
    内存需求: 整数               // MB
    GPU需求: 布尔
    超时: 整数                   // 毫秒
    回调函数: func(结果) -> 空
}

枚举 任务类型 {
    计算密集型                   // CPU密集，适合P-core
    IO密集型                     // 等待多，适合E-core
    内存密集型                   // 内存带宽敏感
    混合型                       // 综合类型
    实时型                       // 低延迟要求
    后台型                       // 低优先级后台任务
}

枚举 任务优先级 {
    实时                         // 最高优先级
    高
    普通
    低
    后台                         // 最低优先级
}

枚举 核心偏好 {
    性能优先                     // 优先使用P-core
    能效优先                     // 优先使用E-core
    自动选择                     // 根据任务类型自动选择
    指定核心                     // 手动指定核心
    全部核心                     // 使用所有可用核心
}

结构 任务结果 {
    任务ID: 文本
    状态: 任务状态
    执行时间: 整数               // 毫秒
    使用核心: 列表<整数>
    CPU使用率: 小数
    内存使用: 整数               // MB
    输出: 值?
    错误: 错误?
}

枚举 任务状态 {
    等待中
    运行中
    已完成
    已取消
    超时
    失败
}
```

### 4.3 CPU调度器

```御程
包 scheduler

结构 CPU调度器 {
    拓扑: CPU拓扑
    任务队列: 优先队列<调度任务>
    运行中任务: 映射<文本, 运行中任务>
    核心状态: 映射<整数, 核心状态>
    调度策略: 调度策略
    电源管理: 电源管理器
}

结构 核心状态 {
    ID: 整数
    核心: 处理器
    当前任务: 文本?
    使用率: 小数
    温度: 小数
    频率: 整数
    负载历史: 列表<小数>
}

结构 运行中任务 {
    任务: 调度任务
    开始时间: 时间戳
    线程句柄: 线程句柄
    分配核心: 列表<整数>
}

接口 调度策略 {
    纯函数 func 选择核心(任务: 调度任务, 拓扑: CPU拓扑, 状态: 映射<整数, 核心状态>) -> 列表<整数>
    纯函数 func 计算优先级(任务: 调度任务) -> 整数
    纯函数 func 是否抢占(新任务: 调度任务, 当前任务: 调度任务) -> 布尔
}

副作用 func (调度器: CPU调度器) 提交任务(任务: 调度任务) -> 结果<文本, 错误> {
    // 验证任务
    如果 不是 任务.验证() {
        返回 失败(错误.无效任务)
    }
    
    // 生成任务ID
    定义 任务ID = 生成UUID()
    任务.ID = 任务ID
    
    // 选择核心
    定义 选择的核心 = 调度器.选择核心(任务)
    
    如果 选择的核心.长度() < 任务.最小核心数 {
        返回 失败(错误.核心不足)
    }
    
    // 创建线程
    定义 线程 = 创建线程(() => {
        设置线程亲和性(选择的核心)
        设置线程优先级(任务.优先级)
        
        定义 开始时间 = 当前时间()
        定义 结果 = 任务.执行()
        定义 结束时间 = 当前时间()
        
        调度器.任务完成(任务ID, 结果, 结束时间 - 开始时间)
    })
    
    // 记录运行状态
    调度器.运行中任务[任务ID] = 运行中任务 {
        任务: 任务,
        开始时间: 当前时间(),
        线程句柄: 线程,
        分配核心: 选择的核心
    }
    
    返回 成功(任务ID)
}

副作用 func (调度器: CPU调度器) 选择核心(任务: 调度任务) -> 列表<整数> {
    匹配 任务.核心偏好 {
        为 核心偏好.性能优先 => {
            // 优先使用P-core
            定义 可用P核心 = 调度器.获取可用核心(调度器.拓扑.性能核心列表)
            如果 可用P核心.长度() >= 任务.最小核心数 {
                返回 可用P核心.取前(任务.最大核心数)
            }
            // P-core不足，补充E-core
            定义 可用E核心 = 调度器.获取可用核心(调度器.拓扑.能效核心列表)
            返回 (可用P核心 + 可用E核心).取前(任务.最大核心数)
        }
        
        为 核心偏好.能效优先 => {
            // 优先使用E-core
            定义 可用E核心 = 调度器.获取可用核心(调度器.拓扑.能效核心列表)
            如果 可用E核心.长度() >= 任务.最小核心数 {
                返回 可用E核心.取前(任务.最大核心数)
            }
            // E-core不足，补充P-core
            定义 可用P核心 = 调度器.获取可用核心(调度器.拓扑.性能核心列表)
            返回 (可用E核心 + 可用P核心).取前(任务.最大核心数)
        }
        
        为 核心偏好.自动选择 => {
            匹配 任务.类型 {
                为 任务类型.计算密集型 => 调度器.选择核心(任务.修改(核心偏好: 核心偏好.性能优先))
                为 任务类型.IO密集型 => 调度器.选择核心(任务.修改(核心偏好: 核心偏好.能效优先))
                为 任务类型.实时型 => 调度器.选择核心(任务.修改(核心偏好: 核心偏好.性能优先))
                为 任务类型.后台型 => 调度器.选择核心(任务.修改(核心偏好: 核心偏好.能效优先))
                默认 => 调度器.负载均衡选择(任务)
            }
        }
        
        为 核心偏好.指定核心 => {
            如果 任务.亲和性 != 空 {
                返回 任务.亲和性
            }
            返回 调度器.选择核心(任务.修改(核心偏好: 核心偏好.自动选择))
        }
        
        为 核心偏好.全部核心 => {
            返回 调度器.拓扑.处理器列表.映射(p => p.ID)
        }
    }
}

副作用 func (调度器: CPU调度器) 负载均衡选择(任务: 调度任务) -> 列表<整数> {
    定义 所有核心 = 调度器.拓扑.处理器列表
    定义 核心负载 = 所有核心.映射(核心 => {
        定义 状态 = 调度器.核心状态[核心.ID]
        返回 { ID: 核心.ID, 负载: 状态.使用率, 类型: 核心.核心类型 }
    })
    
    // 按负载排序
    核心负载.排序((甲, 乙) => 甲.负载 - 乙.负载)
    
    // 选择负载最低的核心
    返回 核心负载
        .筛选(核心 => 核心.负载 < 0.8)  // 排除高负载核心
        .取前(任务.最大核心数)
        .映射(核心 => 核心.ID)
}
```

### 4.4 GPU调度器

```御程
包 scheduler

结构 GPU调度器 {
    GPU列表: 列表<GPU设备>
    任务队列: 优先队列<GPU任务>
    内存池: 映射<整数, 显存池>
    执行流: 映射<整数, 列表<执行流>>
}

结构 GPU设备 {
    ID: 整数
    名称: 文本
    厂商: GPU厂商
    计算能力: 文本
    显存总量: 整数               // MB
    多处理器数: 整数
    最大线程数: 整数
    最大频率: 整数               // MHz
    当前频率: 整数
    温度: 小数
    使用率: 小数
}

枚举 GPU厂商 {
    NVIDIA
    AMD
    Intel
    Apple
    未知
}

结构 GPU任务 {
    ID: 文本
    名称: 文本
    类型: GPU任务类型
    优先级: 任务优先级
    GPU偏好: 整数?               // 指定GPU ID
    显存需求: 整数               // MB
    核函数: 文本                 // 核函数名称或代码
    参数: 映射<文本, 值>
    网格大小: 三维大小
    块大小: 三维大小
    超时: 整数                   // 毫秒
    回调函数: func(结果) -> 空
}

结构 三维大小 {
    X: 整数
    Y: 整数
    Z: 整数
}

枚举 GPU任务类型 {
    计算任务                     // 通用计算
    渲染任务                     // 图形渲染
    AI推理                       // AI模型推理
    AI训练                       // AI模型训练
    视频编码                     // 视频处理
    视频解码
}

副作用 func (调度器: GPU调度器) 提交任务(任务: GPU任务) -> 结果<文本, 错误> {
    // 选择GPU
    定义 目标GPU = 调度器.选择GPU(任务)
    
    // 分配显存
    定义 显存块 = 调度器.内存池[目标GPU.ID].分配(任务.显存需求)
    
    如果 显存块 == 空 {
        返回 失败(错误.显存不足)
    }
    
    // 创建执行流
    定义 流 = 调度器.创建执行流(目标GPU.ID)
    
    // 提交核函数
    异步 {
        定义 开始时间 = 当前时间()
        
        // 上传参数到GPU
        上传参数(目标GPU, 流, 任务.参数)
        
        // 执行核函数
        执行核函数(目标GPU, 流, 任务.核函数, 任务.网格大小, 任务.块大小)
        
        // 下载结果
        定义 结果 = 下载结果(目标GPU, 流)
        
        定义 结束时间 = 当前时间()
        
        // 释放显存
        调度器.内存池[目标GPU.ID].释放(显存块)
        
        // 回调
        任务.回调函数(任务结果 {
            任务ID: 任务.ID,
            状态: 任务状态.已完成,
            执行时间: 结束时间 - 开始时间,
            输出: 结果
        })
    }
    
    返回 成功(任务.ID)
}

副作用 func (调度器: GPU调度器) 选择GPU(任务: GPU任务) -> GPU设备 {
    // 如果指定了GPU
    如果 任务.GPU偏好 != 空 {
        返回 调度器.GPU列表.查找(g => g.ID == 任务.GPU偏好)
    }
    
    // 根据任务类型选择
    匹配 任务.类型 {
        为 GPU任务类型.AI推理 => {
            // 选择AI加速器或性能最强的GPU
            返回 调度器.GPU列表
                .筛选(g => g.厂商 == GPU厂商.NVIDIA 或 g.厂商 == GPU厂商.Apple)
                .排序((甲, 乙) => 乙.计算能力 - 甲.计算能力)
                .首个()
        }
        
        为 GPU任务类型.渲染任务 => {
            // 选择显存最大的GPU
            返回 调度器.GPU列表
                .排序((甲, 乙) => 乙.显存总量 - 甲.显存总量)
                .首个()
        }
        
        默认 => {
            // 选择负载最低的GPU
            返回 调度器.GPU列表
                .排序((甲, 乙) => 甲.使用率 - 乙.使用率)
                .首个()
        }
    }
}
```

### 4.5 异构调度器

```御程
包 scheduler

结构 异构调度器 {
    CPU调度器: CPU调度器
    GPU调度器: GPU调度器
    流水线: 映射<文本, 异构流水线>
    同步器: 同步器
}

结构 异构流水线 {
    ID: 文本
    名称: 文本
    阶段列表: 列表<流水线阶段>
    状态: 流水线状态
    吞吐量: 小数
}

结构 流水线阶段 {
    ID: 整数
    名称: 文本
    执行器: 执行器类型
    任务模板: 调度任务 或 GPU任务
    输入队列: 队列<值>
    输出队列: 队列<值>
    并行度: 整数
}

枚举 执行器类型 {
    CPU
    GPU
    自动
}

枚举 流水线状态 {
    就绪
    运行中
    暂停
    已停止
}

副作用 func (调度器: 异构调度器) 创建流水线(配置: 流水线配置) -> 结果<异构流水线, 错误> {
    定义 流水线 = 异构流水线 {
        ID: 生成ID(),
        名称: 配置.名称,
        阶段列表: [],
        状态: 流水线状态.就绪,
        吞吐量: 0.0
    }
    
    // 创建阶段
    循环 阶段配置 在 配置.阶段列表 {
        定义 阶段 = 流水线阶段 {
            ID: 流水线.阶段列表.长度(),
            名称: 阶段配置.名称,
            执行器: 阶段配置.执行器,
            任务模板: 阶段配置.任务模板,
            输入队列: 创建队列(阶段配置.队列大小),
            输出队列: 创建队列(阶段配置.队列大小),
            并行度: 阶段配置.并行度
        }
        
        流水线.阶段列表.添加(阶段)
    }
    
    // 连接队列
    循环 索引, 阶段 在 流水线.阶段列表.枚举() {
        如果 索引 > 0 {
            阶段.输入队列 = 流水线.阶段列表[索引 - 1].输出队列
        }
    }
    
    返回 成功(流水线)
}

副作用 func (调度器: 异构调度器) 启动流水线(流水线: 异构流水线) {
    流水线.状态 = 流水线状态.运行中
    
    // 启动每个阶段的工作线程
    循环 阶段 在 流水线.阶段列表 {
        循环 _ 在 0..阶段.并行度 {
            异步 {
                当 流水线.状态 == 流水线状态.运行中 {
                    定义 输入 = 阶段.输入队列.弹出(超时: 100)
                    
                    如果 输入 != 空 {
                        定义 结果 = 调度器.执行阶段(阶段, 输入)
                        阶段.输出队列.推入(结果)
                    }
                }
            }
        }
    }
}

副作用 func (调度器: 异构调度器) 执行阶段(阶段: 流水线阶段, 输入: 值) -> 值 {
    匹配 阶段.执行器 {
        为 执行器类型.CPU => {
            定义 任务 = 阶段.任务模板.复制()
            任务.参数 = 输入
            定义 任务ID = 调度器.CPU调度器.提交任务(任务)?
            返回 等待任务完成(任务ID)
        }
        
        为 执行器类型.GPU => {
            定义 任务 = 阶段.任务模板.复制()
            任务.参数 = 输入
            定义 任务ID = 调度器.GPU调度器.提交任务(任务)?
            返回 等待任务完成(任务ID)
        }
        
        为 执行器类型.自动 => {
            // 根据输入大小和负载自动选择
            如果 评估GPU优势(输入, 阶段.任务模板) {
                返回 调度器.执行阶段(阶段.修改(执行器: 执行器类型.GPU), 输入)
            } 否则 {
                返回 调度器.执行阶段(阶段.修改(执行器: 执行器类型.CPU), 输入)
            }
        }
    }
}
```

---

## 五、调度策略

### 5.1 性能优先策略

```御程
包 scheduler.policy

结构 性能优先策略 实现 调度策略 {
    最小频率: 整数               // 最低频率要求
    最大温度: 小数               // 温度限制
}

纯函数 func (策略: 性能优先策略) 选择核心(
    任务: 调度任务,
    拓扑: CPU拓扑,
    状态: 映射<整数, 核心状态>
) -> 列表<整数> {
    // 优先选择P-core
    定义 可用P核心 = 拓扑.性能核心列表.筛选(ID => {
        定义 核心状态 = 状态[ID]
        返回 核心状态.使用率 < 0.9 且
               核心状态.温度 < 策略.最大温度 且
               核心状态.频率 >= 策略.最小频率
    })
    
    // 按频率和使用率排序
    可用P核心.排序((甲, 乙) => {
        定义 甲状态 = 状态[甲]
        定义 乙状态 = 状态[乙]
        返回 (乙状态.频率 - 甲状态.频率) * 1000 + (甲状态.使用率 - 乙状态.使用率)
    })
    
    返回 可用P核心.取前(任务.最大核心数)
}

纯函数 func (策略: 性能优先策略) 计算优先级(任务: 调度任务) -> 整数 {
    匹配 任务.类型 {
        为 任务类型.实时型 => 返回 100
        为 任务类型.计算密集型 => 返回 80
        为 任务类型.混合型 => 返回 60
        为 任务类型.IO密集型 => 返回 40
        为 任务类型.后台型 => 返回 20
    }
}

纯函数 func (策略: 性能优先策略) 是否抢占(新任务: 调度任务, 当前任务: 调度任务) -> 布尔 {
    定义 新优先级 = 策略.计算优先级(新任务)
    定义 当前优先级 = 策略.计算优先级(当前任务)
    
    返回 新优先级 > 当前优先级 + 20  // 优先级差距足够大才抢占
}
```

### 5.2 省电优先策略

```御程
包 scheduler.policy

结构 省电优先策略 实现 调度策略 {
    目标温度: 小数               // 目标温度
    最小频率: 整数               // 最低频率
}

纯函数 func (策略: 省电优先策略) 选择核心(
    任务: 调度任务,
    拓扑: CPU拓扑,
    状态: 映射<整数, 核心状态>
) -> 列表<整数> {
    // 优先使用E-core
    定义 可用E核心 = 拓扑.能效核心列表.筛选(ID => {
        定义 核心状态 = 状态[ID]
        返回 核心状态.使用率 < 0.8 且 核心状态.温度 < 策略.目标温度
    })
    
    如果 可用E核心.长度() >= 任务.最小核心数 {
        返回 可用E核心.取前(任务.最大核心数)
    }
    
    // E-core不足才用P-core
    定义 可用P核心 = 拓扑.性能核心列表.筛选(ID => {
        定义 核心状态 = 状态[ID]
        返回 核心状态.使用率 < 0.7 且 核心状态.温度 < 策略.目标温度
    })
    
    返回 (可用E核心 + 可用P核心).取前(任务.最大核心数)
}

纯函数 func (策略: 省电优先策略) 计算优先级(任务: 调度任务) -> 整数 {
    // 后台任务优先级高（让它们尽快完成，然后进入低功耗）
    匹配 任务.类型 {
        为 任务类型.后台型 => 返回 90
        为 任务类型.IO密集型 => 返回 70
        为 任务类型.混合型 => 返回 50
        为 任务类型.计算密集型 => 返回 30
        为 任务类型.实时型 => 返回 100  // 实时任务仍然最高
    }
}
```

### 5.3 智能平衡策略

```御程
包 scheduler.policy

结构 智能平衡策略 实现 调度策略 {
    性能权重: 小数               // 0.0-1.0
    省电权重: 小数               // 0.0-1.0
    学习率: 小数                 // 自适应学习率
    历史窗口: 整数               // 历史数据窗口大小
}

纯函数 func (策略: 智能平衡策略) 选择核心(
    任务: 调度任务,
    拓扑: CPU拓扑,
    状态: 映射<整数, 核心状态>
) -> 列表<整数> {
    // 计算系统负载
    定义 总负载 = 计算平均负载(状态)
    定义 温度压力 = 计算温度压力(状态)
    定义 功耗预算 = 计算功耗预算(状态)
    
    // 动态调整权重
    定义 调整后性能权重 = 策略.性能权重 * (1 - 温度压力) * 功耗预算
    定义 调整后省电权重 = 策略.省电权重 * (1 + 温度压力) * (1 - 功耗预算)
    
    // 归一化
    定义 总权重 = 调整后性能权重 + 调整后省电权重
    调整后性能权重 = 调整后性能权重 / 总权重
    调整后省电权重 = 调整后省电权重 / 总权重
    
    // 根据权重选择核心
    定义 P核心数 = 向上取整(任务.最大核心数 * 调整后性能权重)
    定义 E核心数 = 任务.最大核心数 - P核心数
    
    定义 选择P核心 = 拓扑.性能核心列表
        .筛选(ID => 状态[ID].使用率 < 0.8)
        .取前(P核心数)
    
    定义 选择E核心 = 拓扑.能效核心列表
        .筛选(ID => 状态[ID].使用率 < 0.8)
        .取前(E核心数)
    
    返回 选择P核心 + 选择E核心
}
```

---

## 六、使用示例

### 6.1 手动模式示例（完全控制）

```御程
导入 scheduler

副作用 func 手动模式示例() {
    // 创建手动调度器
    定义 调度器 = 创建手动调度器()
    
    // 检测CPU拓扑
    定义 拓扑 = 检测CPU拓扑()
    打印("P核心: " + 拓扑.性能核心列表)
    打印("E核心: " + 拓扑.能效核心列表)
    
    // 手动指定：任务1使用P核心0-3
    定义 任务1 = 调度任务 {
        名称: "视频编码",
        类型: 任务类型.计算密集型,
        执行: () => 编码视频(视频数据)
    }
    
    调度器.提交任务(
        任务: 任务1,
        指定核心: [0, 1, 2, 3],           // 手动指定P核心
        指定优先级: 任务优先级.高,        // 手动指定优先级
        指定GPU: 0                        // 手动指定GPU
    )?
    
    // 手动指定：任务2使用E核心4-7
    定义 任务2 = 调度任务 {
        名称: "日志分析",
        类型: 任务类型.后台型,
        执行: () => 分析日志(日志文件)
    }
    
    调度器.提交任务(
        任务: 任务2,
        指定核心: [4, 5, 6, 7],           // 手动指定E核心
        指定优先级: 任务优先级.低,        // 手动指定优先级
        指定GPU: 空                       // 不使用GPU
    )?
    
    // 手动设置核心频率（需要管理员权限）
    调度器.设置核心频率(核心ID: 0, 频率: 4500)?  // 设置P核心频率
    调度器.设置核心频率(核心ID: 4, 频率: 2500)?  // 设置E核心频率
}
```

### 6.2 自动模式示例（便捷开发）

```御程
导入 scheduler

副作用 func 自动模式示例() {
    // 创建自动调度器
    定义 调度器 = 创建自动调度器(
        策略: 自动调度策略.智能平衡,
        允许干预: 真                      // 允许用户干预自动决策
    )
    
    // 自动模式：系统自动选择核心
    定义 任务1 = 调度任务 {
        名称: "矩阵乘法",
        类型: 任务类型.计算密集型,        // 系统自动分配到P核心
        执行: () => 矩阵乘法(大矩阵A, 大矩阵B)
    }
    
    调度器.提交任务(任务1)?              // 无需指定核心，系统自动选择
    
    // 自动模式：后台任务自动分配到E核心
    定义 任务2 = 调度任务 {
        名称: "文件同步",
        类型: 任务类型.后台型,            // 系统自动分配到E核心
        执行: () => 同步文件(文件列表)
    }
    
    调度器.提交任务(任务2)?
    
    // 自动模式：系统会根据负载自动调整
    // 用户可以随时干预
    调度器.设置干预回调((上下文) => {
        打印("系统建议: " + 上下文.系统建议)
        打印("可选方案: " + 上下文.可选方案)
        
        // 用户可以选择接受建议或自定义
        如果 上下文.任务.名称 == "关键任务" {
            返回 用户决策.自定义(我的配置)  // 手动干预
        }
        返回 用户决策.接受建议               // 接受系统建议
    })
}
```

### 6.3 混合模式示例（灵活组合）

```御程
导入 scheduler

副作用 func 混合模式示例() {
    // 创建混合调度器
    定义 调度器 = 创建混合调度器(
        手动控制: [控制范围.核心选择, 控制范围.GPU选择],  // 手动控制核心和GPU
        自动控制: [控制范围.频率调节, 控制范围.优先级],    // 自动控制频率和优先级
        冲突解决: 冲突解决策略.手动优先
    )
    
    // 混合模式：用户指定核心，系统自动调整频率
    定义 任务1 = 调度任务 {
        名称: "AI推理",
        类型: 任务类型.计算密集型,
        执行: () => AI推理(模型, 输入数据)
    }
    
    调度器.提交任务(
        任务: 任务1,
        手动核心: [0, 1, 2, 3]            // 用户手动指定核心
        // 频率由系统自动调整
        // 优先级由系统自动设置
    )?
    
    // 混合模式：不指定核心时，系统自动选择
    定义 任务2 = 调度任务 {
        名称: "数据备份",
        类型: 任务类型.后台型,
        执行: () => 备份数据(数据)
    }
    
    调度器.提交任务(
        任务: 任务2,
        手动核心: 空                      // 不指定，系统自动选择
    )?
    
    // 运行时切换模式
    调度器.切换模式(
        新模式: 调度模式.手动模式,
        配置: 模式配置 {
            模式: 调度模式.手动模式,
            手动控制范围: 控制范围.全部,
            自动控制范围: 空,
            干预阈值: 0.0,
            回退策略: 回退策略.抛出错误
        }
    )?
}
```

### 6.4 大小核调度示例

```御程
导入 scheduler

副作用 func 大小核示例() {
    // 检测CPU拓扑
    定义 拓扑 = 检测CPU拓扑()
    
    打印("性能核心数: " + 拓扑.性能核心列表.长度())
    打印("能效核心数: " + 拓扑.能效核心列表.长度())
    
    // 创建调度器
    定义 调度器 = 创建CPU调度器(调度策略.智能平衡)
    
    // 高性能任务 - 自动分配到P-core
    定义 高性能任务 = 调度任务 {
        名称: "视频编码",
        类型: 任务类型.计算密集型,
        核心偏好: 核心偏好.自动选择,
        执行: () => 编码视频(视频数据)
    }
    
    // 后台任务 - 自动分配到E-core
    定义 后台任务 = 调度任务 {
        名称: "日志分析",
        类型: 任务类型.后台型,
        核心偏好: 核心偏好.自动选择,
        执行: () => 分析日志(日志文件)
    }
    
    调度器.提交任务(高性能任务)
    调度器.提交任务(后台任务)
}
```

### 6.5 GPU计算示例

```御程
导入 scheduler

副作用 func GPU计算示例() {
    // 创建GPU调度器
    定义 GPU调度器 = 创建GPU调度器()
    
    // 获取GPU列表
    定义 GPU列表 = GPU调度器.获取GPU列表()
    
    循环 GPU 在 GPU列表 {
        打印("GPU: " + GPU.名称 + ", 显存: " + GPU.显存总量 + "MB")
    }
    
    // 提交GPU任务
    定义 任务 = GPU任务 {
        名称: "矩阵运算",
        类型: GPU任务类型.计算任务,
        显存需求: 1024,  // 1GB
        核函数: "matrix_multiply",
        参数: {
            "矩阵A": 矩阵A,
            "矩阵B": 矩阵B
        },
        网格大小: 三维大小 { X: 1024, Y: 1024, Z: 1 },
        块大小: 三维大小 { X: 16, Y: 16, Z: 1 }
    }
    
    定义 任务ID = GPU调度器.提交任务(任务)?
    定义 结果 = GPU调度器.等待任务(任务ID)
    
    打印("计算结果: " + 结果.输出)
}
```

### 6.6 异构流水线示例

```御程
导入 scheduler

副作用 func 异构流水线示例() {
    // 创建异构调度器
    定义 调度器 = 创建异构调度器()
    
    // 配置流水线
    定义 配置 = 流水线配置 {
        名称: "视频处理流水线",
        阶段列表: [
            {
                名称: "视频解码",
                执行器: 执行器类型.GPU,
                并行度: 2,
                队列大小: 100
            },
            {
                名称: "帧处理",
                执行器: 执行器类型.CPU,
                并行度: 8,
                队列大小: 100
            },
            {
                名称: "视频编码",
                执行器: 执行器类型.GPU,
                并行度: 2,
                队列大小: 100
            }
        ]
    }
    
    // 创建并启动流水线
    定义 流水线 = 调度器.创建流水线(配置)?
    调度器.启动流水线(流水线)
    
    // 输入数据
    循环 视频文件 在 视频文件列表 {
        流水线.阶段列表[0].输入队列.推入(视频文件)
    }
    
    // 等待完成
    当 流水线.状态 == 流水线状态.运行中 {
        打印("吞吐量: " + 流水线.吞吐量 + " 帧/秒")
        睡眠(1000)
    }
}
```

---

## 七、监控与调试

### 7.1 性能监控

```御程
包 scheduler.monitor

结构 性能监控器 {
    采样间隔: 整数               // 毫秒
    历史长度: 整数
    指标历史: 列表<性能指标>
}

结构 性能指标 {
    时间戳: 时间戳
    CPU使用率: 小数
    每核心使用率: 列表<小数>
    P核心使用率: 小数
    E核心使用率: 小数
    GPU使用率: 小数
    内存使用率: 小数
    温度: 小数
    功耗: 小数
    任务队列长度: 整数
    吞吐量: 小数
    延迟: 小数
}

副作用 func (监控器: 性能监控器) 开始监控() {
    异步 {
        循环 {
            定义 指标 = 采集指标()
            监控器.指标历史.添加(指标)
            
            如果 监控器.指标历史.长度() > 监控器.历史长度 {
                监控器.指标历史.移除首个()
            }
            
            睡眠(监控器.采样间隔)
        }
    }
}

副作用 func (监控器: 性能监控器) 生成报告() -> 性能报告 {
    定义 报告 = 性能报告 {
        时间范围: 时间范围,
        平均CPU使用率: 0,
        峰值CPU使用率: 0,
        平均GPU使用率: 0,
        峰值GPU使用率: 0,
        平均温度: 0,
        峰值温度: 0,
        总任务数: 0,
        成功任务数: 0,
        平均延迟: 0,
        P99延迟: 0
    }
    
    // 计算统计数据
    报告.平均CPU使用率 = 监控器.指标历史.映射(m => m.CPU使用率).平均值()
    报告.峰值CPU使用率 = 监控器.指标历史.映射(m => m.CPU使用率).最大值()
    // ... 更多统计
    
    返回 报告
}
```

### 7.2 可视化仪表板

```御程
包 scheduler.dashboard

结构 调度仪表板 {
    监控器: 性能监控器
    调度器: CPU调度器
    GPU调度器: GPU调度器
}

副作用 func (仪表板: 调度仪表板) 启动() {
    创建窗口("御程调度器仪表板", 1200, 800)
    
    // CPU面板
    添加面板("CPU状态", {
        显示核心拓扑(仪表板.调度器.拓扑)
        显示每核心使用率(仪表板.监控器)
        显示P/E核心分配(仪表板.调度器)
    })
    
    // GPU面板
    添加面板("GPU状态", {
        显示GPU列表(仪表板.GPU调度器.GPU列表)
        显示GPU使用率(仪表板.GPU调度器)
        显示显存使用(仪表板.GPU调度器)
    })
    
    // 任务面板
    添加面板("任务队列", {
        显示等待任务(仪表板.调度器.任务队列)
        显示运行任务(仪表板.调度器.运行中任务)
        显示任务历史(仪表板.监控器)
    })
    
    // 性能图表
    添加面板("性能趋势", {
        显示CPU使用率曲线(仪表板.监控器)
        显示GPU使用率曲线(仪表板.监控器)
        显示温度曲线(仪表板.监控器)
        显示吞吐量曲线(仪表板.监控器)
    })
    
    运行事件循环()
}
```

---

## 八、平台适配

### 8.1 Windows平台

```御程
包 scheduler.platform

结构 Windows平台 实现 平台接口 {
    // 使用Windows API
    // - GetSystemInfo: 获取CPU信息
    // - GetLogicalProcessorInformation: 获取核心拓扑
    // - SetThreadAffinityMask: 设置线程亲和性
    // - SetThreadPriority: 设置线程优先级
    // - PowerReadACValue: 读取电源设置
}

副作用 func (平台: Windows平台) 检测核心类型(ID: 整数) -> 核心类型 {
    // Windows 10 2004+ 支持
    // 使用 GetSystemCpuSetInformation 检测
    // EfficiencyClass: 0 = E-core, 1 = P-core
    
    #[cfg(target_os = "windows")]
    {
        使用 winapi 调用 GetSystemCpuSetInformation
        返回 根据EfficiencyClass判断核心类型
    }
}

副作用 func (平台: Windows平台) 设置线程亲和性(线程: 线程句柄, 核心列表: 列表<整数>) {
    定义 掩码 = 计算亲和性掩码(核心列表)
    SetThreadAffinityMask(线程, 掩码)
}
```

### 8.2 Linux平台

```御程
包 scheduler.platform

结构 Linux平台 实现 平台接口 {
    // 使用sysfs和procfs
    // - /sys/devices/system/cpu/: CPU信息
    // - /proc/cpuinfo: CPU详情
    // - sched_setaffinity: 设置亲和性
    // - cgroups: 资源控制
}

副作用 func (平台: Linux平台) 检测核心类型(ID: 整数) -> 核心类型 {
    // 读取 /sys/devices/system/cpu/cpu{ID}/cpufreq/energy_performance_preference
    // 或使用 cpuid 指令检测
    
    定义 频率 = 读取文件("/sys/devices/system/cpu/cpu" + ID + "/cpufreq/scaling_max_freq")
    定义 基础频率 = 读取文件("/sys/devices/system/cpu/cpu" + ID + "/cpufreq/base_frequency")
    
    // Intel: 使用 cpuid 棇令检测 hybrid 信息
    // AMD: 检测 core_type
}

副作用 func (平台: Linux平台) 设置线程亲和性(线程: 线程句柄, 核心列表: 列表<整数>) {
    定义 掩码 = 创建CPU集合(核心列表)
    sched_setaffinity(线程, 掩码)
}
```

### 8.3 macOS平台

```御程
包 scheduler.platform

结构 MacOS平台 实现 平台接口 {
    // 使用IOKit和sysctl
    // - sysctlbyname: 获取CPU信息
    // - thread_policy_set: 设置线程策略
    // - IOKit: 检测硬件
}

副作用 func (平台: MacOSPlatform) 检测核心类型(ID: 整数) -> 核心类型 {
    // Apple Silicon: 使用 sysctl 检测
    // hw.perflevel0.physicalcpu: 性能核心数
    // hw.perflevel1.physicalcpu: 能效核心数
    
    定义 P核心数 = sysctlbyname("hw.perflevel0.physicalcpu")
    定义 E核心数 = sysctlbyname("hw.perflevel1.physicalcpu")
    
    如果 ID < P核心数 {
        返回 核心类型.性能核心
    } 否则 {
        返回 核心类型.能效核心
    }
}

副作用 func (平台: MacOS平台) 设置线程亲和性(线程: 线程句柄, 核心列表: 列表<整数>) {
    // macOS不直接支持亲和性，但可以使用 QoS
    // THREAD_AFFINITY_POLICY: 设置亲和性标签
    定义 亲和性标签 = 核心列表.首个()
    thread_policy_set(线程, THREAD_AFFINITY_POLICY, 亲和性标签)
}
```

---

## 九、开发计划

### 9.1 阶段一：核心调度（0-3个月）

```
目标：基础CPU调度功能

开发内容：
├── CPU拓扑检测
│   ├── 核心类型识别（P-core/E-core）
│   ├── NUMA节点检测
│   └── 缓存层级检测
├── 基础调度器
│   ├── 任务队列
│   ├── 亲和性控制
│   └── 优先级管理
├── 平台适配
│   ├── Windows API集成
│   ├── Linux sysfs集成
│   └── macOS IOKit集成
└── 基础测试

代码量：5000-8000行
```

### 9.2 阶段二：手动+自动双模式（3-6个月）

```
目标：实现手动+自动双模式调度

开发内容：
├── 手动模式
│   ├── 精确核心选择API
│   ├── 手动频率控制
│   ├── GPU亲和性设置
│   └── 用户配置持久化
├── 自动模式
│   ├── 智能调度策略
│   ├── 负载均衡算法
│   ├── 用户干预机制
│   └── 回退策略
├── 混合模式
│   ├── 模式边界配置
│   ├── 冲突解决策略
│   ├── 运行时模式切换
│   └── 状态保存恢复
└── 测试与优化

代码量：6000-10000行
```

### 9.3 阶段三：GPU调度（6-9个月）

```
目标：GPU任务调度

开发内容：
├── GPU检测
│   ├── NVIDIA NVML集成
│   ├── AMD ADL集成
│   └── Intel GPU集成
├── GPU调度器
│   ├── 任务队列
│   ├── 显存管理
│   └── 多GPU调度
├── 核函数执行
│   ├── CUDA集成
│   ├── OpenCL集成
│   └── Metal集成
└── 性能优化

代码量：6000-10000行
```

### 9.4 阶段四：异构计算（9-12个月）

```
目标：CPU+GPU协同

开发内容：
├── 异构调度器
│   ├── 自动设备选择
│   ├── 任务分割
│   └── 结果合并
├── 流水线系统
│   ├── 多阶段流水线
│   ├── 队列管理
│   └── 背压控制
├── 同步机制
│   ├── 事件同步
│   ├── 流同步
│   └── 内存同步
└── 监控仪表板

代码量：5000-8000行
```

---

## 十、成功指标

### 10.1 性能指标

```
调度效率：
├── 任务调度延迟 < 1ms
├── 核心切换延迟 < 100μs
├── 负载均衡响应 < 10ms
└── 内存开销 < 10MB

性能提升：
├── 计算密集型任务：P-core比E-core快 2-3倍
├── 后台任务：E-core功耗降低 50%+
├── 异构计算：CPU+GPU比纯CPU快 5-10倍
└── 流水线吞吐量提升 3-5倍
```

### 10.2 功能指标

```
平台支持：
├── Windows 10/11 完整支持
├── Linux (主流发行版) 完整支持
├── macOS (Intel + Apple Silicon) 完整支持
└── 跨平台一致性 > 95%

硬件支持：
├── Intel 12/13/14代大小核
├── AMD Ryzen 多CCD
├── Apple M1/M2/M3系列
├── NVIDIA GPU (计算能力 6.0+)
├── AMD GPU (RDNA架构)
└── Intel GPU (Arc系列)

模式支持：
├── 手动模式：完全控制，无限制
├── 自动模式：智能决策，可干预
├── 混合模式：灵活组合，运行时切换
└── 模式切换延迟 < 100ms
```

---

## 十一、总结

本设计文档规划了御程语言的CPU/GPU调度系统，核心特性是**手动+自动双模式**：

### 核心设计理念

```
"用户是主人，系统是助手"

┌─────────────────────────────────────────────────────────────────┐
│                      三种调度模式                                 │
├─────────────────────────────────────────────────────────────────┤
│  手动模式：用户完全控制，系统只执行                               │
│  ├── 适用场景：游戏服务器、科学计算、视频渲染                     │
│  ├── 特点：精确控制、可预测、无惊喜                               │
│  └── API：提交任务(任务, 指定核心, 指定优先级, 指定GPU)          │
├─────────────────────────────────────────────────────────────────┤
│  自动模式：系统智能决策，用户可干预                               │
│  ├── 适用场景：Web服务、日志处理、批量数据处理                    │
│  ├── 特点：便捷高效、智能优化、透明可控                           │
│  └── API：提交任务(任务) + 干预回调                               │
├─────────────────────────────────────────────────────────────────┤
│  混合模式：部分手动+部分自动，灵活组合                            │
│  ├── 适用场景：混合负载服务、开发测试、边缘计算                   │
│  ├── 特点：兼顾控制与便捷、运行时可切换                           │
│  └── API：配置手动控制范围 + 自动控制范围                         │
└─────────────────────────────────────────────────────────────────┘
```

### 主要功能模块

1. **CPU调度**：大小核识别与任务分配
2. **GPU调度**：多GPU任务调度与显存管理
3. **异构计算**：CPU+GPU协同流水线
4. **三种模式**：手动、自动、混合，运行时可切换
5. **跨平台支持**：Windows/Linux/macOS

### 与传统调度系统的区别

```
传统调度系统：
├── 全自动：黑盒行为，用户无法干预
├── 全手动：负担重，需要了解所有细节
└── 缺乏灵活性：无法根据场景动态调整

御程调度系统：
├── 手动优先：用户可以精确控制每一个调度细节
├── 自动辅助：提供便捷的自动模式供选择
├── 灵活切换：运行时可动态切换手动/自动模式
└── 透明可控：自动模式的行为完全可预测、可干预
```

通过这个系统，御程语言将成为首个**原生支持手动+自动双模式调度**的编程语言，为用户提供最大的灵活性和控制力。

---

**文档维护**：
- 每月更新进度
- 季度调整优先级
- 年度全面修订
