# 御程语言 IDE 增强与智能检查系统

> **实现状态**: ✅ 核心功能完整实现
> - ✅ 阻塞检查器已实现（blocking_checker.rs）
> - ✅ 指针检查器已实现（pointer_checker.rs）
> - ✅ 15个单元测试全部通过（100%）
> - ⚠️ 静态契约检查部分实现（基于现有类型系统）
> - ⚠️ 增量测试预演和全量链路验证待完善（基础框架已存在）

## 一、核心理念

> **可靠性不是测试出来的，而是写出来的——因为每一步都有契约护航。**

御程 IDE 的智能检查系统将"可信验证"前置到编码瞬间，实现「所写即所验」。

---

## 二、三层检查体系

### 2.1 检查层级概览

| 层级 | 触发时机 | 耗时 | 资源占用 | 用户感知 |
|------|----------|------|----------|----------|
| L1：静态契约检查 | 键入/保存时 | < 50ms | 极低（纯 AST 分析） | 实时波浪线提示 |
| L2：增量测试预演 | 点击"检查"或保存 | 100ms–1s | 低（仅跑关联用例） | 侧边栏快速反馈 |
| L3：全量链路验证 | 手动触发（如提交前） | 1s–5s | 中（并行跑完整套件） | 弹出报告面板 |

### 2.2 "检查"按钮功能

**触发时机**：用户点击 / 文件保存

**执行内容**：
- 静态分析当前文件（AST + 规则库）
- 检查类型匹配
- 验证契约满足（如 `要求 x > 0` 是否被违反）
- UI 元素是否缺失无障碍标签
- 是否调用已标记为"可能阻塞"的函数

**输出方式**：
- 编辑器中高亮错误行（红色波浪线）
- 悬浮提示详细错误信息
- 侧边栏显示简要统计

**性能目标**：< 200ms 完成

### 2.3 "检查项目"按钮功能

**触发时机**：用户主动点击（通常在提交前）

**执行内容**：
1. 全项目静态分析
2. 运行所有关联测试（.yct）
3. 链路一致性验证
4. 性能/阻塞检测
5. 生成审计报告

**输出报告示例**：

```
🛠️ 契约完整性
───────────────
✅ 8/10 接口已声明
⚠️ 2 个 UI 状态未覆盖（登录失败/加载中）

🔗 链路一致性
───────────────
✅ 前后端接口对齐
❌ 登录页面未处理 429 错误码

⚡ 性能健康度
───────────────
✅ 主线程无阻塞调用
⚠️ 数据库查询建议异步化

🧩 可访问性
───────────────
✅ 所有按钮均有标签
```

---

## 三、自动检查模式

### 3.1 三级自动检查

```ini
[自动检查级别]
○ 关闭（仅手动点击"检查"）
● 轻量模式（默认） ← 推荐
○ 严格模式
```

### 3.2 轻量模式（默认）

**触发时机**：
- 文件保存时（Ctrl+S / Cmd+S）
- 切换文件标签时

**执行内容**：
- 仅运行 L1 静态检查（< 100ms）
- 不运行任何测试
- 不阻塞编辑器输入

**反馈方式**：
- 状态栏显示小图标：✅ / ⚠️ / ❌
- 错误行显示波浪线

### 3.3 严格模式

**触发时机**：
- 保存时 + 空闲 2 秒后

**执行内容**：
- L1 静态检查
- L2 增量测试（仅运行当前文件关联的测试用例）

**适用场景**：
- 提交代码前
- 调试关键模块时

### 3.4 性能保障策略

1. **节流（Throttling）+ 防抖（Debouncing）**
   - 用户连续输入时，延迟 500ms 再触发检查

2. **增量分析**
   - 只分析自上次成功以来变更的 AST 节点

3. **低优先级任务队列**
   - 自动检查任务放入 IDLE 优先级队列

4. **资源熔断**
   - CPU > 80% 或内存紧张时，自动降级为"仅手动"

---

## 四、阻塞检查系统

### 4.1 为什么需要阻塞检查？

阻塞是高可信系统中最隐蔽、最危险的缺陷：
- 用户点击按钮 → 界面冻结 2 秒 → 体验崩坏
- 后端同步调用数据库 → 主线程挂起 → 请求雪崩

**AI 和人类都难以发现这类问题**：
- AI 只看代码结构，不感知时间
- 人类依赖主观感受（"我电脑快，没感觉卡"）
- 传统测试无法量化流畅度

### 4.2 语言级契约声明

```御程
// 显式声明函数是否允许阻塞
函数 获取用户数据(用户ID: 整数) -> 用户信息 {
    可能阻塞: 是   // 默认为 否
    要求 用户ID > 0
}

// UI 函数必须非阻塞
UI函数 处理登录点击() {
    可能阻塞: 否   // 编译器强制检查
}
```

### 4.3 静态分析规则

```yaml
# rules/performance.yaml

- id: ui_block_call
  description: "UI 线程中禁止直接调用可能阻塞的函数"
  patterns:
    - in_ui_function: true
    - calls_blocking_function: true
  actions:
    - error: "UI 函数中禁止调用可能阻塞的操作"
    - suggest: "使用 启动后台任务(获取用户数据(123))"

- id: sync_network_in_main
  description: "主线程禁止同步网络/文件 I/O"
  patterns:
    - call: ["fetch", "open", "readFileSync", "数据库.查询"]
    - in_main_thread: true
  actions:
    - error: "检测到主线程同步 I/O，可能导致 UI 阻塞"
    - mark_unsafe()
```

### 4.4 运行时监控与测试断言

```御程
// 性能测试
性能测试 "登录流程无阻塞" {
    点击("登录按钮")
    
    // 验证 UI 响应时间 < 100ms
    断言_无UI阻塞(持续时间: 1秒) {
        断言_存在("加载动画")
    }
    
    // 验证后台任务完成
    等待_后台任务完成("获取用户数据")
    断言_跳转到("主页")
}

// 检测主线程卡顿
断言_主线程帧率(最低: 30)  // 渲染 FPS 不低于 30
```

### 4.5 后台任务抽象

```御程
// 启动后台任务，返回句柄
任务 = 启动后台任务(耗时函数())

// UI 中可轮询或监听
如果 任务.完成() {
    数据 = 任务.结果()
}
```

### 4.6 阻塞检查器实现

#### 4.6.1 检查器功能

阻塞检查器（`BlockingChecker`）提供以下功能：

- **自动检测阻塞函数**：识别可能导致阻塞的函数调用
- **UI函数保护**：检测UI函数中的阻塞操作
- **分类检测**：区分I/O操作、网络调用、数据库查询等
- **智能建议**：提供修复建议和替代方案

#### 4.6.2 已知阻塞函数

检查器内置了常见阻塞函数的识别：

| 类别 | 函数示例 |
|------|---------|
| 阻塞函数 | `睡眠`, `等待`, `sleep`, `wait`, `阻塞等待` |
| I/O 函数 | `读文件`, `写文件`, `打开文件`, `read_file`, `write_file` |
| 网络函数 | `发送请求`, `获取`, `fetch`, `http_get`, `http_post` |
| 数据库函数 | `查询`, `执行SQL`, `数据库查询`, `query`, `execute` |

#### 4.6.3 问题类型

| 问题类型 | 严重程度 | 说明 |
|---------|---------|------|
| `SyncIOInUI` | Warning | UI函数中同步I/O |
| `LongLoopInUI` | Warning | UI函数中长循环 |
| `BlockingCallInUI` | Error | UI函数中调用阻塞函数 |
| `SyncNetworkCall` | Warning | 同步网络调用 |
| `SyncDatabaseQuery` | Warning | 同步数据库查询 |
| `SleepInMainThread` | Error | 主线程中sleep |
| `HeavyComputation` | Warning | 重计算操作 |

#### 4.6.4 使用方法

```bash
# 检查单个文件
yucheng check --blocking file.ycs

# 检查整个项目
yucheng check --project --blocking

# 生成阻塞检查报告
yucheng check --blocking --report blocking_report.txt
```

#### 4.6.5 检查报告示例

```
═══════════════════════════════════════════════════════════════
                    御程阻塞检查报告
═══════════════════════════════════════════════════════════════

【统计信息】
  总函数数: 15
  UI 函数数: 3
  可能阻塞: 5
  安全函数: 10
  问题数量: 2

【问题列表】

1. ❌ BlockingCallInUI
   位置: 处理登录点击
   问题: UI 函数 '处理登录点击' 中调用了可能阻塞的函数 '数据库查询'
   建议: 使用 启动后台任务(数据库查询) 替代直接调用

2. ⚠️ SyncIOInUI
   位置: 加载配置
   问题: UI 函数 '加载配置' 中包含同步 I/O 操作 '读文件'
   建议: 将 I/O 操作移至后台任务

═══════════════════════════════════════════════════════════════
```

#### 4.6.6 自定义阻塞函数

可以注册自定义的阻塞函数：

```rust
let mut checker = BlockingChecker::new();
checker.register_blocking_function("自定义耗时操作");
checker.register_blocking_function("复杂计算");
```

#### 4.6.7 IDE集成

阻塞检查器已集成到IDE中：

- **实时检查**：编辑时自动检测阻塞问题
- **波浪线提示**：在问题代码下显示红色/黄色波浪线
- **悬浮提示**：鼠标悬停显示详细问题和建议
- **快速修复**：右键菜单提供自动修复选项

#### 4.6.8 配置选项

```yaml
# .yucheng/config.yaml

阻塞检查:
  启用: 是
  检查UI函数: 是
  检查网络调用: 是
  检查数据库调用: 是
  检查文件IO: 是
  自定义阻塞函数:
    - "自定义耗时操作"
    - "复杂计算"
```

#### 4.6.9 实现状态

| 组件 | 状态 | 说明 |
|------|------|------|
| `BlockingChecker` | ✅ 完成 | 阻塞检查器核心 |
| 已知函数库 | ✅ 完成 | 内置常见阻塞函数 |
| UI函数检测 | ✅ 完成 | 自动识别UI函数 |
| 问题分类 | ✅ 完成 | 7种问题类型 |
| 修复建议 | ✅ 完成 | 智能建议系统 |
| 报告生成 | ✅ 完成 | 格式化报告输出 |
| CLI集成 | ✅ 完成 | `--blocking` 参数 |
| IDE集成 | 🔄 进行中 | 实时检查和提示 |

#### 4.6.10 相关文件

- `compiler/src/blocking_checker.rs` - 阻塞检查器实现
- `compiler/src/main.rs` - CLI命令集成
- `compiler/tests/blocking_checker_tests.rs` - 测试用例

---

## 五、测试框架 IDE 集成

### 5.1 文件级即时测试

当用户打开 `.yci` 或 `.yct` 文件，IDE 后台静默运行关联测试：

- 在编辑器 gutter（行号旁）显示：
  - ✅ 绿色对勾：该函数/测试通过
  - ❌ 红色叉：失败 + 悬浮提示错误信息

### 5.2 一键全量检查

点击"检查项目"按钮执行：

```
静态分析 → 契约验证 → 运行测试 → 链路检查 → 生成报告
```

输出面板包含：
- 通过率（如 8/10）
- 失败用例详情（带文件跳转）
- 链路缺口提示

### 5.3 智能测试建议

如果检测到函数有除法操作，但测试未覆盖 `b=0`：

```
💡 建议添加测试：测试 除法_除零
[自动生成测试模板]
```

点击后，自动在 `.yct` 中插入：

```御程
除法_除零:
    断言_失败值(除法(10, 0), "除零错误")
```

---

## 六、问题面板统一展示

### 6.1 分类展示

- **静态问题**（来自即时检查）
- **测试失败**（来自断言测试）
- **链路断裂**（来自一致性检查）
- **性能警告**（来自阻塞检测）

### 6.2 过滤器

- 按类型：契约 / 测试 / 性能 / 可访问性
- 按严重性：错误 / 警告 / 建议

### 6.3 快捷操作

- 点击问题 → 跳转到具体文件/行号
- 右键测试用例 → "仅运行此测试"
- 失败断言 → "跳转到实现"

---

## 七、即时检查与断言测试的关系

### 7.1 不是冗余，而是分层

| 维度 | 即时检查（L1/L2） | 断言测试（L3） |
|------|-------------------|----------------|
| 目的 | 快速反馈，防止低级错误 | 全面验证，证明行为正确 |
| 时机 | 编码时 / 保存时 | 提交前 / CI 阶段 |
| 执行方式 | 静态分析 + 规则匹配 | 实际运行代码 + 断言 |
| 依赖 | .yc 契约 + 规则库 | .yc + .yci + .yct + 运行时 |

### 7.2 共享同一套契约源

```
.yc 契约文件（Single Source of Truth）
        ↓
   ┌────┴────┐
   ↓         ↓
即时检查   断言测试
（语法检查器）（行为证明器）
```

- 所有规则源于 `.yc`
- 测试可由契约生成
- IDE 统一呈现问题

---

## 八、CLI 命令

```bash
# 检查单个文件
yucheng check file.ycs

# 检查整个项目
yucheng check --project

# 带阻塞检测
yucheng check --project --blocking

# 生成审计报告
yucheng audit --output report.html

# 运行测试并检查覆盖率
yucheng test --coverage --check-contracts
```

---

## 九、配置选项

```yaml
# .yucheng/config.yaml

检查配置:
  自动检查: 轻量模式  # 关闭 / 轻量模式 / 严格模式
  保存时检查: 是
  阻塞检测: 是
  无障碍检查: 是
  
性能阈值:
  静态检查超时: 200毫秒
  增量测试超时: 1秒
  全量测试超时: 30秒
  UI阻塞阈值: 16毫秒  # 60fps 一帧
  
报告配置:
  输出格式: [HTML, JSON, Markdown]
  包含截图: 是
  包含性能图表: 是
```

---

## 十、总结

御程 IDE 智能检查系统的核心价值：

1. **即时反馈**：编码时就能发现问题，而非等到测试阶段
2. **分层验证**：静态检查防"写错"，断言测试证"做对"
3. **阻塞防护**：从语言级到运行时，全方位保障 UI 流畅性
4. **统一视图**：所有问题在一个面板展示，支持快速定位和修复
5. **智能建议**：自动生成测试模板，降低可靠性编程门槛

这使得御程成为**首个将可信验证深度集成到 IDE 的中文编程语言**，让可靠性成为默认状态而非额外负担。
