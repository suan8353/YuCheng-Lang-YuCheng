# 御程语言友好错误系统

> **实现状态**: ✅ 完整实现
> - ✅ 友好错误系统完整实现（`friendly_errors.rs`）
> - ✅ ErrorPatternMatcher 已实现
> - ✅ InstantChecker 已实现
> - ✅ FriendlyError 数据结构完整
> - ✅ 错误分类和严重程度系统完整
> 
> **代码位置**: `compiler/src/friendly_errors.rs`

## 一、设计理念

> **错误信息是给"正在学习的人"看的，而不是给"已经理解系统的人"看的。**

传统语言的错误信息（如 `NullPointerException`、`TypeError`）对新手来说是天书。御程的友好错误系统将技术错误转换为：

- **自然语言解释**：不是 "NullPointerException"，而是 "你忘了检查这个值是否存在"
- **编码时发现**：不是运行后报错，而是保存时就提示
- **一键修复建议**：不是让你去 Google，而是直接给出可操作的代码
- **培养工程思维**：不是替你写代码，而是教你正确的编程习惯

---

## 二、系统架构

### 2.1 核心组件

```
┌─────────────────────────────────────────────────────────┐
│                    友好错误系统                          │
├─────────────────────────────────────────────────────────┤
│  ErrorPatternMatcher    │  将技术错误转换为友好格式      │
│  InstantChecker         │  实时检查代码中的潜在问题      │
│  FriendlyError          │  友好错误数据结构              │
│  PotentialIssue         │  潜在问题数据结构              │
└─────────────────────────────────────────────────────────┘
```

### 2.2 错误分类

| 分类 | 说明 | 示例 |
|------|------|------|
| NullOrUndefined | 空值/未定义问题 | 访问可能为空的变量 |
| TypeMismatch | 类型不匹配 | 期望数字但传入文本 |
| BoundaryNotHandled | 边界未处理 | 除零、索引越界 |
| ContractViolation | 契约违规 | 前置条件不满足 |
| StateNotHandled | 状态未处理 | 只处理成功，忽略失败 |
| AsyncIssue | 异步问题 | 未等待异步操作 |
| ResourceLeak | 资源泄漏 | 未关闭文件句柄 |
| SyntaxError | 语法错误 | 括号不匹配 |
| LogicError | 逻辑错误 | 条件永远为假 |
| PerformanceIssue | 性能问题 | 主线程阻塞 |

### 2.3 严重程度

| 级别 | 图标 | 说明 |
|------|------|------|
| Error | ❌ | 必须修复，否则程序无法正确运行 |
| Warning | ⚠️ | 建议修复，可能导致问题 |
| Hint | 💡 | 提示信息，可以改进 |
| Learning | 📚 | 学习建议，培养好习惯 |

---

## 三、即时检查器 (InstantChecker)

### 3.1 检查模式

即时检查器在编码时自动运行，检测以下潜在问题：

#### 空值访问检查
```御程
// 问题代码
变量 名字 = 用户.名字  // ⚠️ 用户可能为空

// 建议修复
如果 用户 != 空 {
    变量 名字 = 用户.名字
}
```

#### 除零风险检查
```御程
// 问题代码
变量 结果 = 总数 / 数量  // ⚠️ 数量可能为零

// 建议修复
如果 数量 != 0 {
    变量 结果 = 总数 / 数量
}
```

#### 索引越界检查
```御程
// 问题代码
变量 项目 = 列表[索引]  // ⚠️ 索引可能越界

// 建议修复
如果 索引 >= 0 且 索引 < 列表.长度 {
    变量 项目 = 列表[索引]
}
```

#### 错误处理检查
```御程
// 问题代码
变量 数据 = 发送请求("/api/user")  // ⚠️ 网络请求可能失败

// 建议修复
尝试 {
    变量 数据 = 发送请求("/api/user")
} 捕获 错误 {
    // 处理错误
}
```

#### 状态处理检查
```御程
// 问题代码
如果 状态 == 加载中 {  // ⚠️ 只处理了加载中，忽略了成功和失败
    显示加载动画()
}

// 建议修复
匹配 状态 {
    加载中 => 显示加载动画()
    成功 => 显示数据()
    失败 => 显示错误()
}
```

### 3.2 检查结果

```typescript
interface InstantCheckResult {
  success: boolean           // 是否无错误
  issues: PotentialIssue[]   // 问题列表
  summary: {
    total_issues: number     // 总问题数
    errors: number           // 错误数
    warnings: number         // 警告数
    hints: number            // 提示数
    learning: number         // 学习建议数
  }
}
```

---

## 四、错误模式匹配器 (ErrorPatternMatcher)

### 4.1 功能

将技术性错误信息转换为友好的自然语言解释：

| 技术错误 | 友好解释 |
|----------|----------|
| `NullPointerException` | 你试图使用一个可能为空的值，就像打开一个空盒子 |
| `TypeError: expected number` | 你传入了错误的类型，就像把方钉子塞进圆孔 |
| `IndexOutOfBounds` | 你访问了列表中不存在的位置，就像要第10个苹果但只有5个 |
| `DivisionByZero` | 你试图除以零，这在数学上是不可能的 |

### 4.2 友好错误结构

```typescript
interface FriendlyError {
  title: string              // 简短标题
  explanation: string        // 自然语言解释
  cause: string              // 为什么会发生
  suggestions: FixSuggestion[] // 修复建议
  learn_more: string | null  // 学习资源
  category: ErrorCategory    // 错误分类
  severity: ErrorSeverity    // 严重程度
  location: ErrorLocation    // 代码位置
}

interface FixSuggestion {
  description: string        // 修复描述
  fix_code: string | null    // 修复代码
  auto_fixable: boolean      // 是否可自动修复
  confidence: number         // 置信度 (0-100)
}
```

---

## 五、IDE 集成

### 5.1 智能检查面板

IDE 工具栏新增"🎓 智能检查"按钮，点击打开智能检查面板：

```
┌─────────────────────────────────────────┐
│ 🎓 智能检查                        [×] │
├─────────────────────────────────────────┤
│ ✓ 无问题  │ 2 警告 │ 1 提示 │ 1 学习   │
├─────────────────────────────────────────┤
│                                         │
│ ⚠️ 行 5: 空值问题                       │
│    用户可能为空，访问前需要检查          │
│    💡 添加空值检查                       │
│    [🔧 应用修复]                        │
│                                         │
│ ⚠️ 行 12: 边界未处理                    │
│    除数可能为零                          │
│    💡 添加零值检查                       │
│    [🔧 应用修复]                        │
│                                         │
│ 💡 行 18: 索引越界风险                  │
│    索引可能超出列表范围                  │
│    💡 添加边界检查                       │
│                                         │
│ 📚 行 25: 契约建议                      │
│    函数有参数但没有契约                  │
│    💡 考虑添加前置条件验证输入           │
│                                         │
└─────────────────────────────────────────┘
```

### 5.2 实时检查

- 代码变更后 500ms 自动触发检查
- 检查结果实时更新到面板
- 支持一键应用修复建议

### 5.3 Tauri 命令

```rust
// 即时检查代码
#[tauri::command]
fn check_instant(code: &str) -> InstantCheckResult

// 将技术错误转换为友好格式
#[tauri::command]
fn make_friendly_error(
    error_msg: &str, 
    code: &str, 
    line: usize, 
    column: usize
) -> Option<FriendlyErrorInfo>

// 获取友好错误报告
#[tauri::command]
fn get_friendly_report(code: &str) -> String
```

---

## 六、使用示例

### 6.1 新手场景

新手写了一个函数：

```御程
函数 计算折扣(原价: 数字, 折扣率: 数字) -> 数字 {
    返回 原价 * 折扣率
}
```

智能检查面板提示：

```
📚 行 1: 契约建议
   函数有参数但没有契约验证
   
   💡 建议：添加前置条件验证输入
   
   考虑添加：
   要求 折扣率 >= 0 且 折扣率 <= 1
   
   这样可以防止传入非法的折扣率（如 1.5 或 -0.1）
```

### 6.2 错误转换场景

运行时报错：

```
TypeError: Cannot read property 'name' of null
```

友好错误面板显示：

```
❌ 空值访问

📖 解释
你试图使用 'user' 但它可能是空的（null）。
这就像试图打开一个空盒子——里面什么都没有！

🔍 原因
变量 'user' 可能还没有被赋值。

💡 建议修复

1. 检查值是否存在后再使用 (95% 置信度)
   如果 user != 空 {
       // 在这里安全使用 user
   }
   [应用此修复]

2. 提供默认值 (80% 置信度)
   user = user ?? 默认值
   [应用此修复]

📚 了解更多
空值是编程中最常见的错误来源。
在使用任何值之前，都要检查它是否存在。
就像收快递前要先确认包裹已经到了一样。
```

---

## 七、实现状态

### 7.1 已完成 ✅

| 功能 | 状态 | 测试数 |
|------|------|--------|
| ErrorPatternMatcher | ✅ | 5 |
| InstantChecker | ✅ | 6 |
| FriendlyError 数据结构 | ✅ | - |
| PotentialIssue 数据结构 | ✅ | - |
| 空值访问检查 | ✅ | 1 |
| 除零风险检查 | ✅ | 1 |
| 索引越界检查 | ✅ | 1 |
| 错误处理检查 | ✅ | 1 |
| 状态处理检查 | ✅ | 1 |
| 契约建议 | ✅ | 1 |
| IDE Tauri 命令 | ✅ | - |
| FriendlyErrorPanel.vue | ✅ | - |
| 工具栏集成 | ✅ | - |

### 7.2 待完成 ⏳

| 功能 | 优先级 |
|------|--------|
| 更多错误模式 | 中 |
| 自动修复应用 | 高 |
| 学习资源链接 | 低 |
| 多语言支持 | 低 |

---

## 八、总结

友好错误系统的核心价值：

1. **降低学习门槛**：新手不再被技术术语吓退
2. **即时反馈**：编码时就能发现问题，而非运行后
3. **可操作建议**：不只是告诉你错了，还告诉你怎么改
4. **培养好习惯**：通过"检查→修复"循环，自然学会契约驱动开发

> **御程的目标**：让第一个程序就值得上线。
