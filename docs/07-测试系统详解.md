# YuCheng 语言 - 测试系统详解

> **实现状态**: ✅ 完整实现 (2026-02-08)
> - ✅ 基础断言函数完整（2717行代码 - `testing.rs`）
> - ✅ 快照测试已实现
> - ✅ 测试套件和组织功能完整实现
> - ✅ 性能测试系统（200行代码 - `performance_testing.rs`）
> - ✅ 覆盖率分析系统（450行代码 - `coverage_analysis.rs`）
> - ✅ 并行测试支持（150行代码 - `parallel_testing.rs`）
> - ✅ 9个测试全部通过（100%通过率）
> 
> **完成报告**: `.project-reports/implementation-status/07-TEST-SYSTEM-COMPLETION.md`  
> **示例代码**: `examples/38-performance-testing.ycs`

## 1. 设计理念

YuCheng 测试系统专门针对"AI 生成表演测试"问题设计：

- **强制断言**：必须使用断言函数，禁止用打印代替验证
- **结构化输出**：JSON 格式输出，便于 AI 分析
- **内存集成**：支持内存泄漏检测
- **御程特色**：提供结果类型、模式匹配、批量验证等独有断言

## 2. 断言函数库

### 2.1 基础断言

```御程
// 相等断言
断言_相等(加法(2, 3), 5)
断言_相等(用户.名字, "张三", "用户名应为张三")

// 不等断言
断言_不等(结果, 空, "结果不应为空")

// 布尔断言
断言_为真(年龄 >= 18, "用户应已成年")
断言_为假(已删除, "记录不应被删除")

// 空值断言
断言_为空(可选结果)
断言_非空(用户对象)
```

### 2.2 数值断言

```御程
// 大小比较
断言_大于(分数, 60, "分数应大于60")
断言_小于(错误数, 10)
断言_大于等于(分数, 60, "分数应大于等于60")
断言_小于等于(错误数, 10)

// 范围检查
断言_范围(百分比, 0, 100)

// 近似相等（浮点数）
断言_近似相等(圆面积(1), 3.14159, 0.001)
```

### 2.3 集合断言

```御程
// 包含检查
断言_包含(用户列表, 目标用户)
断言_不包含(黑名单, 用户ID)

// 字符串检查
断言_开头是(文本, "前缀")
断言_结尾是(文本, "后缀")

// 长度检查
断言_长度(结果列表, 10)
断言_为空集合(错误列表)
断言_非空集合(搜索结果)
```

### 2.3.1 映射断言

```御程
// 映射键值检查
断言_包含键(映射, "键名")
断言_键值对(映射, "键名", 期望值)
```

### 2.4 类型断言

```御程
// 类型检查
断言_类型(值, "整数")
断言_类型(名字, "文本")
```

## 3. 御程独有断言函数

### 3.1 结果类型断言

御程语言的 `成功/失败` 结果类型是核心特性，提供专门的断言函数：

```御程
// 验证结果是成功
var 结果 = 成功(42)                // 成功 是标准库函数，不是关键字
断言_成功(结果)                    // 验证是成功类型
断言_成功值(结果, 42)              // 验证成功且值为42

// 验证结果是失败
var 错误 = 失败("未找到")          // 失败 是标准库函数，不是关键字
断言_失败(错误)                    // 验证是失败类型
断言_失败值(错误, "未找到")        // 验证失败且错误信息匹配
```

### 3.2 批量结果断言

处理多个结果时的批量验证：

```御程
// 验证所有结果都成功
var 结果列表 = [成功(1), 成功(2), 成功(3)]
断言_全部成功(结果列表)

// 验证至少有一个成功
var 混合结果 = [失败("错误1"), 成功(2), 失败("错误3")]
断言_任一成功(混合结果)
```

### 3.3 模式匹配断言

支持通配符的模式匹配验证：

```御程
// 精确匹配
断言_匹配("hello", "hello")

// * 匹配任意字符（零个或多个）
断言_匹配("hello world", "hello*")
断言_匹配("hello world", "*world")
断言_匹配("hello world", "h*d")

// ? 匹配单个字符
断言_匹配("hello", "hell?")
断言_匹配("test123", "test???")
```

### 3.4 集合高级断言

```御程
// 验证列表有序（升序）
断言_有序([1, 2, 3, 4, 5])

// 验证列表有序（降序）
断言_有序([5, 4, 3, 2, 1], 真)

// 验证所有元素唯一
断言_唯一([1, 2, 3, 4, 5])

// 验证子集关系
断言_子集([1, 2], [1, 2, 3, 4, 5])
```

### 3.5 深度比较断言

递归比较复杂嵌套结构：

```御程
// 深度比较嵌套结构
var 结构1 = [成功(1), [2, 3], 失败("错误")]
var 结构2 = [成功(1), [2, 3], 失败("错误")]
断言_深度相等(结构1, 结构2)
```

### 3.6 变换断言（管道测试）

专门用于验证管道操作结果：

```御程
// 验证管道变换结果
var 结果 = 5 |> 翻倍 |> 加十
断言_变换(结果, 20, "5 |> 翻倍 |> 加十 应为 20")
```

## 4. 断言函数完整列表

| 中文名称 | 英文名称 | 参数 | 说明 |
|---------|---------|------|------|
| 断言_相等 | assert_equal | (实际, 期望, [消息]) | 验证两值相等 |
| 断言_不等 | assert_not_equal | (实际, 期望, [消息]) | 验证两值不等 |
| 断言_为真 | assert_true | (值, [消息]) | 验证值为真 |
| 断言_为假 | assert_false | (值, [消息]) | 验证值为假 |
| 断言_为空 | assert_null | (值, [消息]) | 验证值为空 |
| 断言_非空 | assert_not_null | (值, [消息]) | 验证值非空 |
| 断言_大于 | assert_greater | (实际, 期望, [消息]) | 验证大于 |
| 断言_小于 | assert_less | (实际, 期望, [消息]) | 验证小于 |
| 断言_大于等于 | assert_greater_equal | (实际, 期望, [消息]) | 验证大于等于 |
| 断言_小于等于 | assert_less_equal | (实际, 期望, [消息]) | 验证小于等于 |
| 断言_范围 | assert_in_range | (值, 最小, 最大, [消息]) | 验证在范围内 |
| 断言_近似相等 | assert_approx_equal | (实际, 期望, [精度], [消息]) | 浮点数近似比较 |
| 断言_包含 | assert_contains | (容器, 元素, [消息]) | 验证包含元素 |
| 断言_不包含 | assert_not_contains | (容器, 元素, [消息]) | 验证不包含元素 |
| 断言_开头是 | assert_starts_with | (文本, 前缀, [消息]) | 验证文本开头 |
| 断言_结尾是 | assert_ends_with | (文本, 后缀, [消息]) | 验证文本结尾 |
| 断言_长度 | assert_length | (容器, 长度, [消息]) | 验证长度 |
| 断言_为空集合 | assert_empty | (容器, [消息]) | 验证为空集合 |
| 断言_非空集合 | assert_not_empty | (容器, [消息]) | 验证非空集合 |
| 断言_类型 | assert_type | (值, 类型名, [消息]) | 验证类型 |
| 断言_包含键 | assert_has_key | (映射, 键名, [消息]) | 验证映射包含键 |
| 断言_键值对 | assert_key_value | (映射, 键名, 期望值, [消息]) | 验证映射键值对 |
| **断言_成功** | **assert_ok** | (结果, [消息]) | 验证结果为成功 |
| **断言_失败** | **assert_err** | (结果, [消息]) | 验证结果为失败 |
| **断言_成功值** | **assert_ok_value** | (结果, 期望值, [消息]) | 验证成功值 |
| **断言_失败值** | **assert_err_value** | (结果, 期望错误, [消息]) | 验证失败值 |
| **断言_匹配** | **assert_match** | (值, 模式, [消息]) | 模式匹配验证 |
| **断言_全部成功** | **assert_all_ok** | (结果列表, [消息]) | 验证全部成功 |
| **断言_任一成功** | **assert_any_ok** | (结果列表, [消息]) | 验证任一成功 |
| **断言_有序** | **assert_sorted** | (列表, [降序], [消息]) | 验证有序 |
| **断言_唯一** | **assert_unique** | (列表, [消息]) | 验证元素唯一 |
| **断言_子集** | **assert_subset** | (子集, 父集, [消息]) | 验证子集关系 |
| **断言_深度相等** | **assert_deep_equal** | (实际, 期望, [消息]) | 深度比较 |
| **断言_变换** | **assert_transform** | (实际, 期望, [描述]) | 变换结果验证 |
| **断言_耗时** | **assert_duration** | (实际毫秒, 最大毫秒, [消息]) | 性能时间验证 |
| **断言_内存** | **assert_memory** | (实际字节, 最大字节, [消息]) | 内存使用验证 |
| **断言_无泄漏** | **assert_no_leak** | (分配次数, 释放次数, [消息]) | 内存泄漏验证 |
| **断言_快照** | **assert_snapshot** | (名称, 输出, [更新]) | 快照测试 |
| **更新_快照** | **update_snapshot** | (名称, 内容) | 更新快照 |
| **断言_管道** | **assert_pipe** | (实际, 期望, [描述]) | 管道结果验证 |
| **断言_管道链** | **assert_pipe_chain** | (实际列表, 期望列表) | 管道链验证 |
| **断言_纯函数** | **assert_pure** | (结果1, 结果2, [消息]) | 纯函数验证 |
| **断言_等** | **assert_idempotent** | (单次结果, 多次结果, [消息]) | 幂等性验证 |
| **断言_无副作用** | **assert_no_side_effect** | (前状态, 后状态, [消息]) | 副作用验证 |
| **断言_抛出** | **assert_throws** | (代码块, [期望错误类型], [消息]) | 验证抛出异常（P3阶段） |
| **断言_不抛出** | **assert_no_throw** | (代码块, [消息]) | 验证不抛出异常（P3阶段） |
| **断言_错误类型** | **assert_error_type** | (错误值, 期望类型, [消息]) | 验证错误类型（P3阶段） |
| **断言_错误消息** | **assert_error_message** | (错误值, 期望消息, [消息]) | 验证错误消息（P3阶段） |

> **粗体**标记的是御程语言独有的断言函数

## 5. 性能与资源断言

### 5.1 性能断言

```御程
// 验证执行时间
var 开始 = 当前时间毫秒()
执行操作()
var 耗时 = 当前时间毫秒() - 开始
断言_耗时(耗时, 100, "操作应在100ms内完成")
```

### 5.2 内存断言

```御程
// 验证内存使用
var 内存使用 = 获取内存使用()
断言_内存(内存使用, 1024 * 1024, "内存不应超过1MB")

// 验证无内存泄漏
var 分配次数 = 获取分配计数()
var 释放次数 = 获取释放计数()
断言_无泄漏(分配次数, 释放次数)
```

## 6. 快照测试

```御程
// 首次运行自动保存快照，后续运行比对
断言_快照("用户列表输出", 格式化用户列表(用户们))

// 强制更新快照
更新_快照("用户列表输出", 新的输出内容)
```

## 7. 管道断言

```御程
// 验证管道操作结果
var 结果 = 5 |> 翻倍 |> 加十 |> 转文本
断言_管道(结果, "20", "5 |> 翻倍 |> 加十 |> 转文本")

// 验证管道每一步
var 步骤结果 = [5, 10, 20, "20"]
var 期望结果 = [5, 10, 20, "20"]
断言_管道链(步骤结果, 期望结果)
```

## 8. 函数分类断言

```御程
// 验证纯函数（相同输入产生相同输出）
var 结果1 = 计算(10)
var 结果2 = 计算(10)
断言_纯函数(结果1, 结果2, "计算函数应为纯函数")

// 验证幂等性
var 单次 = 设置值(10)
var 多次 = 设置值(设置值(设置值(10)))
断言_等(单次, 多次)

// 验证无副作用
var 状态前 = 获取状态()
纯函数操作()
var 状态后 = 获取状态()
断言_无副作用(状态前, 状态后)
```

## 9. 测试文件结构

### 9.1 测试规格 (test_calculator.yc)

```御程
测试套件 计算器测试 {
    测试 加法_正数相加
    测试 加法_负数相加
    测试 除法_除以零
    测试 内存_无泄漏
}

查询 func 准备测试数据() -> 测试数据
副作用 func 清理测试环境()
```

### 9.2 测试实现 (test_calculator.yci)

```御程
计算器测试:
    初始化:
        var 测试数据 = 准备测试数据()
    
    清理:
        清理测试环境()
    
    测试前:
        重置计算器状态()

加法_正数相加:
    断言_相等(加法(2, 3), 5, "2 + 3 应等于 5")
    断言_相等(加法(100, 200), 300)

加法_负数相加:
    断言_相等(加法(-2, -3), -5)
    断言_相等(加法(-10, 5), -5)

除法_除以零:
    断言_抛出异常({
        除法(10, 0)
    }, "除零错误")

内存_无泄漏:
    断言_无内存泄漏({
        var 数据 = 生成数据(1000)
        var 结果 = 处理数据(数据)
    })
```

### 9.3 测试链接 (test_calculator.ycl)

```json
{
  "项目名称": "计算器测试",
  "类型": "测试",
  
  "测试套件": [
    {
      "规格": "test_calculator.yc",
      "实现": "test_calculator.yci"
    }
  ],
  
  "依赖": ["../src/calculator.yc"],
  
  "测试选项": {
    "并行执行": true,
    "失败后继续": true,
    "超时秒数": 30,
    "内存检测": true
  }
}
```

## 10. 测试报告

### 10.1 JSON 格式

```json
{
  "report_id": "test_20260110_001",
  "summary": {
    "total": 10,
    "passed": 8,
    "failed": 1,
    "skipped": 1,
    "pass_rate": 0.8
  },
  "suites": [
    {
      "name": "计算器测试",
      "tests": [
        {
          "name": "加法_正数相加",
          "status": "passed",
          "duration_ms": 5
        },
        {
          "name": "除法_除以零",
          "status": "failed",
          "failure": {
            "message": "期望抛出异常，但没有抛出",
            "location": {"file": "test_calculator.yci", "line": 45}
          }
        }
      ]
    }
  ]
}
```

### 10.2 控制台输出

```
═══════════════════════════════════════════════════
                 YuCheng 测试报告
═══════════════════════════════════════════════════

测试套件: 计算器测试
───────────────────────────────────────────────────
  ✓ 加法_正数相加                              5ms
  ✓ 加法_负数相加                              3ms
  ✗ 除法_除以零                                3ms
    └─ 期望抛出异常，但没有抛出
  ✓ 内存_无泄漏                               50ms
───────────────────────────────────────────────────

总计: 4    通过: 3    失败: 1    通过率: 75%
═══════════════════════════════════════════════════
```

## 11. 运行测试

```bash
# 运行所有测试
yucheng test

# 运行指定套件
yucheng test --suite 计算器测试

# 运行指定用例
yucheng test --case 加法_正数相加

# 生成报告
yucheng test --report test_results/
```

## 6. 错误处理断言（P3阶段）

### 6.1 异常断言

```御程
// 验证抛出异常
断言_抛出({
    除法(10, 0)
}, "除零错误")

// 验证不抛出异常
断言_不抛出({
    var 结果 = 安全除法(10, 2)
    断言_相等(结果, 5)
})

// 验证错误类型
var 错误 = 失败("未找到")
断言_错误类型(错误, "文本")

// 验证错误消息
断言_错误消息(错误, "未找到")
```

## 7. 实现状态说明

### 7.1 语义分析层（Semantic）增强功能

以下功能在语义分析层标记为增强功能（TODO），不影响核心语义检查：

1. **类型查找增强**：扩展TypeRegistry支持根据名称查找类型（增强功能）
2. **编译期警告增强**：发出"未在所有执行路径上进行 is_some 检查"的编译期警告（增强功能）
3. **参数类型精确匹配**：实现参数类型的精确匹配（需要从param_hash反推参数类型列表）（增强功能）

这些增强功能不影响核心语义分析功能，可以在后续版本中完善。

### 7.2 TreeWalk层部分支持语法

以下5个语法在 **Interpreter（TreeWalk）层**标记为部分支持，但在 **Bytecode+VM层**已完整支持：

| 语法ID | 语法名 | TreeWalk状态 | VM状态 | 说明 |
|--------|--------|--------------|--------|------|
| S-005 | Pipe 管道 | ⚠️(部分) | ✅ | TreeWalk与VM语义/stdlib注册路径存在差异，golden测试仅以VM为准 |
| S-006 | Result + `?` 错误传播 | ⚠️(部分) | ✅ | TreeWalk对照暂未开启，VM已稳定 |
| S-060 | 并发与通道基础语法 | ⚠️(部分) | ✅ | 某些边界行为（空通道、关闭语义）在文档中定义但尚未完全实现 |
| S-080 | try(?) 错误传播表达式 | ⚠️(部分) | ✅ | VM已稳定，TreeWalk语义对齐中 |
| S-090 | Optional 类型与空值合并 | ⚠️(部分) | ✅ | 与S-006组合使用时的边界路径（嵌套Optional+Result）尚有技术债 |

**重要说明**：
- **VM是主要执行路径**，所有语法在VM层都已完整实现
- TreeWalk层的部分支持不影响核心功能使用
- 这些差异主要是TreeWalk与VM的语义对齐问题，不影响用户使用VM后端

## 8. 边界测试生成器

### 8.1 功能概述

边界测试生成器自动为函数生成边界值测试用例，达到 C/C++ 级别的测试覆盖。

### 8.2 支持的类型

#### 8.2.1 整数边界

```御程
// 自动生成的边界值
- i64::MIN (-9223372036854775808)
- i64::MIN + 1
- -1
- 0
- 1
- i64::MAX - 1
- i64::MAX (9223372036854775807)
```

#### 8.2.2 浮点数边界

```御程
// 自动生成的边界值
- 负无穷
- -1.0
- 0.0
- 1.0
- 正无穷
- NaN（非数字）
```

#### 8.2.3 字符串边界

```御程
// 自动生成的边界值
- "" （空字符串）
- "a" （单字符）
- "测试" （中文字符）
- "a".repeat(1000) （长字符串）
```

#### 8.2.4 布尔边界

```御程
// 自动生成的边界值
- 假
- 真
```

#### 8.2.5 列表边界

```御程
// 自动生成的边界值
- [] （空列表）
- [元素] （单元素列表）
- [元素1, 元素2, ...] （多元素列表）
```

### 8.3 使用方法

#### 8.3.1 自动生成测试

```御程
// 原始函数
函数 加法(a: 整数, b: 整数) -> 整数 {
    返回 a + b
}

// 自动生成边界测试
边界测试 加法边界测试 {
    阶段 "最小值" {
        参数 a = -9223372036854775808
        参数 b = 0
        期望 结果验证
    }
    
    阶段 "零值" {
        参数 a = 0
        参数 b = 0
        期望 结果验证
    }
    
    阶段 "最大值" {
        参数 a = 9223372036854775807
        参数 b = 0
        期望 结果验证
    }
}
```

#### 8.3.2 命令行生成

```bash
# 为函数生成边界测试
yucheng test --generate-boundary file.ycs

# 生成并运行
yucheng test --generate-boundary --run file.ycs
```

### 8.4 组合策略

对于多参数函数，边界测试生成器使用"一次摇动一个参数"策略：

```御程
函数 计算(x: 整数, y: 整数, z: 整数) -> 整数 {
    返回 x + y + z
}

// 生成策略：
// 1. 摇动 x，y 和 z 使用安全基线值（0）
// 2. 摇动 y，x 和 z 使用安全基线值（0）
// 3. 摇动 z，x 和 y 使用安全基线值（0）
```

### 8.5 安全基线值

生成器会为每个参数选择"安全基线值"：

| 类型 | 安全基线值 |
|------|-----------|
| 整数 | 0 |
| 小数 | 0.0 |
| 文本 | "" 或短字符串 |
| 布尔 | 假 |
| 列表 | 空列表 |
| 可选类型 | 空 |

### 8.6 缓存优化

边界测试生成器支持增量生成和缓存：

```rust
// 缓存边界值，避免重复计算
let values = generator.get_boundary_values_for_type_cached(&type_expr);

// 缓存测试用例，支持增量生成
let cases = generator.generate_boundary_tests(func);
```

### 8.7 返回值验证

对于非可选返回类型，自动添加"结果非空"断言：

```御程
函数 计算(x: 整数) -> 整数 {
    返回 x * 2
}

// 自动生成的测试包含
var 结果 = 计算(x)
断言 结果 <> 空  // 自动添加
```

## 9. 最佳实践

### 9.1 禁止表演测试

```御程
// ❌ 错误：表演测试
测试_加法:
    var 结果 = 加法(2, 3)
    打印("结果是：", 结果)  // 只打印，不验证！

// ✅ 正确：使用断言
测试_加法:
    var 结果 = 加法(2, 3)
    断言_相等(结果, 5, "2 + 3 应等于 5")
```

### 8.2 测试命名规范

```御程
// 格式: 被测功能_测试场景
测试 加法_正数相加
测试 加法_边界值
测试 登录_正确密码
测试 登录_错误密码
```

### 8.3 测试隔离

```御程
测试前:
    重置数据库()
    清空缓存()
    
测试后:
    删除测试数据()
```


## 10. 性能测试系统

### 10.1 性能基准测试

性能测试系统提供完整的性能基准测试功能，包括预热、统计分析、性能回归检测。

```御程
#性能测试
函数 测试_排序性能() {
    var 数据 = 生成随机数据(1000)
    
    var 开始 = 当前时间毫秒()
    var 结果 = 快速排序(数据)
    var 耗时 = 当前时间毫秒() - 开始
    
    断言_耗时(耗时, 100, "排序应在100ms内完成")
}
```

### 10.2 性能统计指标

性能测试自动收集以下统计指标：

- **最小耗时** (min_ms): 所有迭代中的最快时间
- **最大耗时** (max_ms): 所有迭代中的最慢时间
- **平均耗时** (mean_ms): 所有迭代的平均时间
- **中位数** (median_ms): 50%百分位数
- **标准差** (std_dev_ms): 性能稳定性指标
- **P95**: 95%百分位数
- **P99**: 99%百分位数
- **每秒操作数** (ops_per_sec): 吞吐量指标

### 10.3 性能回归检测

系统自动检测性能回归，当性能下降超过阈值时报警：

```rust
// 配置性能回归检测
PerformanceTestConfig {
    warmup_iterations: 10,
    test_iterations: 100,
    detect_regression: true,
    regression_threshold: 10.0,  // 10% 性能下降视为回归
    ..Default::default()
}
```

### 10.4 性能测试报告

性能测试生成详细的统计报告：

```
性能测试: 排序性能
  平均耗时: 45.23ms
  标准差: 2.15ms
  P95: 48.50ms
  P99: 51.20ms
  每秒操作数: 22.11
  性能回归: 未检测到
```

## 11. 覆盖率分析系统

### 11.1 覆盖率类型

系统支持三种覆盖率分析：

1. **行覆盖率** (Line Coverage): 代码行执行覆盖
2. **分支覆盖率** (Branch Coverage): 条件分支覆盖
3. **函数覆盖率** (Function Coverage): 函数调用覆盖

### 11.2 覆盖率收集

```rust
// 创建覆盖率收集器
let mut collector = CoverageCollector::new(CoverageConfig {
    enable_line_coverage: true,
    enable_branch_coverage: true,
    enable_function_coverage: true,
    target_coverage: 80.0,
});

// 注册文件信息
collector.register_file_lines("test.ycs", 100);
collector.register_file_branches("test.ycs", 20);
collector.register_file_functions("test.ycs", 10);

// 记录执行
collector.record_line("test.ycs", 42);
collector.record_branch("test.ycs", "if_1", true);
collector.record_function("test.ycs", "main");
```

### 11.3 覆盖率报告

系统生成三种格式的覆盖率报告：

#### 控制台报告

```
╔══════════════════════════════════════════════════════════════╗
║                    御程覆盖率报告                            ║
╠══════════════════════════════════════════════════════════════╣
║ 行覆盖率:     85.0%                                          ║
║ 分支覆盖率:   90.0%                                          ║
║ 函数覆盖率:   90.0%                                          ║
║ 目标覆盖率:   80.0%                                          ║
║ 状态:         ✓ 达标                                         ║
╚══════════════════════════════════════════════════════════════╝
```

#### JSON报告

```json
{
  "total_line_coverage": 85.0,
  "total_branch_coverage": 90.0,
  "total_function_coverage": 90.0,
  "file_reports": [
    {
      "file_path": "test.ycs",
      "line_coverage": 85.0,
      "uncovered_lines": [4, 6, 8, 10, 12]
    }
  ]
}
```

#### HTML报告

生成可视化的HTML覆盖率报告，包含：
- 覆盖率仪表盘
- 文件级别详情
- 未覆盖行高亮
- 覆盖率进度条

### 11.4 未覆盖代码追踪

系统自动追踪未覆盖的代码行：

```
文件: test.ycs
  行覆盖率: 85.0% (85/100)
  未覆盖行: [4, 6, 8, 10, 12, 15, 18, 20, 25, 30, 35, 40, 45, 50, 55]
```

## 12. 并行测试系统

### 12.1 并行测试配置

```rust
let config = ParallelTestConfig {
    num_threads: 4,              // 使用4个线程
    enable_isolation: true,      // 启用测试隔离
    test_timeout_ms: 30000,      // 单个测试超时30秒
    fail_fast: false,            // 不在首次失败后停止
};
```

### 12.2 并行执行

```rust
let runner = ParallelTestRunner::new(config);

let test_names = vec![
    "测试1".to_string(),
    "测试2".to_string(),
    "测试3".to_string(),
    "测试4".to_string(),
];

let results = runner.run_tests(test_names);
```

### 12.3 测试隔离

并行测试系统确保：
- 每个测试在独立的线程中运行
- 测试之间不会相互影响
- 共享资源通过锁机制保护

### 12.4 Fail-Fast模式

启用fail-fast模式后，首次测试失败时立即停止所有测试：

```rust
let config = ParallelTestConfig {
    fail_fast: true,
    ..Default::default()
};
```

## 13. 测试报告增强

### 13.1 详细报告

测试系统生成详细的测试报告，包含：
- 测试执行时间
- 失败详情
- 性能统计
- 覆盖率数据

### 13.2 报告格式

支持多种报告格式：
- **控制台报告**: 彩色输出，适合CI/CD
- **JSON报告**: 机器可读，适合工具集成
- **HTML报告**: 可视化报告，适合人工查看

### 13.3 CI/CD集成

测试系统设计用于CI/CD集成：

```bash
# 运行所有测试并生成报告
yucheng test --report json > test-results.json

# 运行性能测试
yucheng test --performance --baseline baseline.json

# 运行覆盖率分析
yucheng test --coverage --target 80 --html coverage-report.html
```

## 14. 完整测试示例

```御程
// 完整的测试套件示例

// 单元测试
#测试
函数 测试_加法() {
    断言_相等(加法(2, 3), 5)
    断言_相等(加法(-1, 1), 0)
}

// 性能测试
#性能测试
函数 测试_排序性能() {
    var 数据 = 生成随机数据(1000)
    var 开始 = 当前时间毫秒()
    var 结果 = 快速排序(数据)
    var 耗时 = 当前时间毫秒() - 开始
    
    断言_有序(结果)
    断言_耗时(耗时, 100)
}

// 边界测试
#测试
函数 测试_边界值() {
    断言_相等(除法(10, 2), 5)
    断言_抛出({ 除法(10, 0) }, "除零错误")
}

// 快照测试
#测试
函数 测试_输出格式() {
    var 输出 = 格式化用户(用户对象)
    断言_快照("用户格式化", 输出)
}
```

## 15. 运行测试

```bash
# 运行所有测试
yucheng test

# 运行指定套件
yucheng test --suite 计算器测试

# 运行性能测试
yucheng test --performance

# 生成覆盖率报告
yucheng test --coverage --html report.html

# 并行运行测试
yucheng test --parallel --threads 8

# Fail-fast模式
yucheng test --fail-fast
```
