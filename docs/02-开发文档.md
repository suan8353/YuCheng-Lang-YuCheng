# YuCheng 语言 - 开发文档

## 1. 开发环境搭建

### 1.1 必需工具

| 工具 | 版本要求 | 用途 |
|------|---------|------|
| Rust | 1.75+ | 编译器核心开发 |
| Node.js | 20+ | IDE 前端开发 |
| pnpm | 8+ | 包管理 |
| VS Code | 最新 | 开发 IDE |

### 1.2 项目结构

```
yucheng-lang/
├── compiler/                 # 编译器核心 (Rust)
│   ├── src/
│   │   ├── main.rs          # CLI 入口
│   │   ├── lib.rs           # 库导出
│   │   ├── preprocessor.rs  # 符号预处理器
│   │   ├── lexer.rs         # 词法分析器
│   │   ├── token.rs         # Token 定义
│   │   ├── keywords.rs      # 关键字映射（中英文）
│   │   ├── parser.rs        # 语法分析器
│   │   ├── ast.rs           # AST 定义
│   │   ├── analyzer.rs      # 语义分析器
│   │   ├── semantic.rs      # 语义分析（编译期检查）
│   │   ├── linker.rs        # 链接检查器
│   │   ├── interpreter.rs        # 树遍历解释器
│   │   ├── bytecode.rs     # 字节码编译器和虚拟机
│   │   ├── llvm_backend.rs # LLVM 后端
│   │   ├── llvm21_backend.rs # LLVM 21 后端
│   │   ├── wasm_backend.rs  # WebAssembly 后端
│   │   ├── compiler.rs      # 统一编译驱动器
│   │   ├── stdlib.rs        # 标准库
│   │   ├── memory.rs        # 内存模拟器
│   │   ├── testing.rs       # 测试框架
│   │   ├── ffi.rs           # FFI 管理器
│   │   ├── external.rs      # 外部库调用
│   │   ├── python_interop.rs # Python 互操作
│   │   ├── lang_interop.rs  # 多语言互操作
│   │   ├── ui/              # UI 系统
│   │   │   ├── mod.rs
│   │   │   ├── lexer.rs
│   │   │   ├── parser.rs
│   │   │   ├── ast.rs
│   │   │   └── renderer.rs
│   │   ├── layers/          # 分层架构模块
│   │   │   ├── mod.rs
│   │   │   ├── foundation.rs
│   │   │   ├── compilation.rs
│   │   │   ├── domain.rs
│   │   │   ├── service.rs
│   │   │   └── application.rs
│   │   └── ...              # 其他模块（100+ 文件）
│   ├── Cargo.toml
│   └── tests/               # 测试文件
│
├── ide/                      # IDE 界面 (Tauri + Vue)
│   ├── src/
│   │   ├── main.ts
│   │   ├── components/
│   │   │   ├── Editor.vue
│   │   │   ├── FileTree.vue
│   │   │   ├── MemoryChart.vue
│   │   │   └── Console.vue
│   │   └── stores/
│   ├── src-tauri/
│   │   └── src/
│   │       └── main.rs
│   ├── package.json
│   └── tauri.conf.json
│
├── stdlib/                   # 标准库
│   ├── core.yc              # 核心函数声明
│   ├── core.yci             # 核心函数实现
│   ├── io.yc                # 输入输出
│   ├── math.yc              # 数学函数
│   ├── test.yc              # 测试函数
│   └── ui.yc                # 界面函数
│
├── examples/                 # 示例项目
│   ├── hello-world/
│   ├── calculator/
│   └── login-app/
│
└── docs/                     # 文档
```

## 2. 编译器开发

### 2.1 词法分析器 (Lexer)

#### Token 定义

```rust
// compiler/src/lexer/token.rs

#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    // 关键字
    Var,        // var
    Func,       // func
    Class,      // class
    If,         // 如果
    Else,       // 否则
    Loop,       // 循环
    Return,     // 返回
    
    // 指针关键字
    Ptr,        // ptr
    AutoPtr,    // auto_ptr
    
    // 函数分类关键字
    PureFunc,     // 纯函数
    QueryFunc,    // 查询
    EffectFunc,   // 副作用
    
    // 契约关键字
    Requires,     // 要求
    Ensures,      // 保证
    
    // 运算符
    Assign,       // <-
    Equal,        // ==
    NotEqual,     // <>
    Greater,      // >
    Less,         // <
    GreaterEq,    // >=
    LessEq,       // <=
    Plus,         // +
    Minus,        // -
    Multiply,     // *
    Divide,       // /
    And,          // &&
    Or,           // ||
    Not,          // !
    
    // 数据流符号
    Output,       // =>
    Input,        // <=
    
    // 分隔符
    LeftParen,    // (
    RightParen,   // )
    LeftBrace,    // {
    RightBrace,   // }
    LeftBracket,  // [
    RightBracket, // ]
    Comma,        // ,
    Colon,        // :
    
    // 字面量
    Identifier(String),
    StringLiteral(String),
    NumberLiteral(f64),
    BoolLiteral(bool),
    
    // 特殊
    Newline,
    Indent,
    Dedent,
    EOF,
}

#[derive(Debug, Clone)]
pub struct Token {
    pub token_type: TokenType,
    pub lexeme: String,
    pub line: usize,
    pub column: usize,
}
```

#### 符号预处理器

```rust
// compiler/src/lexer/sanitizer.rs

use std::collections::HashMap;

pub struct SymbolSanitizer {
    mapping: HashMap<char, char>,
}

impl SymbolSanitizer {
    pub fn new() -> Self {
        let mut mapping = HashMap::new();
        
        // 括号类
        mapping.insert('（', '(');
        mapping.insert('）', ')');
        mapping.insert('｛', '{');
        mapping.insert('｝', '}');
        mapping.insert('［', '[');
        mapping.insert('］', ']');
        
        // 标点类
        mapping.insert('，', ',');
        mapping.insert('；', ';');
        mapping.insert('：', ':');
        mapping.insert('。', '.');
        
        // 运算符类
        mapping.insert('＋', '+');
        mapping.insert('－', '-');
        mapping.insert('＊', '*');
        mapping.insert('／', '/');
        mapping.insert('＝', '=');
        mapping.insert('＜', '<');
        mapping.insert('＞', '>');
        
        // 引号类
        mapping.insert('"', '"');
        mapping.insert('"', '"');
        mapping.insert(''', '\'');
        mapping.insert(''', '\'');
        
        Self { mapping }
    }
    
    pub fn sanitize(&self, source: &str) -> String {
        let mut result = String::new();
        let mut in_string = false;
        
        for ch in source.chars() {
            // 检测字符串边界
            if ch == '"' || ch == '\'' {
                in_string = !in_string;
                result.push(ch);
                continue;
            }
            
            // 字符串内部不做替换
            if in_string {
                result.push(ch);
                continue;
            }
            
            // 查表替换
            if let Some(&mapped) = self.mapping.get(&ch) {
                result.push(mapped);
            } else {
                result.push(ch);
            }
        }
        
        result
    }
}
```

### 2.2 语法分析器 (Parser)

#### AST 节点定义

```rust
// compiler/src/parser/ast.rs

#[derive(Debug, Clone)]
pub enum AstNode {
    // 程序结构
    Program(Vec<AstNode>),
    
    // 声明
    VarDecl {
        name: String,
        var_type: Option<String>,
        initial_value: Option<Box<AstNode>>,
    },
    FuncDecl {
        category: FuncCategory,  // A/B/C 类
        name: String,
        params: Vec<Parameter>,
        return_type: Option<String>,
    },
    FuncImpl {
        name: String,
        body: Vec<AstNode>,
    },
    
    // 语句
    Assignment {
        target: String,
        value: Box<AstNode>,
    },
    IfStmt {
        condition: Box<AstNode>,
        then_branch: Vec<AstNode>,
        else_branch: Option<Vec<AstNode>>,
    },
    LoopStmt {
        iterator: String,
        collection: Box<AstNode>,
        body: Vec<AstNode>,
    },
    OutputStmt {
        target: String,
        values: Vec<AstNode>,
    },
    InputStmt {
        source: String,
        target: String,
    },
    
    // 表达式
    BinaryExpr {
        left: Box<AstNode>,
        operator: String,
        right: Box<AstNode>,
    },
    UnaryExpr {
        operator: String,
        operand: Box<AstNode>,
    },
    CallExpr {
        function: String,
        arguments: Vec<AstNode>,
    },
    Identifier(String),
    Literal(LiteralValue),
}

#[derive(Debug, Clone)]
pub enum FuncCategory {
    Pure,    // 纯函数 (无副作用，可缓存)
    Query,   // 查询 (只读，不修改状态)
    Effect,  // 副作用 (可修改状态、I/O)
}

#[derive(Debug, Clone)]
pub struct Parameter {
    pub name: String,
    pub param_type: Option<String>,
}

#[derive(Debug, Clone)]
pub enum LiteralValue {
    Number(f64),
    String(String),
    Bool(bool),
    Null,
}
```

### 2.3 链接检查器 (Linker)

```rust
// compiler/src/analyzer/linker.rs

use std::collections::{HashMap, HashSet};

pub struct LinkChecker {
    declarations: HashSet<String>,      // .yc 中声明的函数
    implementations: HashSet<String>,   // .yci 中实现的函数
    link_config: LinkConfig,            // .ycl 配置
}

#[derive(Debug)]
pub struct LinkConfig {
    pub project_name: String,
    pub modules: Vec<ModuleLink>,
    pub execution_order: Vec<String>,
}

#[derive(Debug)]
pub struct ModuleLink {
    pub spec: String,           // .yc 文件路径
    pub impl_file: String,      // .yci 文件路径
    pub view: Option<String>,   // .ycv 文件路径 (可选)
}

#[derive(Debug)]
pub enum LinkError {
    MissingImplementation {
        function: String,
        declared_in: String,
    },
    UndeclaredFunction {
        function: String,
        found_in: String,
    },
    MissingModule {
        module: String,
    },
    CircularDependency {
        chain: Vec<String>,
    },
}

impl LinkChecker {
    pub fn check(&self) -> Result<(), Vec<LinkError>> {
        let mut errors = Vec::new();
        
        // 检查 1: 所有声明都有实现
        for decl in &self.declarations {
            if !self.implementations.contains(decl) {
                errors.push(LinkError::MissingImplementation {
                    function: decl.clone(),
                    declared_in: "spec".to_string(),
                });
            }
        }
        
        // 检查 2: 所有实现都有声明
        for impl_fn in &self.implementations {
            if !self.declarations.contains(impl_fn) {
                errors.push(LinkError::UndeclaredFunction {
                    function: impl_fn.clone(),
                    found_in: "impl".to_string(),
                });
            }
        }
        
        // 检查 3: 链接配置中的模块都存在
        for module in &self.link_config.modules {
            // 验证文件存在性...
        }
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}
```

### 2.4 内存模拟器

```rust
// compiler/src/runtime/memory.rs

use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemorySnapshot {
    pub timestamp: String,
    pub code_line: usize,
    pub stack: Vec<StackFrame>,
    pub heap: Vec<HeapBlock>,
    pub pointers: Vec<PointerInfo>,
    pub leaks: Vec<String>,
    pub null_access: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StackFrame {
    pub function: String,
    pub variables: Vec<Variable>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Variable {
    pub name: String,
    pub var_type: String,
    pub value: String,
    pub address: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeapBlock {
    pub address: String,
    pub size: usize,
    pub status: HeapStatus,
    pub allocated_at: usize,
    pub freed_at: Option<usize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HeapStatus {
    Allocated,
    Freed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PointerInfo {
    pub name: String,
    pub value: String,
    pub status: PointerStatus,
    pub pointer_type: PointerType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PointerStatus {
    Valid,
    Dangling,
    Null,
    Uninitialized,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PointerType {
    Auto,
    Manual,
}

pub struct MemorySimulator {
    stack: Vec<StackFrame>,
    heap: HashMap<String, HeapBlock>,
    pointers: HashMap<String, PointerInfo>,
    snapshots: Vec<MemorySnapshot>,
    current_line: usize,
}

impl MemorySimulator {
    pub fn new() -> Self {
        Self {
            stack: Vec::new(),
            heap: HashMap::new(),
            pointers: HashMap::new(),
            snapshots: Vec::new(),
            current_line: 0,
        }
    }
    
    pub fn allocate(&mut self, name: &str, size: usize, ptr_type: PointerType) -> String {
        let address = format!("0x{:08X}", self.heap.len() * 1000 + 0x1000);
        
        self.heap.insert(address.clone(), HeapBlock {
            address: address.clone(),
            size,
            status: HeapStatus::Allocated,
            allocated_at: self.current_line,
            freed_at: None,
        });
        
        self.pointers.insert(name.to_string(), PointerInfo {
            name: name.to_string(),
            value: address.clone(),
            status: PointerStatus::Valid,
            pointer_type: ptr_type,
        });
        
        address
    }
    
    pub fn free(&mut self, name: &str) -> Result<(), String> {
        if let Some(ptr) = self.pointers.get_mut(name) {
            if let Some(block) = self.heap.get_mut(&ptr.value) {
                block.status = HeapStatus::Freed;
                block.freed_at = Some(self.current_line);
            }
            ptr.status = PointerStatus::Dangling;
            Ok(())
        } else {
            Err(format!("指针 '{}' 不存在", name))
        }
    }
    
    pub fn take_snapshot(&mut self) -> MemorySnapshot {
        let snapshot = MemorySnapshot {
            timestamp: chrono::Utc::now().to_rfc3339(),
            code_line: self.current_line,
            stack: self.stack.clone(),
            heap: self.heap.values().cloned().collect(),
            pointers: self.pointers.values().cloned().collect(),
            leaks: self.detect_leaks(),
            null_access: false,
        };
        
        self.snapshots.push(snapshot.clone());
        snapshot
    }
    
    fn detect_leaks(&self) -> Vec<String> {
        self.heap.iter()
            .filter(|(_, block)| matches!(block.status, HeapStatus::Allocated))
            .map(|(addr, _)| addr.clone())
            .collect()
    }
    
    pub fn export_json(&self) -> String {
        serde_json::to_string_pretty(&self.snapshots).unwrap()
    }
}
```

## 3. IDE 开发

### 3.1 Tauri 配置

```json
// ide/tauri.conf.json
{
  "build": {
    "beforeBuildCommand": "pnpm build",
    "beforeDevCommand": "pnpm dev",
    "devPath": "http://localhost:5173",
    "distDir": "../dist"
  },
  "package": {
    "productName": "YuCheng IDE",
    "version": "0.1.0"
  },
  "tauri": {
    "bundle": {
      "active": true,
      "icon": ["icons/icon.ico"],
      "identifier": "com.yucheng.ide",
      "targets": "all"
    },
    "windows": [
      {
        "title": "YuCheng IDE - 御程开发环境",
        "width": 1280,
        "height": 800,
        "resizable": true,
        "fullscreen": false
      }
    ]
  }
}
```

### 3.2 文件类型注册

```json
// ide/src/config/file-types.json
{
  "fileTypes": [
    {
      "extension": ".yc",
      "name": "YuCheng Specification",
      "icon": "spec-icon",
      "color": "#2196F3",
      "language": "yucheng-spec"
    },
    {
      "extension": ".yci",
      "name": "YuCheng Implementation",
      "icon": "impl-icon",
      "color": "#4CAF50",
      "language": "yucheng-impl"
    },
    {
      "extension": ".ycl",
      "name": "YuCheng Linkage",
      "icon": "link-icon",
      "color": "#FFC107",
      "language": "json"
    },
    {
      "extension": ".ycv",
      "name": "YuCheng View",
      "icon": "view-icon",
      "color": "#9C27B0",
      "language": "yucheng-view"
    }
  ]
}
```

## 4. 构建与发布

### 4.1 编译器构建

```bash
# 进入编译器目录
cd compiler

# 开发构建
cargo build

# 发布构建 (优化)
cargo build --release

# 运行测试
cargo test

# 生成文档
cargo doc --open
```

### 4.2 IDE 构建

```bash
# 进入 IDE 目录
cd ide

# 安装依赖
pnpm install

# 开发模式
pnpm tauri dev

# 构建发布版
pnpm tauri build
```

### 4.3 打包发布

构建完成后，在以下目录找到可执行文件：

- Windows: `ide/src-tauri/target/release/YuCheng IDE.exe`
- macOS: `ide/src-tauri/target/release/bundle/macos/YuCheng IDE.app`
- Linux: `ide/src-tauri/target/release/yucheng-ide`

## 5. 命令行工具

```bash
# 编译项目
yucheng build project.ycl

# 运行项目
yucheng run project.ycl

# 透视运行（生成内存报告）
yucheng run --inspect project.ycl

# 检查链接
yucheng check project.ycl

# 生成动态库
yucheng build --lib project.ycl

# 运行测试
yucheng test

# 格式化代码
yucheng fmt
```
