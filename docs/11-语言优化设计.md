# YuCheng 语言 - 语言优化设计

> **实现状态**: ⚠️ 部分实现
> - ✅ 函数分类、契约系统、审计集成 已在解析器 / 解释器 / VM 编译器中落地
> - ✅ 构建后审计与契约裁剪等基础优化已投入使用
> - ⚠️ 高级优化与多后端（LLVM / WASM / 多语言转译）仍在迭代中
> - 📋 本文档同时作为后续语言演进与优化的设计参考

本文档描述 YuCheng 语言的 6 项核心语言级优化，提升类型安全、开发体验和可靠性。

---

## 1. 函数分类：从命名约定升级为语法关键字

### 1.1 问题

依赖 `计算_`、`执行_` 等前缀是脆弱的——易拼错、难检查、无强制力。

### 1.2 优化方案

引入三个**保留关键字**作为函数声明的修饰符：

```御程
// 纯计算函数 - 无副作用，可缓存、可并行
纯函数 func 加法(a: 整数, b: 整数) -> 整数

// 查询函数 - 只读，不修改状态
查询 func 获取温度() -> 小数

// 副作用函数 - 可修改状态、执行I/O
副作用 func 点亮LED(引脚: 整数)
```

或使用英文关键字（可配置）：

```御程
compute func 加法(a: 整数, b: 整数) -> 整数
query   func 获取温度() -> 小数
effect  func 点亮LED(引脚: 整数)
```

### 1.3 编译器强制约束

| 函数类型 | 允许调用 | 禁止调用 |
|---------|---------|---------|
| `纯函数` | 其他 `纯函数` | `查询`、`副作用` |
| `查询` | `纯函数`、其他 `查询` | `副作用` |
| `副作用` | 所有类型 | 无限制 |

```御程
// ✅ 正确
纯函数 func 计算面积(长: 小数, 宽: 小数) -> 小数 {
    返回 长 * 宽
}

// ❌ 编译错误：纯函数内不能调用副作用函数
纯函数 func 计算并打印(a: 整数) -> 整数 {
    执行_打印(a)  // 错误：纯函数内禁止调用副作用函数
    返回 a * 2
}
```

### 1.4 优势

- 编译器在**编译期**强制约束行为
- IDE 可基于关键字提供精准的语义高亮
- 消除命名歧义，提升代码可读性
- AI 生成代码时有明确的类型约束

---

## 2. 接口契约：前置条件与后置条件

### 2.1 问题

正确性依赖运行时断言，发现错误太晚。

### 2.2 优化方案

在 `.yc` 规格文件中支持契约声明：

```御程
// math.yc

纯函数 func 平方根(x: 小数) -> 小数
    要求 x >= 0.0           // 前置条件
    保证 返回值 >= 0.0       // 后置条件

纯函数 func 除法(a: 小数, b: 小数) -> 小数
    要求 b <> 0.0           // 除数不能为零
    保证 返回值 * b == a    // 数学恒等式

查询 func 获取元素(列表: 列表<T>, 索引: 整数) -> T
    要求 索引 >= 0
    要求 索引 < 列表.长度
```

### 2.3 编译器行为

```御程
// math.yci - 编译器自动插入断言

纯函数 func 平方根(x: 小数) -> 小数 {
    // [自动插入] 前置条件检查
    断言(x >= 0.0, "前置条件失败: x >= 0.0")
    
    // 实际实现
    var 结果 = 内置_平方根(x)
    
    // [自动插入] 后置条件检查
    断言(结果 >= 0.0, "后置条件失败: 返回值 >= 0.0")
    
    返回 结果
}
```

### 2.4 编译选项

```bash
# 开发模式：启用所有契约检查
yucheng build --contracts=full

# 测试模式：仅检查前置条件
yucheng build --contracts=requires

# 发布模式：关闭契约检查（类似 C 的 NDEBUG）
yucheng build --contracts=none -O3
```

### 2.5 契约语法完整示例

```御程
// account.yc

副作用 func 转账(
    来源账户: 账户,
    目标账户: 账户,
    金额: 小数
) -> 布尔
    要求 金额 > 0                           // 金额必须为正
    要求 来源账户.余额 >= 金额               // 余额充足
    要求 来源账户 <> 目标账户                // 不能自己转给自己
    保证 来源账户.余额 == 旧值(来源账户.余额) - 金额  // 扣款正确
    保证 目标账户.余额 == 旧值(目标账户.余额) + 金额  // 入账正确
```

---

## 3. 链接文件简化：自动推导模式

### 3.1 问题

手动维护 `.ycl` 对小型项目是负担。

### 3.2 显式链接语法（保留）

```json
// project.ycl - 完整控制模式
{
  "模式": "显式",
  "模块链接": [
    {
      "规格": "math.yc",
      "实现": "math.yci"
    },
    {
      "规格": "ui.yc",
      "实现": "ui.yci",
      "视图": "ui.ycv"
    }
  ],
  "入口函数": "主函数"
}
```

### 3.3 自动推导语法（新增）

```json
// project.ycl - 自动模式
{
  "模式": "自动",
  "入口": "main.ycv",
  "扫描目录": ["src/", "lib/"]
}
```

编译器行为：
1. 从 `main.ycv` 开始分析依赖
2. 自动匹配 `.yc` 和 `.yci` 文件对
3. 生成内部链接图

### 3.4 命令行工具

```bash
# 自动生成 .ycl 草稿
yucheng init --auto-link main.ycv

# 验证链接完整性
yucheng check project.ycl

# 显示依赖图
yucheng deps --graph project.ycl
```

### 3.5 混合模式

```json
{
  "模式": "混合",
  "自动扫描": ["src/"],
  "显式覆盖": [
    {
      "规格": "vendor/special.yc",
      "实现": "vendor/special.yci"
    }
  ],
  "排除": ["test/", "examples/"]
}
```

---

## 4. 统一类型系统：禁止隐式转换

### 4.1 问题

C 风格的隐式类型转换（如 `int` → `float`）是 bug 温床。

### 4.2 优化方案

**禁止所有隐式数值转换**，强制显式转换：

```御程
// ❌ 编译错误：不允许隐式转换
var a: 整数 = 5
var b: 小数 = a  // 错误：整数不能隐式转换为小数

// ✅ 正确：显式转换
var a: 整数 = 5
var b: 小数 = 转小数(a)  // 显式调用转换函数
```

### 4.3 类型转换函数

```御程
// 数值转换
转小数(整数值)      // 整数 -> 小数
转整数(小数值)      // 小数 -> 整数（截断）
整数_四舍五入(小数值)  // 小数 -> 整数（四舍五入）

// 文本转换
转文本(任意值)      // 任意类型 -> 文本
整数_解析(文本值)  // 文本 -> 整数（可能失败）
小数_解析(文本值)  // 文本 -> 小数（可能失败）

// 安全转换（返回可选类型）
尝试_转整数(文本值) -> 整数?  // 失败返回空
```

### 4.4 类型推断

```御程
// 类型推断仍然有效
var x = 42        // 推断为 整数
var y = 3.14      // 推断为 小数
var z = "hello"   // 推断为 文本

// 但跨类型操作必须显式
var result = 转小数(x) + y  // 必须先转换
```

### 4.5 运算符类型规则

```御程
// 同类型运算
整数 + 整数 -> 整数
小数 + 小数 -> 小数

// 混合类型：编译错误
整数 + 小数 -> 错误！必须显式转换

// 比较运算同理
整数 > 小数 -> 错误！
转小数(整数值) > 小数值 -> 布尔  // 正确
```

---

## 5. 内存管理：作用域绑定 + 显式延长

### 5.1 问题

- 纯手动管理（如 C）易出错
- 纯 GC（如 Python）不可预测

### 5.2 默认模式：作用域自动析构

```御程
副作用 func 处理数据() {
    {
        var buf = 申请(1024)  // 进入作用域分配
        // ... 使用 buf ...
    } // 离开作用域自动调用 释放(buf)
    
    // buf 在这里已不可访问
}
```

### 5.3 显式延长生命周期

若需延长生命周期，使用 `持有` 和 `释放`：

```御程
var 全局缓存: 指针<字节> = 空

副作用 func 初始化缓存() {
    var buf = 申请(1024)
    全局缓存 = 持有(buf)  // 显式延长生命周期
    // buf 离开作用域不会被释放
}

副作用 func 清理缓存() {
    释放(全局缓存)  // 手动释放
    全局缓存 = 空
}
```

### 5.4 编译器静态检查

```御程
// ❌ 编译警告：持有/释放不成对
副作用 func 泄漏示例() {
    var buf = 申请(1024)
    var p = 持有(buf)
    // 警告：p 被持有但从未释放
}

// ❌ 编译错误：释放后使用
副作用 func 悬垂示例() {
    var buf = 申请(1024)
    var p = 持有(buf)
    释放(p)
    var x = p[0]  // 错误：p 已被释放
}
```

### 5.5 内存透视集成

```json
// 内存报告中追踪所有 申请/持有 调用点
{
  "allocations": [
    {
      "address": "0x1000",
      "size": 1024,
      "allocated_at": {"file": "main.yci", "line": 15},
      "retained": true,
      "retained_at": {"file": "main.yci", "line": 16},
      "released": false  // 警告：未释放
    }
  ]
}
```

### 5.6 智能指针语法糖

```御程
// 自动管理的智能指针（默认推荐）
auto var buf = 申请(1024)  // 等价于作用域绑定

// 手动管理的原始指针（高级用法）
manual var raw = 申请(1024)
// 必须手动释放
释放(raw)
```

---

## 6. 单文件开发模式 (.ycs)

### 6.1 问题

四文件体系对新手门槛高。

### 6.2 单文件聚合格式

支持 `.ycs`（YuCheng Single）单文件格式：

```御程
// hello.ycs - 单文件模式

//===== 规格区 =====//
纯函数 func 加法(a: 整数, b: 整数) -> 整数
副作用 func 主函数()

//===== 实现区 =====//
实现 {

纯函数 func 加法(a: 整数, b: 整数) -> 整数 {
    返回 a + b
}

副作用 func 主函数() {
    var 结果 = 加法(1, 2)
    控制台 => "1 + 2 = ", 结果
}

}

//===== 视图区（可选）=====//
视图 {

窗口 主窗口 {
    标题: "Hello YuCheng"
    
    按钮 {
        文字: "计算"
        点击 => 主函数()
    }
}

}
```

### 6.3 区域标记语法

```御程
// 使用标记分隔各区域
#规格
纯函数 func foo() -> 整数

#实现
纯函数 func foo() -> 整数 {
    返回 42
}

#视图
窗口 主窗口 { ... }

#测试
测试 "foo返回42" {
    断言_相等(foo(), 42)
}
```

### 6.4 工具链支持

```bash
# 直接运行单文件
yucheng run hello.ycs

# 拆分为标准四文件结构
yucheng split hello.ycs --output ./src/

# 合并多文件为单文件（用于分享）
yucheng merge project.ycl --output combined.ycs
```

### 6.5 IDE 支持

- 单文件模式下，IDE 显示折叠的区域标记
- 提供"拆分到多文件"一键操作
- 语法高亮区分不同区域

### 6.6 适用场景

| 场景 | 推荐模式 |
|------|---------|
| 教学演示 | `.ycs` 单文件 |
| 原型开发 | `.ycs` 单文件 |
| 脚本工具 | `.ycs` 单文件 |
| 小型项目 | 自动链接模式 |
| 中大型项目 | 显式四文件 |
| 团队协作 | 显式四文件 |

---

## 7. 语言设计原则总结

| 特性 | 实现方式 |
|------|---------|
| **强契约** | 函数类别关键字 + 接口前置/后置条件 |
| **零歧义** | 无隐式转换 + 显式内存管理 |
| **高可靠** | 编译期行为约束 + 静态资源检查 |
| **易上手** | 单文件模式 + 自动链接 |
| **可观察** | 内存/性能数据结构化输出 |

### 核心目标

> 让开发者写出的每一行代码，都自带"正确性证明"和"可观测性"，而无需依赖外部工具或经验猜测。

---

## 8. 语法对照表

### 8.1 函数声明对照

| 旧语法（命名约定） | 新语法（关键字） |
|------------------|----------------|
| `func 计算_加法(a, b)` | `纯函数 func 加法(a, b)` |
| `func 获取_温度()` | `查询 func 温度()` |
| `func 执行_保存(数据)` | `副作用 func 保存(数据)` |

### 8.2 完整示例对照

**旧语法：**
```御程
// math.yc
func 计算_加法(a, b) -> 结果
func 执行_打印结果(值)
```

**新语法：**
```御程
// math.yc
纯函数 func 加法(a: 整数, b: 整数) -> 整数
    保证 返回值 == a + b

副作用 func 打印结果(值: 整数)
```

### 8.3 兼容性

- 编译器支持 `--legacy` 模式兼容旧语法（默认禁用）
- 提供 `yucheng migrate` 工具自动迁移代码

```bash
# 启用旧语法兼容模式（不推荐，仅用于迁移过渡）
yucheng build --legacy project.ycl

# 自动迁移旧代码到新语法
yucheng migrate src/

# 检查代码是否使用旧语法
yucheng check --deprecated src/
```

**迁移规则：**

| 旧语法 | 新语法 |
|-------|-------|
| `func 计算_xxx()` | `纯函数 func xxx()` |
| `func 获取_xxx()` | `查询 func xxx()` |
| `func 执行_xxx()` | `副作用 func xxx()` |
| `变量 <- 值` | `变量 = 值` |
| `auto_ptr` / `ptr` | 作用域绑定 + `持有`/`释放` |
