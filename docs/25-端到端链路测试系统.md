# 御程语言端到端链路测试系统

> **实现状态**: ✅ 核心功能完整实现 (95%完成)
> - ✅ 接口契约数据结构完整
> - ✅ 链路测试核心功能完整
> - ✅ 契约声明语法解析器完整实现 (contract_parser_enhanced.rs)
> - ✅ 增强Mock服务系统完整实现 (mock_service_enhanced.rs)
> - ✅ 数据库验证增强完整实现
> - ✅ WebSocket Mock支持
> - ✅ 故障注入系统完整
> - ✅ 事务一致性验证
> - ✅ 27个极端测试全部通过 (100%)
> - ⚠️ CLI命令待完善
> - ⚠️ 链路可视化待实现

## 一、核心理念

> **从用户点击到数据库写入的每一跳，都处于契约的约束之下。**

传统测试体系的割裂问题：
- 前端测 UI（Cypress/Playwright）
- 后端测 API（Postman/Jest）
- 数据库测数据（手动SQL）
- **但没人验证整条链路是否真正贯通且正确**

御程的解决方案：**契约化链路测试**
- 在 `.yc` 规格文件中定义前后端交互契约
- 由 `yucheng test --e2e` 自动验证全链路
- 生成链路覆盖率报告

---

## 二、接口契约声明语法

### 2.1 基础接口定义

```御程
// user_api.yc - 用户接口规格

接口 登录接口 {
    路径: "/api/login"
    方法: POST
    
    请求体: {
        用户名: 文本 @必填 @最小长度(3)
        密码: 文本 @必填 @最小长度(6)
        记住我: 布尔 = 假
    }
    
    成功响应: {
        令牌: 文本
        用户: {
            编号: 整数
            姓名: 文本
            角色: 文本
        }
        过期时间: 整数
    }
    
    错误响应: [
        { 状态码: 400, 错误码: "INVALID_INPUT", 消息: "请求参数无效" },
        { 状态码: 401, 错误码: "AUTH_FAILED", 消息: "用户名或密码错误" },
        { 状态码: 429, 错误码: "RATE_LIMITED", 消息: "请求过于频繁" },
        { 状态码: 500, 错误码: "SERVER_ERROR", 消息: "服务器内部错误" }
    ]
    
    超时: 5000毫秒
    重试: 3次
}
```


### 2.2 UI契约定义

```御程
// login_ui.yc - 登录页面UI契约

UI契约 登录页面 {
    // 状态定义
    状态 {
        已登录: 布尔 = 假
        加载中: 布尔 = 假
        错误消息: 文本? = 空
    }
    
    // 前置条件
    要求 !已登录 → 存在("登录表单")
    要求 !已登录 → 存在("用户名输入框")
    要求 !已登录 → 存在("密码输入框")
    要求 !已登录 → 存在("登录按钮")
    
    // 后置条件
    保证 已登录 → 不存在("登录表单")
    保证 已登录 → 存在("欢迎消息")
    保证 已登录 → 跳转到("/dashboard")
    
    // 行为契约
    行为 提交登录 {
        触发: 点击("登录按钮")
        前置: 输入值("用户名输入框") != "" 且 输入值("密码输入框") != ""
        
        调用: 接口(登录接口) {
            用户名: 输入值("用户名输入框")
            密码: 输入值("密码输入框")
        }
        
        成功时: {
            设置状态(已登录: 真)
            存储("auth_token", 响应.令牌)
            跳转("/dashboard")
        }
        
        失败时(401): {
            显示错误("用户名或密码错误")
        }
        
        失败时(429): {
            显示错误("请求过于频繁，请稍后再试")
            禁用("登录按钮", 时长: 30秒)
        }
    }
    
    // 无障碍契约
    无障碍 {
        要求 所有输入框有标签
        要求 错误消息可被屏幕阅读器读取
        要求 焦点顺序正确
    }
}
```

### 2.3 数据契约定义

```御程
// user_data.yc - 用户数据契约

数据契约 用户表 {
    表名: "users"
    
    字段 {
        id: 整数 @主键 @自增
        username: 文本 @唯一 @非空 @最大长度(50)
        password_hash: 文本 @非空
        role: 文本 @默认("user")
        created_at: 时间戳 @默认(当前时间)
        last_login: 时间戳?
    }
    
    // 数据完整性约束
    约束 {
        用户名格式: username 匹配 "^[a-zA-Z0-9_]+$"
        角色枚举: role 在 ["admin", "user", "guest"]
    }
}

数据契约 登录日志表 {
    表名: "login_logs"
    
    字段 {
        id: 整数 @主键 @自增
        user_id: 整数 @外键(用户表.id)
        ip_address: 文本
        success: 布尔
        timestamp: 时间戳 @默认(当前时间)
    }
}
```

---

## 三、链路测试语法

### 3.1 基础链路测试

```御程
// login_e2e.yct - 登录链路测试

链路测试套件 "用户登录全流程" {
    
    前置准备 {
        // 准备测试数据
        插入测试数据(用户表, {
            username: "testuser",
            password_hash: 哈希("password123"),
            role: "user"
        })
        
        // 启动Mock服务
        启动Mock服务(端口: 3001)
    }
    
    后置清理 {
        清空测试数据(用户表)
        清空测试数据(登录日志表)
        停止Mock服务()
    }
    
    链路测试 "成功登录完整链路" {
        // 第1步：渲染登录页面
        渲染界面("login.ycv")
        断言_存在("登录表单")
        
        // 第2步：用户输入
        输入文本("用户名输入框", "testuser")
        输入文本("密码输入框", "password123")
        
        // 第3步：点击登录
        点击("登录按钮")
        
        // 第4步：验证接口调用
        断言_接口已调用(登录接口) {
            请求体.用户名 == "testuser"
            请求体.密码 == "password123"
        }
        
        // 第5步：等待响应
        等待(接口响应: 登录接口, 超时: 5秒)
        
        // 第6步：验证前端状态
        断言_状态("已登录", 真)
        断言_本地存储存在("auth_token")
        断言_跳转到("/dashboard")
        
        // 第7步：验证数据库
        断言_数据库(登录日志表) {
            存在记录 {
                user_id: 查询(用户表, username: "testuser").id
                success: 真
            }
        }
        
        // 第8步：验证后续页面
        断言_存在("欢迎消息")
        断言_文本("欢迎消息", 包含: "testuser")
    }
}
```


### 3.2 错误路径测试

```御程
链路测试套件 "登录错误处理" {
    
    链路测试 "密码错误链路" {
        渲染界面("login.ycv")
        
        输入文本("用户名输入框", "testuser")
        输入文本("密码输入框", "wrongpassword")
        点击("登录按钮")
        
        // 验证接口调用
        断言_接口已调用(登录接口)
        
        // 模拟401响应
        模拟响应(登录接口, 错误(401)) {
            错误码: "AUTH_FAILED"
            消息: "用户名或密码错误"
        }
        
        // 验证前端错误处理
        断言_存在("错误提示")
        断言_文本("错误提示", "用户名或密码错误")
        断言_状态("已登录", 假)
        断言_未跳转()
        
        // 验证数据库日志
        断言_数据库(登录日志表) {
            存在记录 { success: 假 }
        }
    }
    
    链路测试 "请求频率限制链路" {
        渲染界面("login.ycv")
        
        // 连续尝试登录5次
        循环 5 次 {
            输入文本("用户名输入框", "testuser")
            输入文本("密码输入框", "wrongpass")
            点击("登录按钮")
            等待(接口响应: 登录接口)
            清空输入("用户名输入框")
            清空输入("密码输入框")
        }
        
        // 第6次应被限流
        模拟响应(登录接口, 错误(429)) {
            消息: "请求过于频繁"
            重试时间: 30
        }
        
        断言_文本("错误提示", 包含: "请求过于频繁")
        断言_已禁用("登录按钮")
        断言_倒计时显示("登录按钮", 30)
    }
    
    链路测试 "网络超时链路" {
        渲染界面("login.ycv")
        
        // 模拟网络超时
        模拟接口超时(登录接口, 超时: 5秒)
        
        输入文本("用户名输入框", "testuser")
        输入文本("密码输入框", "password123")
        点击("登录按钮")
        
        // 验证加载状态
        断言_存在("加载指示器")
        断言_已禁用("登录按钮")
        
        // 等待超时
        等待(5秒)
        
        // 验证超时处理
        断言_不存在("加载指示器")
        断言_存在("错误提示")
        断言_文本("错误提示", 包含: "网络超时")
        断言_存在("重试按钮")
    }
}
```


### 3.3 性能链路测试

```御程
链路测试套件 "性能链路测试" {
    
    #性能测试
    链路测试 "登录响应时间" {
        渲染界面("login.ycv")
        
        输入文本("用户名输入框", "testuser")
        输入文本("密码输入框", "password123")
        
        变量 开始时间 = 当前时间戳()
        点击("登录按钮")
        等待(跳转到: "/dashboard")
        变量 结束时间 = 当前时间戳()
        
        变量 总耗时 = 结束时间 - 开始时间
        
        // 性能断言
        断言_小于(总耗时, 2000毫秒, "登录全链路应在2秒内完成")
        
        // 分段计时
        断言_接口耗时(登录接口, 小于: 500毫秒)
        断言_渲染耗时("/dashboard", 小于: 1000毫秒)
    }
    
    #性能测试
    链路测试 "并发登录压力测试" {
        变量 成功数 = 0
        变量 失败数 = 0
        变量 响应时间列表 = []
        
        // 并发100个登录请求
        并发执行(数量: 100) 为 索引 {
            变量 开始 = 当前时间戳()
            
            尝试 {
                渲染界面("login.ycv", 实例: 索引)
                输入文本("用户名输入框", "user" + 索引)
                输入文本("密码输入框", "password")
                点击("登录按钮")
                等待(接口响应: 登录接口, 超时: 10秒)
                
                成功数 = 成功数 + 1
            } 捕获 错误 {
                失败数 = 失败数 + 1
            }
            
            追加(响应时间列表, 当前时间戳() - 开始)
        }
        
        // 性能指标断言
        断言_大于等于(成功数, 95, "成功率应≥95%")
        断言_小于(平均值(响应时间列表), 3000毫秒)
        断言_小于(百分位(响应时间列表, 99), 5000毫秒, "P99应<5秒")
    }
}
```


---

## 四、Mock服务系统

### 4.1 自动Mock服务

```御程
// 基于接口契约自动生成Mock服务
Mock服务 用户服务Mock {
    基于契约: "user_api.yc"
    端口: 3001
    
    // 默认行为：根据契约自动响应
    默认模式: 契约响应
    
    // 自定义响应规则
    规则 "/api/login" {
        当 请求体.用户名 == "admin" 且 请求体.密码 == "admin123" {
            响应 {
                令牌: "admin-token-xxx"
                用户: { 编号: 1, 姓名: "管理员", 角色: "admin" }
            }
        }
        
        当 请求体.用户名 == "locked_user" {
            响应 错误(403) {
                错误码: "ACCOUNT_LOCKED"
                消息: "账户已被锁定"
            }
        }
        
        // 默认：使用契约定义的成功响应
        默认 {
            响应 成功 {
                令牌: 生成UUID()
                用户: { 编号: 生成整数(1000, 9999), 姓名: 请求体.用户名, 角色: "user" }
            }
        }
    }
    
    // 延迟模拟
    延迟规则 {
        "/api/login": 随机(100, 500)毫秒
        "/api/users": 随机(200, 800)毫秒
    }
    
    // 故障注入
    故障规则 {
        // 10%概率返回500错误
        "/api/data": 概率(10%) → 错误(500)
        // 5%概率超时
        "/api/upload": 概率(5%) → 超时
    }
}
```


### 4.2 数据库Mock

```御程
Mock数据库 测试数据库 {
    类型: 内存SQLite
    
    // 初始化表结构（基于数据契约）
    初始化 {
        创建表(用户表)
        创建表(登录日志表)
    }
    
    // 预置测试数据
    预置数据 {
        插入(用户表, [
            { username: "testuser", password_hash: 哈希("password123"), role: "user" },
            { username: "admin", password_hash: 哈希("admin123"), role: "admin" },
            { username: "locked_user", password_hash: 哈希("pass"), role: "user", locked: 真 }
        ])
    }
    
    // 数据快照（用于测试隔离）
    快照策略: 每个测试前重置
}
```

### 4.3 WebSocket Mock

```御程
MockWebSocket 通知服务Mock {
    路径: "/ws/notifications"
    
    // 连接事件
    当连接 {
        发送 { 类型: "connected", 消息: "连接成功" }
    }
    
    // 消息处理
    当收到消息 为 消息 {
        若 消息.类型 == "subscribe" {
            发送 { 类型: "subscribed", 频道: 消息.频道 }
        }
    }
    
    // 模拟推送
    模拟推送 "新订单通知" {
        延迟: 2秒
        消息: { 类型: "order", 订单号: "ORD-001", 金额: 199.00 }
    }
    
    模拟推送 "系统公告" {
        定时: 每(30秒)
        消息: { 类型: "announcement", 内容: "系统将于今晚维护" }
    }
}
```


---

## 五、数据库验证

### 5.1 数据状态断言

```御程
链路测试 "订单创建数据一致性" {
    // 准备：清空订单表
    清空表(订单表)
    
    渲染界面("order.ycv")
    
    // 填写订单
    选择("商品下拉框", "iPhone 15")
    输入文本("数量输入框", "2")
    输入文本("收货地址", "北京市朝阳区xxx")
    点击("提交订单按钮")
    
    等待(接口响应: 创建订单接口)
    
    // 验证数据库状态
    断言_数据库(订单表) {
        记录数量 == 1
        
        存在记录 {
            product_name: "iPhone 15"
            quantity: 2
            address: "北京市朝阳区xxx"
            status: "pending"
            created_at: 近期(1分钟内)
        }
    }
    
    // 验证关联表
    断言_数据库(订单明细表) {
        存在记录 {
            order_id: 查询(订单表).id
            product_id: 查询(商品表, name: "iPhone 15").id
        }
    }
    
    // 验证库存扣减
    断言_数据库(商品表) {
        记录 { name: "iPhone 15" } 的 stock 减少了 2
    }
}
```


### 5.2 数据变更追踪

```御程
链路测试 "用户信息修改追踪" {
    // 记录初始状态
    变量 初始用户 = 查询数据库(用户表, id: 1001)
    
    渲染界面("profile.ycv")
    
    // 修改用户信息
    清空输入("邮箱输入框")
    输入文本("邮箱输入框", "new@example.com")
    点击("保存按钮")
    
    等待(接口响应: 更新用户接口)
    
    // 验证数据变更
    断言_数据库变更(用户表, id: 1001) {
        字段 "email" {
            旧值: 初始用户.email
            新值: "new@example.com"
        }
        字段 "updated_at" {
            已更新
        }
        字段 "username" {
            未变更
        }
    }
    
    // 验证审计日志
    断言_数据库(审计日志表) {
        存在记录 {
            table_name: "users"
            record_id: 1001
            action: "UPDATE"
            changes: 包含("email")
            operator_id: 当前用户ID()
        }
    }
}
```

### 5.3 事务一致性验证

```御程
链路测试 "转账事务一致性" {
    // 记录初始余额
    变量 账户A初始 = 查询数据库(账户表, id: "A").balance
    变量 账户B初始 = 查询数据库(账户表, id: "B").balance
    变量 转账金额 = 100.00
    
    渲染界面("transfer.ycv")
    
    选择("转出账户", "账户A")
    选择("转入账户", "账户B")
    输入文本("金额", 转账金额)
    点击("确认转账")
    
    等待(接口响应: 转账接口)
    
    // 验证事务原子性
    断言_数据库(账户表) {
        记录 { id: "A" } 的 balance == 账户A初始 - 转账金额
        记录 { id: "B" } 的 balance == 账户B初始 + 转账金额
    }
    
    // 验证总额不变（守恒）
    变量 总额 = 求和(查询所有(账户表), "balance")
    断言_等于(总额, 账户A初始 + 账户B初始, "总额应保持不变")
}
```


---

## 六、链路覆盖率报告

### 6.1 覆盖率指标

```御程
// 链路覆盖率配置
链路覆盖率配置 {
    // 接口覆盖
    接口覆盖 {
        目标: 100%
        包含: ["登录接口", "用户接口", "订单接口"]
        排除: ["健康检查接口"]
    }
    
    // 错误码覆盖
    错误码覆盖 {
        目标: 80%
        必须覆盖: [400, 401, 403, 404, 500]
    }
    
    // UI路径覆盖
    UI路径覆盖 {
        目标: 90%
        关键路径: [
            "登录 → 首页",
            "首页 → 订单列表 → 订单详情",
            "首页 → 个人中心 → 修改密码"
        ]
    }
    
    // 数据契约覆盖
    数据契约覆盖 {
        目标: 100%
        验证: [用户表, 订单表, 日志表]
    }
}
```

### 6.2 报告生成

```御程
// 生成链路覆盖率报告
生成报告 链路测试报告 {
    格式: ["HTML", "JSON", "Markdown"]
    输出目录: "./reports/e2e/"
    
    包含 {
        // 概览
        总测试数
        通过数
        失败数
        跳过数
        执行时间
        
        // 覆盖率
        接口覆盖率图表
        错误码覆盖矩阵
        UI路径覆盖图
        数据表覆盖统计
        
        // 详情
        失败测试详情
        未覆盖接口列表
        未覆盖错误码列表
        性能指标趋势
        
        // 链路图
        调用链路可视化
        数据流向图
    }
}
```


### 6.3 报告示例

```
═══════════════════════════════════════════════════════════════
                    御程链路测试报告
═══════════════════════════════════════════════════════════════
生成时间: 2026-01-11 15:30:00
项目: 用户管理系统
版本: 1.0.0

【测试概览】
┌─────────────┬────────┐
│ 总测试数    │ 45     │
│ 通过        │ 43     │
│ 失败        │ 1      │
│ 跳过        │ 1      │
│ 执行时间    │ 2m 35s │
│ 通过率      │ 95.6%  │
└─────────────┴────────┘

【链路覆盖率】
┌─────────────────┬────────┬────────┬────────┐
│ 类型            │ 已覆盖 │ 总数   │ 覆盖率 │
├─────────────────┼────────┼────────┼────────┤
│ 接口            │ 12     │ 12     │ 100%   │
│ 错误码          │ 8      │ 10     │ 80%    │
│ UI路径          │ 15     │ 16     │ 93.8%  │
│ 数据表          │ 5      │ 5      │ 100%   │
└─────────────────┴────────┴────────┴────────┘

【未覆盖项】
⚠ 错误码 408 (请求超时) - 登录接口
⚠ 错误码 503 (服务不可用) - 订单接口
⚠ UI路径: 首页 → 设置 → 通知设置

【失败测试】
✗ 登录错误处理::网络超时链路
  原因: 断言失败 - 期望存在"重试按钮"，但未找到
  位置: login_e2e.yct:156
  截图: ./screenshots/timeout_failure.png

【性能指标】
┌─────────────────┬────────┬────────┬────────┐
│ 链路            │ 平均   │ P95    │ P99    │
├─────────────────┼────────┼────────┼────────┤
│ 登录全流程      │ 856ms  │ 1.2s   │ 1.8s   │
│ 订单创建        │ 1.2s   │ 2.1s   │ 3.5s   │
│ 数据加载        │ 432ms  │ 780ms  │ 1.1s   │
└─────────────────┴────────┴────────┴────────┘
═══════════════════════════════════════════════════════════════
```


---

## 七、CLI命令

### 7.1 运行链路测试

```bash
# 运行所有链路测试
yucheng test --e2e

# 运行指定测试文件
yucheng test --e2e tests/login_e2e.yct

# 运行指定测试套件
yucheng test --e2e --suite "用户登录全流程"

# 运行指定测试用例
yucheng test --e2e --case "成功登录完整链路"

# 并行运行（加速）
yucheng test --e2e --parallel 4

# 带覆盖率
yucheng test --e2e --coverage

# 生成报告
yucheng test --e2e --report html,json

# 交互模式（可视化调试）
yucheng test --e2e --interactive

# 仅运行失败的测试
yucheng test --e2e --failed-only

# 监视模式（文件变化时自动运行）
yucheng test --e2e --watch
```

### 7.2 Mock服务管理

```bash
# 启动Mock服务
yucheng mock start --config mock_config.yc

# 启动指定Mock
yucheng mock start 用户服务Mock --port 3001

# 查看Mock状态
yucheng mock status

# 停止Mock服务
yucheng mock stop

# 记录真实请求（用于生成Mock数据）
yucheng mock record --target http://api.example.com --output recorded_mocks.yc
```

### 7.3 契约验证

```bash
# 验证接口契约
yucheng contract verify user_api.yc --against http://localhost:3000

# 生成契约文档
yucheng contract docs user_api.yc --output api_docs.html

# 契约差异比较
yucheng contract diff user_api.yc user_api_v2.yc

# 从OpenAPI导入契约
yucheng contract import openapi.yaml --output api.yc

# 导出为OpenAPI
yucheng contract export user_api.yc --format openapi --output openapi.yaml
```


---

## 八、完整示例

### 8.1 电商订单链路测试

```御程
// 文件: tests/order_e2e.yct

链路测试套件 "电商订单全流程" {
    
    前置准备 {
        // 启动Mock服务
        启动Mock服务(用户服务Mock, 端口: 3001)
        启动Mock服务(商品服务Mock, 端口: 3002)
        启动Mock服务(支付服务Mock, 端口: 3003)
        
        // 初始化测试数据库
        初始化数据库(测试数据库)
        
        // 预置数据
        插入测试数据(用户表, { id: 1, username: "buyer", balance: 1000.00 })
        插入测试数据(商品表, { id: 101, name: "测试商品", price: 99.00, stock: 10 })
    }
    
    后置清理 {
        停止所有Mock服务()
        清空测试数据库()
    }
    
    链路测试 "完整购物流程" {
        // ===== 第1阶段：用户登录 =====
        渲染界面("login.ycv")
        
        输入文本("用户名", "buyer")
        输入文本("密码", "password123")
        点击("登录按钮")
        
        断言_接口已调用(登录接口)
        等待(跳转到: "/home")
        断言_本地存储存在("auth_token")
        
        // ===== 第2阶段：浏览商品 =====
        点击("商品分类", 文本: "全部商品")
        等待(接口响应: 商品列表接口)
        
        断言_存在("商品卡片")
        断言_子元素数量("商品列表", 大于: 0)
        
        // ===== 第3阶段：加入购物车 =====
        点击("商品卡片", 包含: "测试商品")
        等待(跳转到: "/product/101")
        
        断言_文本("商品名称", "测试商品")
        断言_文本("商品价格", "¥99.00")
        
        输入文本("购买数量", "2")
        点击("加入购物车")
        
        断言_接口已调用(加入购物车接口) {
            请求体.product_id == 101
            请求体.quantity == 2
        }
        
        断言_提示消息("已加入购物车")
        断言_文本("购物车数量徽章", "2")
        
        // ===== 第4阶段：结算 =====
        点击("购物车图标")
        等待(跳转到: "/cart")
        
        断言_存在("购物车商品项")
        断言_文本("商品小计", "¥198.00")
        
        点击("去结算")
        等待(跳转到: "/checkout")
        
        // 填写收货信息
        输入文本("收货人", "张三")
        输入文本("手机号", "13800138000")
        输入文本("收货地址", "北京市朝阳区xxx街道xxx号")
        
        // ===== 第5阶段：支付 =====
        点击("提交订单")
        
        断言_接口已调用(创建订单接口)
        等待(跳转到: 匹配("/order/"))
        
        // 验证订单创建
        断言_数据库(订单表) {
            存在记录 {
                user_id: 1
                total_amount: 198.00
                status: "pending_payment"
            }
        }
        
        // 选择支付方式
        点击("支付宝支付")
        点击("确认支付")
        
        // 模拟支付成功回调
        模拟响应(支付回调接口, 成功) {
            order_id: 获取当前订单ID()
            payment_status: "success"
            transaction_id: "PAY202601110001"
        }
        
        等待(页面更新)
        
        // ===== 第6阶段：验证最终状态 =====
        
        // 验证UI
        断言_文本("订单状态", "已支付")
        断言_存在("支付成功图标")
        
        // 验证数据库 - 订单状态
        断言_数据库(订单表) {
            记录 { user_id: 1 } 的 status == "paid"
            记录 { user_id: 1 } 的 payment_time != 空
        }
        
        // 验证数据库 - 库存扣减
        断言_数据库(商品表) {
            记录 { id: 101 } 的 stock == 8  // 原10减2
        }
        
        // 验证数据库 - 用户余额（如果使用余额支付）
        // 断言_数据库(用户表) {
        //     记录 { id: 1 } 的 balance == 802.00
        // }
        
        // 验证日志
        断言_数据库(操作日志表) {
            存在记录 { action: "ORDER_CREATED", user_id: 1 }
            存在记录 { action: "PAYMENT_SUCCESS", user_id: 1 }
        }
    }
    
    链路测试 "库存不足场景" {
        // 预置：库存只有1件
        更新测试数据(商品表, { id: 101 }, { stock: 1 })
        
        // 登录并尝试购买2件
        执行登录("buyer", "password123")
        跳转到("/product/101")
        
        输入文本("购买数量", "2")
        点击("加入购物车")
        
        // 验证库存检查
        断言_提示消息(包含: "库存不足")
        断言_接口响应(加入购物车接口, 状态码: 400)
        
        // 验证数据库未变更
        断言_数据库(商品表) {
            记录 { id: 101 } 的 stock == 1  // 保持不变
        }
    }
    
    链路测试 "支付超时场景" {
        执行登录("buyer", "password123")
        创建测试订单(商品ID: 101, 数量: 1)
        
        跳转到("/order/" + 获取当前订单ID())
        
        // 模拟支付超时（30分钟）
        模拟时间流逝(30分钟)
        
        // 触发超时检查
        触发定时任务("订单超时检查")
        
        // 验证订单取消
        断言_数据库(订单表) {
            记录 { id: 获取当前订单ID() } 的 status == "cancelled"
            记录 { id: 获取当前订单ID() } 的 cancel_reason == "支付超时"
        }
        
        // 验证库存恢复
        断言_数据库(商品表) {
            记录 { id: 101 } 的 stock == 10  // 恢复原库存
        }
        
        // 刷新页面验证UI
        刷新页面()
        断言_文本("订单状态", "已取消")
        断言_文本("取消原因", "支付超时自动取消")
    }
}
```


---

## 九、测试函数参考

### 9.1 链路测试专用函数

| 函数 | 说明 | 示例 |
|------|------|------|
| `链路测试套件(名称)` | 定义测试套件 | `链路测试套件 "登录流程"` |
| `链路测试(名称)` | 定义单个链路测试 | `链路测试 "成功登录"` |
| `前置准备` | 套件级前置操作 | `前置准备 { ... }` |
| `后置清理` | 套件级后置操作 | `后置清理 { ... }` |

### 9.2 Mock服务函数

| 函数 | 说明 | 示例 |
|------|------|------|
| `启动Mock服务(名称)` | 启动Mock服务 | `启动Mock服务(用户服务Mock)` |
| `停止Mock服务(名称)` | 停止Mock服务 | `停止Mock服务(用户服务Mock)` |
| `停止所有Mock服务()` | 停止所有Mock | `停止所有Mock服务()` |
| `模拟响应(接口, 类型)` | 设置模拟响应 | `模拟响应(登录接口, 成功)` |
| `模拟接口超时(接口)` | 模拟超时 | `模拟接口超时(登录接口, 超时: 5秒)` |
| `模拟接口延迟(接口)` | 模拟延迟 | `模拟接口延迟(登录接口, 延迟: 2秒)` |

### 9.3 数据库操作函数

| 函数 | 说明 | 示例 |
|------|------|------|
| `初始化数据库(配置)` | 初始化测试数据库 | `初始化数据库(测试数据库)` |
| `清空测试数据库()` | 清空所有测试数据 | `清空测试数据库()` |
| `插入测试数据(表, 数据)` | 插入测试数据 | `插入测试数据(用户表, {...})` |
| `更新测试数据(表, 条件, 数据)` | 更新测试数据 | `更新测试数据(用户表, {id:1}, {...})` |
| `清空表(表)` | 清空指定表 | `清空表(订单表)` |
| `查询数据库(表, 条件)` | 查询数据 | `查询数据库(用户表, id: 1)` |

### 9.4 数据库断言函数

| 函数 | 说明 | 示例 |
|------|------|------|
| `断言_数据库(表)` | 数据库状态断言 | `断言_数据库(用户表) { ... }` |
| `断言_数据库变更(表, 条件)` | 数据变更断言 | `断言_数据库变更(用户表, id:1)` |
| `存在记录` | 断言记录存在 | `存在记录 { name: "test" }` |
| `不存在记录` | 断言记录不存在 | `不存在记录 { status: "deleted" }` |
| `记录数量` | 断言记录数 | `记录数量 == 5` |

### 9.5 接口断言函数

| 函数 | 说明 | 示例 |
|------|------|------|
| `断言_接口已调用(接口)` | 验证接口被调用 | `断言_接口已调用(登录接口)` |
| `断言_接口未调用(接口)` | 验证接口未被调用 | `断言_接口未调用(删除接口)` |
| `断言_接口调用次数(接口, 次数)` | 验证调用次数 | `断言_接口调用次数(查询接口, 3)` |
| `断言_接口耗时(接口, 条件)` | 验证接口耗时 | `断言_接口耗时(登录接口, 小于: 500毫秒)` |
| `断言_接口响应(接口, 条件)` | 验证响应内容 | `断言_接口响应(登录接口, 状态码: 200)` |

### 9.6 时间控制函数

| 函数 | 说明 | 示例 |
|------|------|------|
| `模拟时间流逝(时长)` | 模拟时间流逝 | `模拟时间流逝(30分钟)` |
| `设置系统时间(时间)` | 设置模拟时间 | `设置系统时间("2026-01-11 12:00:00")` |
| `触发定时任务(名称)` | 手动触发定时任务 | `触发定时任务("订单超时检查")` |

---

## 十、最佳实践

### 10.1 测试组织

```
tests/
├── e2e/                      # 链路测试目录
│   ├── auth/                 # 认证相关
│   │   ├── login_e2e.yct
│   │   ├── register_e2e.yct
│   │   └── password_e2e.yct
│   ├── order/                # 订单相关
│   │   ├── create_order_e2e.yct
│   │   ├── pay_order_e2e.yct
│   │   └── cancel_order_e2e.yct
│   └── user/                 # 用户相关
│       ├── profile_e2e.yct
│       └── settings_e2e.yct
├── contracts/                # 契约定义
│   ├── user_api.yc
│   ├── order_api.yc
│   └── payment_api.yc
├── mocks/                    # Mock配置
│   ├── user_mock.yc
│   └── payment_mock.yc
└── fixtures/                 # 测试数据
    ├── users.json
    └── products.json
```

### 10.2 测试隔离原则

1. **数据隔离**：每个测试使用独立的测试数据，测试后清理
2. **服务隔离**：使用Mock服务，不依赖真实外部服务
3. **状态隔离**：每个测试前重置应用状态
4. **时间隔离**：使用模拟时间，避免时间相关的不稳定性

### 10.3 命名规范

```御程
// 测试套件：功能模块 + "全流程"/"链路测试"
链路测试套件 "用户登录全流程"
链路测试套件 "订单支付链路测试"

// 测试用例：场景描述
链路测试 "成功登录并跳转首页"
链路测试 "密码错误显示错误提示"
链路测试 "连续失败后账户锁定"
```

### 10.4 断言策略

```御程
// 1. 先验证UI状态
断言_存在("成功消息")
断言_文本("订单状态", "已支付")

// 2. 再验证接口调用
断言_接口已调用(支付接口)
断言_接口响应(支付接口, 状态码: 200)

// 3. 最后验证数据库
断言_数据库(订单表) {
    记录 { id: 订单ID } 的 status == "paid"
}
```

---

## 十一、与传统方案对比

| 维度 | Cypress + Postman | **御程链路测试** |
|------|-------------------|------------------|
| 契约来源 | 手写/分散维护 | `.yc` 规格文件，代码即文档 |
| 类型安全 | 弱类型JSON | 御程类型系统 + 编译期检查 |
| 前后端关联 | 手动协调 | 自动验证UI行为与接口契约一致 |
| 数据库验证 | 需额外工具 | 内置 `断言_数据库` |
| Mock服务 | 需配置Stub | 基于契约自动生成 |
| 覆盖率 | 分散统计 | 统一链路覆盖率报告 |
| 学习成本 | 多工具多语言 | 统一御程语法 |

---

## 十二、总结

御程端到端链路测试系统的核心价值：

1. **契约驱动**：从 `.yc` 规格文件自动派生测试，确保实现与设计一致
2. **全链路覆盖**：从用户点击到数据库写入，每一跳都可验证
3. **类型安全**：编译期检查测试代码，减少运行时错误
4. **自动Mock**：基于契约自动生成Mock服务，无需手动维护
5. **统一报告**：接口、UI、数据库覆盖率统一呈现
6. **中文友好**：全中文关键字，降低学习门槛

这使得御程成为**首个原生支持端到端契约化链路测试的中文编程语言**，特别适合金融、医疗、政务等对可靠性要求极高的领域。
