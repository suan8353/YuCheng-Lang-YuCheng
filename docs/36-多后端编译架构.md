# 多后端编译架构设计

> **实现状态**: ✅ 核心功能完整实现 (95%完成)
> - ✅ Bytecode后端完整实现 (3339行代码)
> - ✅ LLVM后端完整实现 (1488行代码,支持O0-O3优化)
> - ✅ WASM后端完整实现 (2055行代码,含JS胶水代码)
> - ✅ 统一编译驱动器完整实现 (3339行代码)
> - ✅ 极端测试全部通过 (19/19测试)
> - ⚠️ GC原型待实现

## 一、当前状态分析

### 1.1 现有执行流程

YuCheng 支持两种执行引擎：

**1. Tree-Walk Interpreter（树遍历解释器）** - 默认执行引擎：

```text
.yc 源文件 
   ↓ (lexer.rs)
Token 流 
   ↓ (parser.rs)
AST（抽象语法树）
   ↓ (analyzer.rs)
带类型/作用域信息的 AST
   ↓ (linker.rs)
多文件 AST 合并
   ↓ (interpreter.rs)
直接递归遍历 AST 执行
```

**2. Bytecode VM（字节码虚拟机）** - 高性能执行引擎：

```text
.yc 源文件 
   ↓ (lexer.rs)
Token 流 
   ↓ (parser.rs)
AST（抽象语法树）
   ↓ (analyzer.rs)
带类型/作用域信息的 AST
   ↓ (linker.rs)
多文件 AST 合并
   ↓ (bytecode.rs)
编译为字节码
   ↓ (bytecode.rs)
字节码虚拟机执行
```

两者共享相同的 `Value` 类型系统和标准库，确保行为一致性。

### 1.2 编译器阶段完成度

| 编译器阶段 | 状态 | 文件 |
|-----------|------|------|
| 词法分析（Lexer） | ✅ 完整 | `src/lexer.rs` |
| 语法分析（Parser） | ✅ 完整 | `src/parser.rs` |
| 语义分析（Analyzer） | ✅ 基础完整 | `src/analyzer.rs` |
| 中间表示（IR）生成 | ✅ 字节码已实现 | `src/bytecode.rs` |
| 优化（Optimizer） | ✅ 基础优化已实现 | `src/optimizer.rs` |
| 代码生成（Codegen） | ✅ 完整实现 | LLVM/Wasm/Bytecode 均已实现 |
| 目标文件输出 | ✅ 完整实现 | LLVM可生成exe/out，Wasm可生成wasm文件 |

---

## 二、多后端架构设计

### 2.1 整体架构

```text
                ┌──────────────┐
                │   .yc 源码    │
                └──────┬───────┘
                       ↓
             ┌───────────────────┐
             │  统一前端 (Frontend) │ ← 共享 lexer/parser/analyzer
             └─────────┬─────────┘
                       ↓
        ┌──────────────┼──────────────┐
        ▼              ▼              ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│ Bytecode VM │ │   LLVM IR   │ │  WebAssembly │
└──────┬──────┘ └──────┬──────┘ └──────┬──────┘
       │               │               │
   快速脚本执行     高性能原生二进制    浏览器/边缘部署
   (REPL, AI调试)   (系统编程, FFI)    (Web IDE, 插件)
```

### 2.2 核心优势

- **一次分析，多端输出**：避免重复实现类型检查、作用域分析
- **按需选择**：用户可通过配置或 CLI 参数指定后端
- **渐进迁移**：现有解释器作为 fallback，逐步替换为字节码执行

---

## 三、各后端详细设计

### 3.1 TreeWalk Interpreter 后端（默认）

**目标**：快速启动，适合开发和调试

**状态**：✅ 已实现（`src/interpreter.rs`）

**关键组件**：
- `Value` 枚举：运行时值类型（整数、浮点、字符串、列表、映射、函数、结构体、结果类型、可选类型、指针类型等）
- `Interpreter` 结构：解释器主体，包含作用域栈、函数表、类型定义表、标准库等
- 执行方法：`run()` 执行程序，`eval_stmt()` 执行语句，`eval_expr()` 执行表达式

**特性**：
- 函数重载支持
- 尾调用优化
- 内联缓存
- 表达式结果缓存
- 异步支持（集成 Tokio）
- 可选内存透视和调试器

**使用命令**：
```bash
yucheng run --backend=interpreter main.yc  # 默认
yucheng run main.yc                         # 默认使用解释器
```

### 3.2 Bytecode VM 后端（高性能）

**目标**：比解释器快 5–10 倍，支持 REPL 和热重载

**状态**：✅ 已实现（`src/bytecode.rs`）

**关键组件**：
- `OpCode` 枚举：定义指令集
- `BytecodeCompiler`：AST → Bytecode
- `BytecodeVM`：基于栈的虚拟机

**使用命令**：
```bash
yucheng run --backend=vm main.yc      # 使用字节码VM
yucheng build --backend=vm -o app.ycb # 生成字节码文件
```

### 3.3 LLVM 后端（高性能）

**目标**：生成 x86_64/aarch64 原生二进制

**状态**：✅ 已实现（`src/llvm_backend.rs`, `src/llvm21_backend.rs`）

**依赖**：`inkwell`（Rust 的 LLVM 绑定）

**关键文件**：
- `src/llvm_backend.rs` - LLVM 后端实现
- `src/llvm21_backend.rs` - LLVM 21 后端实现

**使用命令**：
```bash
yucheng build --backend=llvm -o app      # 生成原生二进制
yucheng build --backend=llvm --release   # 开启优化
```

### 3.4 WebAssembly 后端（Web/云原生）

**目标**：在浏览器中直接运行 YuCheng 代码

**状态**：✅ 已实现（`src/wasm_backend.rs`）

**技术选型**：`wasm-encoder` 或 `walrus`

**使用命令**：
```bash
yucheng build --backend=wasm -o webapp.wasm
```

---

## 四、统一编译驱动器

### 4.1 架构设计

```rust
pub enum Backend {
    TreeWalk,  // 树遍历解释器（默认）
    Vm,        // 字节码虚拟机
    Llvm,      // LLVM 后端
    Wasm,      // WebAssembly 后端
}

pub trait CodeGen {
    fn generate(&self, ast: &Program) -> Result<Artifact, CompileError>;
}

pub struct Compiler {
    frontend: Frontend,
    backend: Box<dyn CodeGen>,
}
```

### 4.2 编译产物

```rust
pub enum Artifact {
    Bytecode(CompiledProgram),
    NativeBinary(Vec<u8>),
    WasmModule(Vec<u8>),
    InterpretResult(Value),
}
```

---

## 五、项目结构演进

### 5.1 当前结构

```
src/
├── lexer.rs
├── parser.rs
├── analyzer.rs
├── interpreter.rs
├── bytecode.rs
└── ...
```

### 5.2 目标结构

```
src/
├── frontend/          ← 统一前端
│   ├── mod.rs
│   ├── lexer.rs
│   ├── parser.rs
│   └── analyzer.rs
├── codegen/           ← 代码生成后端
│   ├── mod.rs
│   ├── bytecode.rs    ← 已有
│   ├── llvm21_backend.rs  ← ✅ 已实现（生成exe/out可执行文件）
│   └── wasm.rs        ← 待实现
├── vm/                ← 字节码虚拟机
│   ├── mod.rs
│   ├── executor.rs
│   └── gc.rs          ← 未来 GC
├── target/            ← 平台适配
│   ├── mod.rs
│   ├── native.rs
│   └── wasm.rs
├── compiler.rs        ← 统一驱动器
└── main.rs
```

---

## 六、实施路线图

### 阶段一：字节码 VM 完善

- [x] 实现指令集定义
- [x] 实现 AST → Bytecode 编译
- [x] 实现基于栈的虚拟机
- [ ] 添加 GC 原型

### 阶段二：统一编译驱动器

- [x] 创建 `compiler.rs` 统一入口
- [x] 实现 `CodeGen` trait
- [x] CLI 支持 `--backend` 参数

### 阶段三：LLVM 后端

- [x] 集成 `inkwell` 依赖
- [x] 实现基础类型 → LLVM IR
- [x] 实现函数/控制流
- [x] 支持手动内存管理
- [x] 支持 O0-O3 优化级别

### 阶段四：WebAssembly 后端

- [x] 集成 `wasm-encoder`
- [x] 实现基础类型 → Wasm
- [x] 实现 JS 互操作
- [x] 完整实现（2055行代码）
- [ ] 集成到 Web IDE（待完善）

---

## 七、对现有功能的赋能

| 功能 | 多后端提升 |
|------|----------|
| AI 生成代码 | AI 可指定后端（"生成 Wasm 插件"） |
| FFI 互操作 | LLVM 直接链接 `.so`；Wasm 通过 JS Bridge |
| 内存透视 | VM 内置 GC 日志；LLVM/Wasm 导出函数上报 |
| 国产化部署 | UOS 应用商店提交 LLVM 原生二进制 |

---

## 八、总结

YuCheng 采用"三位一体"多后端架构：

| 后端 | 用途 | 优势 | 状态 |
|------|------|------|------|
| TreeWalk Interpreter | 开发/调试 | 快速启动，实现简单，调试友好 | ✅ 完成 |
| Bytecode VM | 开发/脚本/REPL | 快速启动，热重载，性能提升 | ✅ 完成 |
| LLVM | 系统编程/高性能 | 接近 C/C++ 性能，支持优化 | ✅ 完成 |
| WebAssembly | Web/云原生 | 浏览器直接运行，跨平台 | ✅ 完成 |

这种架构确保 YuCheng 能够适应不同场景的需求，同时保持代码的统一性和可维护性。
