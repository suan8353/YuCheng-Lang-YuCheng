# YuCheng 语言 - 内存透视详解

> **实现状态**: ✅ 完整实现
> - ✅ 后端内存追踪完整（700+行代码）
> - ✅ 内存分析和统计功能完整
> - ✅ 实时内存图表和可视化完整
> - ✅ IDE可视化面板完整实现
> - ✅ 热点分析和碎片化追踪
> - ✅ 时间线事件记录

## 0. 重要声明

> **Memory Simulator 是观察工具，不是安全保证。**

| 它是什么 | 它不是什么 |
|----------|------------|
| ✅ 事实记录器 | ❌ 正确性证明器 |
| ✅ 问题检测器 | ❌ 安全保证 |
| ✅ 教学演示工具 | ❌ 运行时防护 |
| ✅ AI 分析数据源 | ❌ 编译器替代品 |

Memory Simulator 会**报告观察到的问题**，但**不会阻止程序执行**。
语言层面的内存安全由编译器的作用域绑定和类型系统保证。

## 1. 系统概述

内存透视系统是 YuCheng 的核心特色功能，在代码运行时实时模拟内存状态，通过两个通道输出：

- **图表通道**：给人看的可视化界面
- **JSON 通道**：给 AI 看的结构化数据

```
代码执行 ──▶ 内存模拟器 ──┬──▶ 图表渲染器 ──▶ IDE面板
                         │
                         └──▶ JSON生成器 ──▶ 报告文件
                                              │
                                              ▼
                                         观察报告
                                       (非安全判决)
```

## 2. 内存模型

### 2.1 栈 (Stack)

```
┌─────────────────────────────┐
│         栈顶 (Top)          │
├─────────────────────────────┤
│  函数帧: 计算结果             │
│  ├─ 局部变量: 临时值 = 42   │
│  └─ 局部变量: 索引 = 0      │
├─────────────────────────────┤
│  函数帧: 主函数               │
│  ├─ 局部变量: 用户名 = "张三"│
│  └─ 局部变量: 计数 = 10     │
└─────────────────────────────┘
```

### 2.2 堆 (Heap)

```
┌──────────┬──────────┬──────────┬──────────┐
│ 0x1000   │ 0x1100   │ 0x1200   │ 0x1300   │
│ 已分配   │ 已释放   │ 已分配   │ 未使用   │
│ 100字节  │ 50字节   │ 200字节  │          │
└──────────┴──────────┴──────────┴──────────┘
```

### 2.3 指针状态

| 状态 | 颜色 | 说明 |
|------|------|------|
| 有效 (Valid) | 🟢 绿色 | 指向已分配的内存 |
| 悬垂 (Dangling) | 🔴 红色 | 指向已释放的内存 |
| 空 (Null) | ⚪ 灰色 | 值为空 |
| 未初始化 | 🟡 黄色 | 声明但未赋值 |

## 3. JSON 报告格式

### 3.1 完整报告结构

```json
{
  "report_id": "run_20260110_001",
  "timestamp": "2026-01-10T10:30:00Z",
  "status": "completed",
  
  "execution_summary": {
    "total_lines": 150,
    "executed_lines": 148,
    "execution_time_ms": 234
  },
  
  "memory_summary": {
    "peak_stack_size": 2048,
    "peak_heap_size": 10240,
    "total_allocations": 15,
    "total_frees": 14,
    "leaked_bytes": 100
  },
  
  "snapshots": [...],
  
  "issues": [
    {
      "type": "MEMORY_LEAK",
      "severity": "warning",
      "location": {"file": "main.yci", "line": 45},
      "message": "内存块 0x1000 (100字节) 未释放",
      "suggestion": "在函数结束前调用 释放(ptr_data)"
    }
  ]
}
```

### 3.2 内存快照结构

```json
{
  "snapshot_id": 25,
  "code_line": 25,
  
  "stack": [
    {
      "function": "主函数",
      "variables": [
        {
          "name": "用户名",
          "type": "文本",
          "value": "\"张三\"",
          "address": "0xFFFF0010"
        }
      ]
    }
  ],
  
  "heap": [
    {
      "address": "0x1000",
      "size": 400,
      "status": "allocated",
      "allocated_at": {"file": "main.yci", "line": 10}
    }
  ],
  
  "pointers": [
    {
      "name": "ptr_data",
      "value": "0x1000",
      "status": "valid",
      "pointer_type": "manual"
    }
  ]
}
```

## 4. 问题类型

### 4.1 错误级别 (Error)

| 类型代码 | 名称 | 说明 |
|---------|------|------|
| `NULL_POINTER_DEREFERENCE` | 空指针解引用 | 访问空指针 |
| `DANGLING_POINTER_ACCESS` | 悬垂指针访问 | 访问已释放内存 |
| `DOUBLE_FREE` | 重复释放 | 同一内存释放两次 |
| `BUFFER_OVERFLOW` | 缓冲区溢出 | 越界访问 |

### 4.2 警告级别 (Warning)

| 类型代码 | 名称 | 说明 |
|---------|------|------|
| `MEMORY_LEAK` | 内存泄漏 | 未释放的内存 |
| `UNINITIALIZED_POINTER` | 未初始化指针 | 使用前未赋值 |
| `UNUSED_ALLOCATION` | 未使用的分配 | 分配后未使用 |

## 5. AI 集成接口

### 5.1 AI 分析报告

```御程
// AI 分析内存报告
var 分析 = AI分析内存报告("memory_report.json")

// 分析结果
{
  "summary": "检测到 2 个内存问题",
  "suggestions": [
    {
      "issue_id": "ISS_001",
      "action": "fix_code",
      "target_file": "main.yci",
      "target_line": 35,
      "fix_code": "如果 ptr <> 空 { ... }"
    }
  ]
}
```

### 5.2 AI 自动修复

```御程
var 修复结果 = AI自动修复("memory_report.json", "main.yci")

如果 修复结果.成功 {
    打印("已修复 ", 修复结果.修复数量, " 个问题")
}
```

## 6. 透视模式使用

### 6.1 命令行

```bash
# 透视运行
yucheng run --inspect project.ycl

# 生成报告
yucheng run --inspect --output report.json project.ycl
```

### 6.2 IDE 操作

点击"透视运行"按钮，右侧面板显示：
- 堆栈结构图
- 内存占用曲线
- 指针关系图
- 问题列表

### 6.3 手动快照

```御程
// 在代码中手动触发快照
内存快照("标记点1")

// 对比快照
var 差异 = 内存差异("标记点1", "标记点2")
```

## 7. 指针检查器

### 7.1 功能概述

指针检查器是混合内存管理系统的核心组件，专门检查手动指针的使用，提供智能提示和自动修复建议。

### 7.2 指针类型

解释器实际支持的指针类型（`Value` 枚举中的变体）：

| 类型 | 实现 | 说明 | 内存管理 |
|------|------|------|----------|
| Box指针 | `Value::BoxPtr(Box<Value>)` | 独占所有权，堆分配 | Rust Box 自动管理 |
| Rc指针 | `Value::RcPtr(Rc<RefCell<Value>>)` | 引用计数，共享所有权 | 引用计数自动释放 |
| Mutex | `Value::Mutex(Arc<Mutex<Value>>)` | 互斥锁，线程安全 | Arc 引用计数管理 |
| RwLock | `Value::RwLock(Arc<RwLock<Value>>)` | 读写锁，多读单写 | Arc 引用计数管理 |
| Channel | `Value::Channel(Arc<ChannelInner>)` | 通道，线程间通信 | Arc 引用计数管理 |
| AtomicInt | `Value::AtomicInt(Arc<AtomicI64>)` | 原子整数 | Arc 引用计数管理 |

**注意**：这些指针类型在解释器中通过 `Value` 枚举实现，内存管理由 Rust 的所有权系统和引用计数机制自动处理。

### 7.3 检查项

#### 7.3.1 空指针检测

```御程
var ptr: 手动指针 = 空
var 值 = *ptr  // ❌ 错误：空指针解引用
```

#### 7.3.2 悬垂指针检测

```御程
var ptr = 分配(100)
释放(ptr)
var 值 = *ptr  // ❌ 错误：访问已释放的指针
```

#### 7.3.3 双重释放检测

```御程
var ptr = 分配(100)
释放(ptr)
释放(ptr)  // ❌ 错误：重复释放
```

#### 7.3.4 内存泄漏检测

```御程
函数 处理数据() {
    var ptr = 分配(1000)
    // ... 处理逻辑
    // ⚠️ 警告：指针未释放
}
```

### 7.4 修复建议

指针检查器会为每个问题提供多种修复建议：

#### 7.4.1 补齐释放语句

```御程
// 问题代码
函数 处理() {
    var ptr = 分配(100)
    返回 结果
}

// 建议修复
函数 处理() {
    var ptr = 分配(100)
    释放(ptr)
    ptr = 空
    返回 结果
}
```

#### 7.4.2 转换为智能指针

```御程
// 问题代码
var ptr = 分配(100)

// 建议修复（推荐）
var ptr = 智能指针(分配(100))  // 自动管理
```

#### 7.4.3 添加 defer 语句

```御程
// 问题代码
函数 处理() {
    var ptr = 分配(100)
    // ... 复杂逻辑
}

// 建议修复
函数 处理() {
    var ptr = 分配(100)
    defer 释放(ptr)  // 函数结束时自动释放
    // ... 复杂逻辑
}
```

#### 7.4.4 添加空值检查

```御程
// 问题代码
var 值 = *ptr

// 建议修复
如果 ptr <> 空 {
    var 值 = *ptr
}
```

### 7.5 不安全块

在不安全块中，指针检查器会放宽检查：

```御程
不安全 {
    var ptr = 分配(100)
    // 不会警告未释放
    // 用户承担责任
}
```

### 7.6 控制流分析

检查器会分析所有控制流路径：

```御程
函数 处理(条件: 布尔) {
    var ptr = 分配(100)
    
    如果 条件 {
        释放(ptr)
        返回
    }
    // ⚠️ 警告：else 分支未释放
}
```

### 7.7 使用方法

```bash
# 运行指针检查
yucheng check --pointers file.ycs

# 自动修复
yucheng check --pointers --fix file.ycs
```

## 8. 最佳实践

1. **开发时始终开启透视模式**
2. **关注警告级别问题**
3. **使用智能指针减少手动管理**
4. **释放后立即置空**
5. **使用 defer 确保释放**

```御程
// 推荐写法1：智能指针
var ptr = 智能指针(分配(100))  // 自动管理

// 推荐写法2：defer
函数 处理() {
    var ptr = 分配(100)
    defer 释放(ptr)  // 确保释放
    // ... 业务逻辑
}

// 推荐写法3：手动释放后置空
释放(指针)
指针 = 空  // 防止悬垂
```
