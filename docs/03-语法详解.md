# YuCheng 语言 - 语法详解（完整版）

> 本文档是御程语言的完整语法和语义参考手册  
> 版本：v0.4.0  
> 更新日期：2026-01-18  
> 测试覆盖：664个测试 (662通过/2失败, 99.7%)

## 重要更新 (v0.4.0)

- ✅ 实现可选类型系统 (T?) - AST: TypeExpr::Optional, TypeKind::Optional
- ✅ 实现泛型类型系统 (列表<T>, 映射<K,V>) - AST: TypeExpr::Generic, TypeKind::Generic
- ⚠️ 实现 Result<T,E> 类型 - 在标准库 stdlib/core/结果.yc 中用 YuCheng 语言实现
- ⚠️ 函数类型 func(T) -> R - 仅支持同步函数，不支持 Future/异步
- ✅ 支持嵌套泛型和复杂类型组合
- ✅ 348个编译期测试 (662通过/2失败)
- ✅ 新增45个高级类型系统测试

## 重要更新 (v0.3.0)

- ✅ 完整实现类型检查系统（禁止隐式类型转换）
- ✅ 完整实现控制流分析系统（确保所有路径返回）
- ✅ 达到 C/C++ 级别的编译期严谨性
- ✅ 303个编译期测试全部通过
- ✅ 新增180个高级特性测试（指针、错误处理、并发、模块）

## 目录

1. [文件类型](#1-文件类型)
2. [基础语法](#2-基础语法)
   - 2.1 [词法规则](#21-词法规则)
   - 2.2 [注释](#22-注释)
   - 2.3 [变量声明](#23-变量声明)
   - 2.4 [数据类型](#24-数据类型)
   - 2.5 [运算符](#25-运算符)
3. [控制结构](#3-控制结构)
4. [函数定义](#4-函数定义)
5. [指针与内存](#5-指针与内存)
6. [类与对象](#6-类与对象)
7. [链接配置](#7-链接配置)
8. [错误处理](#8-错误处理)
9. [符号兼容](#9-符号兼容)
10. [完整示例](#10-完整示例)
11. [单文件模式](#11-单文件模式)
12. [不安全代码](#12-不安全代码)
13. [高级类型系统](#13-高级类型系统)
14. [模块系统](#14-模块系统)
15. [错误传播](#15-错误传播)
16. [注解系统](#16-注解系统)
17. [复合赋值运算符](#17-复合赋值运算符)
18. [Python风格注释](#18-python风格注释)
19. [并发与异步](#19-并发与异步)
20. [混合内存管理](#20-混合内存管理)
21. [语义检查规则](#21-语义检查规则)
   - 21.1 [编译期检查（已实现）](#211-编译期检查已实现)
   - 21.2 [编译期检查（待实现）](#212-编译期检查待实现)
   - 21.3 [运行时检查](#213-运行时检查)
   - 21.4 [内存安全检查](#214-内存安全检查)

---

## 附录

- [附录A：代码级参考](./附录A-代码级参考.md) - 包含所有关键字、AST节点、Token类型、契约系统的代码级定义

---

## 1. 文件类型

| 扩展名 | 用途 | 必须 |
|-------|------|------|
| `.yc` | 规格定义（接口声明） | ✓ |
| `.yci` | 逻辑实现 | ✓ |
| `.ycl` | 链接配置 | ✓ |
| `.ycv` | 界面视图 | 可选 |
| `.ycs` | 单文件模式（教学/原型） | 可选 |

## 2. 基础语法

### 2.1 词法规则

#### 2.1.1 分号规则

御程语言支持**可选分号**语法：

```御程
// 分号是可选的
var x = 10
var y = 20

// 也可以使用分号
var a = 10;
var b = 20;

// 同一行多个语句需要分号分隔
var m = 1; var n = 2
```

**规则**：
- 语句末尾的分号是可选的
- 同一行多个语句之间必须用分号分隔
- 代码块 `{}` 内的语句会自动跳过可选分号

#### 2.1.2 软关键字

某些关键字在特定上下文中可以作为标识符使用（软关键字）：

**可作为标识符的关键字**：
- `测试` / `test` - 可用作函数名或变量名
- `打印` / `print` - 可用作函数名（但 `打印 表达式` 是内置语法）
- `控制台` / `console` - 可用作变量名
- `日志` / `log` - 可用作函数名或变量名
- `调试` / `debug` - 可用作函数名或变量名
- `信息` / `info` - 可用作变量名
- `警告` / `warn` - 可用作函数名或变量名
- `参数` / `param` - 可用作变量名
- `生成` / `generate` - 可用作函数名
- `验证` / `verify` - 可用作函数名
- `期望` / `expect` - 可用作函数名
- `场景` / `scenario` - 可用作变量名
- `级别` / `level` - 可用作变量名
- `单元` / `unit` - 可用作变量名
- `集成` / `integration` - 可用作变量名
- `系统` / `system` - 可用作变量名
- `步进` / `step` - 可用作函数名
- `选择` / `select` - 可用作函数名

**示例**：

```御程
// ✅ 正确：软关键字作为函数名
副作用 func 测试() {
    var x = 10
}

// ✅ 正确：软关键字作为变量名
var 级别 = 5
var 系统 = "Linux"

// ⚠️ 注意：在特定上下文中仍是关键字
测试套件 "用户测试" {  // 这里 "测试套件" 是关键字组合
    测试用例 "登录" {   // 这里 "测试用例" 是关键字组合
        // ...
    }
}
```

### 2.2 注释

```御程
// 单行注释

/*
 * 多行注释
 * 可以跨越多行
 */
```

### 2.3 变量声明

御程语言支持**中英文双语关键字**，`变量` 和 `var` 完全等价：

```御程
// 基本声明（带类型推断）- 使用中文关键字
变量 用户名 = "张三"
变量 年龄 = 18
变量 是否登录 = 假

// 基本声明（带类型推断）- 使用英文关键字
var 用户名 = "张三"
var 年龄 = 18
var 是否登录 = 假

// 显式类型声明 - 中英文混用
变量 计数器: 整数 = 0
var 欢迎语: 文本 = "你好"
变量 价格: 小数 = 99.9
var 已激活: 布尔 = 真

// 类型转换必须显式（禁止隐式转换）
变量 a: 整数 = 5
变量 b: 小数 = 转小数(a)  // ✅ 必须显式转换
// 变量 c: 小数 = a       // ❌ 编译错误：不允许隐式转换
```

**关键字等价关系**：
- `变量` ≡ `var` - 变量声明
- `常量` ≡ `const` - 常量声明
- `函数` ≡ `func` - 函数定义
- `如果` ≡ `if` - 条件判断
- `否则` ≡ `else` - 否则分支
- `当` ≡ `while` - 循环
- `循环` ≡ `for` - 遍历循环
- `返回` ≡ `return` - 返回值
- `真` ≡ `true` - 布尔真值
- `假` ≡ `false` - 布尔假值

### 2.4 数据类型

| 类型 | 中文关键字 | 英文关键字 | 示例 |
|------|-----------|-----------|------|
| 整数 | `整数` | `int` | `100`, `-50`, `0`, `0xFF` (十六进制) |
| 小数 | `小数` | `float` | `3.14`, `-0.5`, `1.5e10` (科学计数法) |
| 文本 | `文本` | `string` | `"你好"`, `"Hello"` |
| 布尔 | `布尔` | `bool` | `真`/`true`, `假`/`false` |
| 列表 | `列表` | `list` | `[1, 2, 3]` |
| 字典 | `字典` | `dict` | `{"键": "值"}` |
| 空值 | `空` | `null` | `空`/`null` |

**数字字面量格式**：
```御程
// 十进制整数
变量 十进制 = 100

// 十六进制整数（0x 或 0X 前缀）
变量 十六进制 = 0xFF        // 255
变量 十六进制2 = 0x1000000  // 16777216

// 二进制整数（0b 或 0B 前缀）
变量 二进制 = 0b1010        // 10

// 八进制整数（0o 或 0O 前缀）
变量 八进制 = 0o777         // 511

// 浮点数
变量 浮点数 = 3.14
变量 科学计数法 = 1.5e10    // 15000000000

// 布尔值（中英文都支持）
变量 是 = 真      // 或 true
变量 否 = 假      // 或 false
```

### 2.5 运算符

#### 赋值运算符

```御程
// 赋值
年龄 = 18
名字 = "张三"

// 复合赋值
计数 += 1
总价 -= 折扣
数量 *= 2
```

#### 比较运算符

```御程
a == b    // 等于
a <> b    // 不等于
a > b     // 大于
a < b     // 小于
a >= b    // 大于等于
a <= b    // 小于等于
```

#### 逻辑运算符

```御程
a && b    // 并且
a || b    // 或者
!a        // 非
```

#### 算术运算符

```御程
a + b     // 加
a - b     // 减
a * b     // 乘
a / b     // 除
a % b     // 取余
a ** b    // 幂运算
```

### 2.5 数据流符号

```御程
// 输出：数据流向目标
控制台 => "你好，世界"
控制台 => "结果是：", 计算结果

// 输入：数据流入变量
控制台 <= 用户输入
文件 <= 文件内容
```

## 3. 控制结构

### 3.1 条件判断

```御程
// 基本 if-else
如果 年龄 >= 18 {
    控制台 => "成年人"
} 否则 {
    控制台 => "未成年人"
}

// 多条件
如果 分数 >= 90 {
    等级 = "优秀"
} 否则如果 分数 >= 60 {
    等级 = "及格"
} 否则 {
    等级 = "不及格"
}

// 单行简写
如果 已登录 { 显示主页() }
```

### 3.2 循环

```御程
// 遍历循环（for-in）
循环 水果 在 水果列表 {
    控制台 => "水果：", 水果
}

// 范围循环
循环 i 在 1..10 {
    控制台 => "数字：", i
}

// 条件循环（while）
当 计数 < 100 {
    计数 += 1
}

// 无限循环 + 跳出
当 真 {
    如果 条件满足 {
        中断
    }
}

// 跳过当前迭代
循环 数字 在 数字列表 {
    如果 数字 < 0 {
        继续
    }
    处理(数字)
}
```

### 3.3 匹配 (类似 switch)

```御程
匹配 状态码 {
    200 => 控制台 => "成功"
    404 => 控制台 => "未找到"
    500 => 控制台 => "服务器错误"
    其他 => 控制台 => "未知状态"
}
```

## 4. 函数定义

### 4.1 函数分类关键字

所有函数必须使用分类关键字声明（编译器强制检查）：

| 关键字 | 英文关键字 | 特点 | 用途 | 调用限制 |
|--------|-----------|------|------|---------|
| `纯函数` | `compute` | 无副作用，可缓存 | 数学运算、数据转换 | 只能调用其他纯函数 |
| `查询` | `query` | 只读，不修改状态 | 读取数据、查询 | 可调用纯函数和查询 |
| `副作用` | `effect` | 可修改状态、I/O | 修改状态、I/O操作 | 无限制 |

### 4.2 规格定义 (.yc 文件)

```御程
// math.yc

// 变量声明
var 全局计数器 = 0

// 纯函数：无副作用，可缓存、可并行
纯函数 func 加法(数字a: 整数, 数字b: 整数) -> 整数
纯函数 func 圆面积(半径: 小数) -> 小数
纯函数 func 阶乘(n: 整数) -> 整数

// 查询函数：只读，不修改状态
查询 func 当前时间() -> 时间戳
查询 func 用户信息(用户ID: 整数) -> 用户数据

// 副作用函数：可修改状态、执行I/O
副作用 func 打印日志(内容: 文本)
副作用 func 保存文件(路径: 文本, 数据: 文本)
副作用 func 发送请求(地址: 文本) -> 响应
```

### 4.3 契约声明（可选）

```御程
// 在规格文件中声明前置/后置条件
纯函数 func 平方根(x: 小数) -> 小数
    要求 x >= 0.0           // 前置条件
    保证 返回值 >= 0.0       // 后置条件

纯函数 func 除法(a: 小数, b: 小数) -> 小数
    要求 b <> 0.0           // 除数不能为零
```

### 4.4 逻辑实现 (.yci 文件)

```御程
// math.yci

// 实现纯函数
纯函数 func 加法(数字a: 整数, 数字b: 整数) -> 整数 {
    返回 数字a + 数字b
}

纯函数 func 圆面积(半径: 小数) -> 小数 {
    返回 3.14159 * 半径 ** 2
}

纯函数 func 阶乘(n: 整数) -> 整数 {
    如果 n <= 1 {
        返回 1
    } 否则 {
        返回 n * 阶乘(n - 1)
    }
}

// 实现查询函数
查询 func 当前时间() -> 时间戳 {
    返回 系统.当前时间()
}

// 实现副作用函数
副作用 func 打印日志(内容: 文本) {
    控制台 => "[日志] ", 内容
    全局计数器 += 1
}
```

### 4.5 编译器强制约束

```御程
// ✅ 正确：纯函数只调用纯函数
纯函数 func 计算面积(长: 小数, 宽: 小数) -> 小数 {
    返回 长 * 宽
}

// ❌ 编译错误：纯函数内不能调用副作用函数
纯函数 func 计算并打印(a: 整数) -> 整数 {
    打印日志("计算中")  // 错误：纯函数内禁止调用副作用函数
    返回 a * 2
}
```

### 4.6 函数调用

```御程
// 基本调用
var 结果 = 加法(10, 20)

// 链式调用
var 最终结果 = 加法(乘法(2, 3), 4)

// 忽略返回值
打印日志("操作完成")
```

## 5. 指针与内存

### 5.1 作用域绑定（默认，推荐）

```御程
// 默认使用作用域自动析构
{
    var 数据指针 = 申请(整数, 100)  // 申请100个整数的空间
    
    // 使用
    数据指针[0] = 42
    控制台 => 数据指针[0]
    
} // 离开作用域自动释放
```

### 5.2 显式延长生命周期

```御程
var 全局缓存: 指针<字节> = 空

副作用 func 初始化缓存() {
    var buf = 申请(1024)
    全局缓存 = 持有(buf)  // 显式延长生命周期
    // buf 离开作用域不会被释放
}

副作用 func 清理缓存() {
    释放(全局缓存)  // 手动释放
    全局缓存 = 空
}
```

### 5.3 编译器静态检查

```御程
// ❌ 编译警告：持有/释放不成对
副作用 func 泄漏示例() {
    var buf = 申请(1024)
    var p = 持有(buf)
    // 警告：p 被持有但从未释放
}

// ❌ 编译错误：释放后使用
副作用 func 悬垂示例() {
    var buf = 申请(1024)
    var p = 持有(buf)
    释放(p)
    var x = p[0]  // 错误：p 已被释放
}
```

## 6. 类与对象

### 6.1 类定义 (.yc 文件)

```御程
// user.yc

class 用户 {
    // 属性
    var 用户名: 文本
    var 密码: 文本
    var 等级: 整数 = 1
    
    // 方法声明
    查询 func 显示名() -> 文本
    副作用 func 升级()
    纯函数 func 经验值(基础值: 整数) -> 整数
}
```

### 6.2 类实现 (.yci 文件)

```御程
// user.yci

查询 func 用户.显示名() -> 文本 {
    返回 用户名 + " (Lv." + 转文本(等级) + ")"
}

副作用 func 用户.升级() {
    等级 += 1
    打印("升级到 " + 转文本(等级) + " 级")
}

纯函数 func 用户.经验值(基础值: 整数) -> 整数 {
    返回 转整数(转小数(基础值) * 转小数(等级) * 1.5)
}
```

### 6.3 对象使用

```御程
// 创建对象
var 玩家 = 新建 用户()
玩家.用户名 = "张三"
玩家.密码 = "123456"

// 调用方法
var 显示名 = 玩家.显示名()
玩家.升级()

// 访问属性
控制台 => "当前等级：", 玩家.等级
```

## 7. 链接配置 (.ycl 文件)

```json
{
  "项目名称": "我的应用",
  "版本": "1.0.0",
  
  "模块链接": [
    {
      "规格": "main.yc",
      "实现": "main.yci",
      "视图": "main.ycv"
    },
    {
      "规格": "utils.yc",
      "实现": "utils.yci"
    }
  ],
  
  "入口函数": "主函数",
  
  "依赖库": [
    "数学库",
    "网络库"
  ],
  
  "错误处理": {
    "缺失定义": "报错并终止",
    "缺失实现": "报错并终止",
    "变量未使用": "警告"
  }
}
```

## 8. 错误处理

### 8.1 尝试-捕获

御程语言使用 `尝试-捕获` 语法进行错误处理：

```御程
// 基本错误捕获
尝试 {
    变量 结果 = 危险操作()
    打印("操作成功")
} 捕获 错误 {
    打印("发生错误: " + 转文本(错误))
}

// 捕获并处理错误
尝试 {
    设置CPU频率(2400)
    打印("CPU频率设置成功")
} 捕获 错误 {
    打印("权限不足: " + 转文本(错误))
}

// 带最终清理块
尝试 {
    变量 文件 = 打开文件("data.txt")
    // 使用文件...
} 捕获 错误 {
    打印("文件操作失败: " + 转文本(错误))
} 最终 {
    清理资源()  // 无论成功或失败都会执行
}
```

**错误处理规则**：
- `尝试` 块中的代码如果抛出错误，会立即跳转到 `捕获` 块
- `捕获` 块中的 `错误` 变量包含错误信息
- `最终` 块（可选）无论是否发生错误都会执行
- 错误信息可以通过 `转文本(错误)` 转换为字符串

### 8.2 抛出错误

```御程
副作用 func 验证年龄(年龄: 整数) {
    如果 年龄 < 0 {
        抛出 错误("年龄不能为负数")
    }
    如果 年龄 > 150 {
        抛出 错误("年龄不合理")
    }
}

// 在函数中使用
副作用 func 主函数() {
    尝试 {
        验证年龄(-5)
    } 捕获 错误 {
        打印("验证失败: " + 转文本(错误))
    }
}
```

### 8.3 标准库错误处理函数

```御程
// 创建成功结果
变量 成功结果 = 成功(值)

// 创建失败结果
变量 失败结果 = 失败("错误消息")

// 检查结果类型
如果 是成功(结果) {
    // 处理成功情况
} 否则如果 是失败(结果) {
    // 处理失败情况
}

// 解包结果（失败时返回默认值）
变量 值 = 解包或(结果, 默认值)
```

## 9. 符号兼容

以下全角符号会被自动转换为半角符号：

```御程
// 以下写法等价：

如果 (年龄 > 18) { ... }
如果 （年龄 ＞ 18） ｛ ... ｝

控制台 => "你好";
控制台 => "你好"；

列表[0]
列表［0］
```

## 10. 完整示例

### calculator.yc (规格)
```御程
var 历史记录: 列表<字典> = []

纯函数 func 加法(a: 小数, b: 小数) -> 小数
纯函数 func 减法(a: 小数, b: 小数) -> 小数
纯函数 func 乘法(a: 小数, b: 小数) -> 小数
纯函数 func 除法(a: 小数, b: 小数) -> 小数
    要求 b <> 0.0

查询 func 历史() -> 列表<字典>

副作用 func 记录(表达式: 文本, 结果: 小数)
副作用 func 清空历史()
```

### calculator.yci (实现)
```御程
纯函数 func 加法(a: 小数, b: 小数) -> 小数 {
    返回 a + b
}

纯函数 func 减法(a: 小数, b: 小数) -> 小数 {
    返回 a - b
}

纯函数 func 乘法(a: 小数, b: 小数) -> 小数 {
    返回 a * b
}

纯函数 func 除法(a: 小数, b: 小数) -> 小数 {
    返回 a / b
}

查询 func 历史() -> 列表<字典> {
    返回 历史记录
}

副作用 func 记录(表达式: 文本, 结果: 小数) {
    历史记录.添加({
        "表达式": 表达式,
        "结果": 结果,
        "时间": 当前时间()
    })
}

副作用 func 清空历史() {
    历史记录 = []
}
```

### calculator.ycl (链接)
```json
{
  "项目名称": "计算器",
  "模块链接": [
    { "规格": "calculator.yc", "实现": "calculator.yci" }
  ],
  "入口函数": "主函数"
}
```

## 11. 单文件模式 (.ycs)

对于简单项目或教学场景，可使用单文件模式：

```御程
// hello.ycs - 单文件模式

#规格
纯函数 func 加法(a: 整数, b: 整数) -> 整数
副作用 func 主函数()

#实现
纯函数 func 加法(a: 整数, b: 整数) -> 整数 {
    返回 a + b
}

副作用 func 主函数() {
    var 结果 = 加法(1, 2)
    控制台 => "1 + 2 = ", 结果
}

#视图
窗口 主窗口 {
    标题: "Hello YuCheng"
    
    按钮 {
        文字: "计算"
        点击 => 主函数()
    }
}
```

工具链支持：
```bash
# 直接运行单文件
yucheng run hello.ycs

# 拆分为标准四文件结构
yucheng split hello.ycs --output ./src/
```


## 12. 不安全代码

### 12.1 不安全块

当需要进行底层操作（如 FFI、原始指针）时，必须使用 `不安全` 块：

```御程
// 不安全块 - 显式标记危险代码
不安全 {
    // 这里可以：
    // - 使用原始指针
    // - 调用外部 C 函数
    // - 绕过借用检查
    var 原始指针 = 申请(1024)
    // ... 手动管理内存
    释放(原始指针)
}
```

### 12.2 不安全函数

整个函数可以标记为不安全：

```御程
// 不安全函数 - 调用者必须在不安全块中调用
不安全 副作用 func 底层内存操作(地址: 指针, 大小: 整数) {
    // 直接操作内存
}

// 调用不安全函数
不安全 {
    底层内存操作(某地址, 1024)
}
```

### 12.3 FFI 调用

所有外部函数调用自动视为不安全：

```御程
// 声明外部函数
外部 库 "libc" func malloc(size: 整数) -> 指针
外部 库 "libc" func free(ptr: 指针)

// 必须在不安全块中调用
不安全 {
    var 内存 = malloc(1024)
    // 使用内存...
    free(内存)
}
```

### 12.4 安全边界原则

| 区域 | 保证 | 责任方 |
|------|------|--------|
| 普通代码 | 内存安全、类型安全 | 编译器 |
| 不安全块 | 无保证 | 程序员 |
| FFI 调用 | 无保证 | 程序员 |

> **重要**：`不安全` 块内的代码不受编译器安全检查保护。
> 使用前请确保你理解正在做什么。


## 13. 高级类型系统

### 13.1 类型别名

```御程
// 简单类型别名
类型 用户ID = 整数
类型 邮箱 = 文本

// 泛型类型别名
类型 结果<T> = T
类型 可选<T> = T?
```

### 13.2 接口定义

```御程
// 定义接口
接口 可显示 {
    查询 func 显示() -> 文本
}

接口 可比较<T> {
    纯函数 func 比较(其他: T) -> 整数
}

// 带泛型约束的接口
接口 容器<T: 可显示> {
    查询 func 获取(索引: 整数) -> T
    副作用 func 添加(元素: T)
}
```

### 13.3 泛型类型

```御程
// 泛型类定义
class 列表<T> {
    var 元素: T[]
    
    查询 func 长度() -> 整数
    副作用 func 添加(元素: T)
}

// 泛型函数
纯函数 func 交换<T>(a: T, b: T) -> (T, T) {
    返回 (b, a)
}
```

## 14. 模块系统

### 14.1 导入

```御程
// 导入整个模块
导入 数学库

// 导入并重命名
导入 网络库 作为 网络

// 选择性导入（计划中）
// 导入 { 加法, 减法 } 从 数学库
```

### 14.2 导出

```御程
// 导出函数
导出 纯函数 func 公开函数() -> 整数 {
    返回 42
}

// 导出类型
导出 类型 公开类型 {
    var 字段: 文本
}
```

### 14.3 外部库声明

```御程
// 声明外部 C 库函数
外部 库 "libc" func malloc(size: 整数) -> 指针
外部 库 "libc" func free(ptr: 指针)

// 声明多个函数
外部 库 "mylib" {
    func 初始化() -> 整数
    func 清理()
    func 处理(数据: 指针, 长度: 整数) -> 整数
}
```

## 15. 错误传播

### 15.1 `?` 运算符

```御程
// 错误传播：如果结果是错误，立即返回
副作用 func 读取配置() -> 结果<配置> {
    var 文件内容 = 读取文件("config.json")?  // 失败则返回错误
    var 配置 = 解析JSON(文件内容)?           // 失败则返回错误
    返回 成功(配置)
}

// 链式错误传播
副作用 func 处理数据() -> 结果<数据> {
    var 原始 = 获取数据()?
    var 验证后 = 验证(原始)?
    var 处理后 = 转换(验证后)?
    返回 成功(处理后)
}
```

### 15.2 `抛出` 语句

```御程
副作用 func 验证年龄(年龄: 整数) {
    如果 年龄 < 0 {
        抛出 错误("年龄不能为负数")
    }
    如果 年龄 > 150 {
        抛出 错误("年龄不合理")
    }
}
```

## 16. 注解系统

### 16.1 `@` 注解

```御程
// 测试注解
@测试
副作用 func 测试加法() {
    断言(加法(1, 2) == 3)
}

// 字段注解
class 用户 {
    @必填
    var 用户名: 文本
    
    @主键
    var ID: 整数
    
    @默认值("未知")
    var 昵称: 文本
}

// 契约等级注解
纯函数 func 平方根(x: 小数) -> 小数
    @可验证 要求 x >= 0.0
    @运行时 保证 返回值 >= 0.0
```

## 17. 复合赋值运算符

```御程
var x = 10

x += 5   // x = x + 5
x -= 3   // x = x - 3
x *= 2   // x = x * 2
x /= 4   // x = x / 4
x %= 3   // x = x % 3
```

## 18. Python 风格注释

```御程
# 这是单行注释（Python 风格）
# 可以用于快速注释

// 这也是单行注释（C 风格）

/*
 * 多行注释
 */
```

---

## 18. 测试断言语法

### 18.1 基础断言

```御程
// 相等断言
断言(x == 5, "x 应该等于 5")
断言_相等(实际值, 期望值)
断言_不相等(实际值, 期望值)

// 布尔断言
断言_真(条件)
断言_假(条件)

// 空值断言
断言_空(值)
断言_非空(值)

// 类型断言
断言_类型(值, "整数")
```

### 18.2 数值断言

```御程
// 比较断言
断言_大于(a, b)
断言_小于(a, b)
断言_大于等于(a, b)
断言_小于等于(a, b)

// 范围断言
断言_在范围(值, 最小值, 最大值)
断言_接近(实际值, 期望值, 误差)
```

### 18.3 字符串断言

```御程
// 字符串断言
断言_包含(文本, 子串)
断言_不包含(文本, 子串)
断言_开头是(文本, 前缀)
断言_结尾是(文本, 后缀)
断言_匹配(文本, 正则表达式)
```

### 18.4 集合断言

```御程
// 列表断言
断言_长度(列表, 期望长度)
断言_包含元素(列表, 元素)
断言_不包含元素(列表, 元素)
断言_列表相等(列表1, 列表2)

// 映射断言
断言_包含键(映射, 键)
断言_键值对(映射, 键, 值)
```

### 18.5 错误断言

```御程
// 异常断言
断言_抛出(函数调用)
断言_不抛出(函数调用)

// Result类型断言
断言_成功(结果)
断言_失败(结果)
断言_成功值(结果, 期望值)
```

### 18.6 高级测试语法

```御程
// 边界测试
边界测试 func 测试整数边界() {
    断言_相等(处理(-1), 错误)
    断言_相等(处理(0), 成功)
    断言_相等(处理(最大整数), 成功)
}

// 链路测试
链路测试 "用户注册流程" {
    阶段 "输入验证" {
        断言_真(验证用户名("test"))
    }
    
    阶段 "数据存储" {
        var 用户 = 创建用户("test")
        断言_非空(用户)
    }
}

// 属性测试
属性测试 "加法交换律" {
    输入: 整数 a, 整数 b
    迭代: 100
    验证: a + b == b + a
}

// 快照断言
断言_快照("测试名称", 输出内容)
更新_快照("测试名称", 新内容)
```

---

## 19. UI系统语法

### 19.1 窗口定义

```御程
// 基本窗口
窗口 主窗口 {
    标题: "御程应用"
    宽度: 800
    高度: 600
    
    // 窗口内容
}

// 带状态的窗口
窗口 {
    状态 {
        计数: 0
        用户名: ""
        已登录: 假
    }
    
    // UI组件
}
```

### 19.2 布局系统

```御程
// 垂直布局
布局_垂直 {
    文本标签 { 内容: "标题" }
    按钮 { 文字: "点击" }
}

// 水平布局
布局_水平 {
    文本框 { 提示: "输入" }
    按钮 { 文字: "提交" }
}

// 网格布局
布局_网格 {
    行数: 3
    列数: 3
    间距: 10
    
    // 子组件
}

// 弹性布局
布局_弹性 {
    方向: 水平
    对齐: 居中
    间距: 20
}
```

### 19.3 基础控件

```御程
// 文本标签
文本标签 {
    内容: "你好，世界"
    字体大小: 16
    字体颜色: "#333333"
    字体粗细: "粗体"
}

// 按钮
按钮 {
    文字: "点击我"
    点击 => 处理点击()
    背景色: "#1976D2"
    文字颜色: "#FFFFFF"
    圆角: 4
}

// 文本框
文本框 {
    值: 双向绑定(用户名)
    提示文字: "请输入用户名"
    最大长度: 20
    变化 => 验证输入()
}

// 密码框
密码框 {
    值: 双向绑定(密码)
    提示文字: "请输入密码"
}

// 复选框
复选框 {
    选中: 双向绑定(同意条款)
    标签: "我同意用户协议"
}

// 单选按钮
单选按钮组 {
    选中值: 双向绑定(性别)
    
    单选按钮 { 值: "男", 标签: "男" }
    单选按钮 { 值: "女", 标签: "女" }
}

// 下拉选择
下拉选择 {
    选中值: 双向绑定(城市)
    选项: ["北京", "上海", "广州", "深圳"]
}

// 滑块
滑块 {
    值: 双向绑定(音量)
    最小值: 0
    最大值: 100
    步长: 1
}
```

### 19.4 高级控件

```御程
// 列表
列表 {
    数据源: 绑定(用户列表)
    
    列表项模板 用户 {
        布局_水平 {
            头像 { 文字: 用户.姓名[0] }
            文本标签 { 内容: 绑定(用户.姓名) }
        }
    }
}

// 表格
表格 {
    数据源: 绑定(数据列表)
    
    列 { 标题: "姓名", 字段: "姓名" }
    列 { 标题: "年龄", 字段: "年龄" }
    列 { 标题: "城市", 字段: "城市" }
}

// 标签页
标签页组 {
    标签页 { 标题: "首页", 内容: 首页内容() }
    标签页 { 标题: "设置", 内容: 设置内容() }
}

// 对话框
对话框 {
    标题: "确认"
    内容: "确定要删除吗？"
    
    按钮 { 文字: "确定", 点击 => 确认删除() }
    按钮 { 文字: "取消", 点击 => 关闭对话框() }
}

// 菜单
菜单 {
    菜单项 { 文字: "新建", 快捷键: "Ctrl+N", 点击 => 新建() }
    菜单项 { 文字: "打开", 快捷键: "Ctrl+O", 点击 => 打开() }
    分隔线 {}
    菜单项 { 文字: "退出", 点击 => 退出() }
}
```

### 19.5 数据绑定

```御程
窗口 {
    状态 {
        计数: 0
        用户名: ""
    }
    
    // 单向绑定
    文本标签 { 内容: 绑定(计数) }
    
    // 双向绑定
    文本框 { 值: 双向绑定(用户名) }
    
    // 计算属性绑定
    文本标签 { 内容: 绑定(计数 * 2) }
    
    // 条件绑定
    若显示(已登录) {
        文本标签 { 内容: "欢迎回来" }
    }
    
    // 列表绑定
    循环渲染(用户列表) 为 用户, 索引 {
        文本标签 { 内容: 绑定(用户.姓名) }
    }
}
```

### 19.6 事件处理

```御程
按钮 {
    文字: "点击"
    
    // 点击事件
    点击 => 处理点击()
    
    // 双击事件
    双击 => 处理双击()
    
    // 悬停事件
    悬停 => 显示提示()
    离开 => 隐藏提示()
    
    // 键盘事件
    按键 => 处理按键(事件)
}

文本框 {
    // 输入事件
    输入 => 验证输入()
    
    // 焦点事件
    获得焦点 => 高亮边框()
    失去焦点 => 恢复边框()
    
    // 变化事件
    变化 => 保存草稿()
}
```

### 19.7 样式系统

```御程
// 内联样式
按钮 {
    文字: "按钮"
    背景色: "#1976D2"
    文字颜色: "#FFFFFF"
    圆角: 4
    内边距: "10 20"
    外边距: "5"
    边框: "1px solid #ccc"
    阴影: "0 2px 4px rgba(0,0,0,0.1)"
}

// 主题系统
主题 亮色主题 {
    主色: "#1976D2"
    背景色: "#ffffff"
    文字色: "#333333"
    边框色: "#e0e0e0"
}

窗口 {
    应用主题: 亮色主题
    
    按钮 {
        背景色: 主题.主色
        文字颜色: 主题.背景色
    }
}
```

### 19.8 动画系统

```御程
// 定义动画
动画 淡入 {
    从: { 透明度: 0 }
    到: { 透明度: 1 }
    时长: 300毫秒
    缓动: 渐出
}

动画 滑入 {
    从: { 位移X: -100 }
    到: { 位移X: 0 }
    时长: 500毫秒
    缓动: 弹性
}

// 使用动画
卡片 {
    入场动画: 淡入
    悬停动画: 脉冲
    
    文本标签 { 内容: "动画卡片" }
}
```

### 19.9 响应式设计

```御程
窗口 {
    // 响应式布局
    响应式布局 {
        // 手机
        当 宽度 < 600 {
            布局_垂直 { }
        }
        
        // 平板
        当 宽度 >= 600 且 宽度 < 1024 {
            布局_网格 { 列数: 2 }
        }
        
        // 桌面
        当 宽度 >= 1024 {
            布局_网格 { 列数: 3 }
        }
    }
}
```

### 19.10 表单验证

```御程
表单 用户表单 {
    验证模式: 提交时
    
    表单项 {
        名称: "用户名"
        必填: 真
        
        文本框 用户名输入 {
            验证 {
                规则 非空 { 消息: "用户名不能为空" }
                规则 最小长度(3) { 消息: "用户名至少3个字符" }
                规则 最大长度(20) { 消息: "用户名最多20个字符" }
                规则 正则("^[a-zA-Z0-9_]+$") { 消息: "只能包含字母数字下划线" }
            }
        }
    }
    
    表单项 {
        名称: "邮箱"
        
        文本框 邮箱输入 {
            验证 {
                规则 邮箱格式 { 消息: "请输入有效的邮箱地址" }
            }
        }
    }
    
    按钮 {
        文字: "提交"
        点击 => 提交表单(用户表单)
    }
}
```

### 19.11 国际化

```御程
// 定义语言包
语言包 中文 {
    欢迎: "欢迎使用御程"
    登录: "登录"
    注册: "注册"
    欢迎用户: "欢迎，{用户名}！"
}

语言包 英文 {
    欢迎: "Welcome to YuCheng"
    登录: "Login"
    注册: "Register"
    欢迎用户: "Welcome, {用户名}!"
}

窗口 {
    当前语言: 中文
    
    文本标签 { 内容: 多语言(欢迎) }
    
    按钮 { 文字: 多语言(登录) }
    
    // 带参数
    文本标签 { 
        内容: 多语言(欢迎用户, 用户名: "张三") 
    }
}
```

### 19.12 无障碍支持

```御程
窗口 {
    无障碍 {
        角色: "应用程序"
        标签: "御程示例应用"
        描述: "这是一个演示无障碍功能的应用"
    }
    
    按钮 {
        文字: "🏠"
        无障碍 {
            标签: "返回首页"
            快捷键: "Alt+H"
            提示: "点击返回首页"
        }
    }
    
    文本框 {
        无障碍 {
            标签: "用户名输入框"
            必填: 真
            错误消息: 绑定(用户名错误)
        }
    }
}
```

---

## 20. 并发与异步

### 19.1 协程基础

```御程
// 使用 异步 关键字定义协程
异步 func 获取数据(url: 文本) -> 结果<文本, 网络错误> {
    var 响应 = 等待 HTTP_GET(url)
    返回 响应.内容
}

// 调用协程
副作用 func 主函数() {
    var 数据 = 等待 获取数据("https://api.example.com")
    控制台 => 数据
}
```

### 19.2 等待操作

```御程
// 等待单个协程
var 结果 = 等待 异步操作()

// 等待多个协程（全部完成）
var (a, b, c) = 等待_全部(
    获取用户(),
    获取订单(),
    获取配置()
)

// 等待任一完成
var 首个 = 等待_任一(
    从服务器A获取(),
    从服务器B获取()
)

// 带超时等待
var 结果 = 等待_超时(获取数据(), 5000毫秒)
匹配 结果 {
    成功(数据) => 处理(数据)
    超时 => 控制台 => "请求超时"
}
```

### 19.3 通道通信

```御程
// 创建通道
var 消息通道 = 通道<文本>()           // 无缓冲通道
var 数据通道 = 通道<整数>(容量: 10)   // 缓冲通道

// 发送数据
消息通道 <- "Hello"

// 接收数据
var 消息 = <- 消息通道

// 选择器（多通道监听）
选择 {
    当 消息 <- 消息通道 => {
        控制台 => "收到消息: ", 消息
    }
    当 数据 <- 数据通道 => {
        处理数据(数据)
    }
    当 超时(1000毫秒) => {
        控制台 => "等待超时"
    }
    默认 => {
        控制台 => "无数据可用"
    }
}
```

### 19.4 并行计算

```御程
// 纯函数可以安全并行执行
纯函数 func 计算平方(x: 整数) -> 整数 {
    返回 x * x
}

// 并行映射
var 数据 = [1, 2, 3, 4, 5, 6, 7, 8]
var 结果 = 并行_映射(数据, 计算平方)  // 自动分配到多核

// 显式并行区块
并行 {
    任务 "下载图片" {
        var 图片 = 等待 下载("image.png")
    }
    
    任务 "处理数据" {
        var 数据 = 等待 加载数据()
    }
}
// 所有任务完成后继续
```

### 19.5 同步原语

```御程
// 互斥锁
var 锁 = 互斥锁()

副作用 func 安全更新() {
    锁定 锁 {
        // 临界区代码
        共享数据 += 1
    }
}

// 读写锁
var 读写锁 = 读写锁()

查询 func 读取数据() -> 数据 {
    读锁定 读写锁 {
        返回 共享数据.克隆()
    }
}

副作用 func 写入数据(新数据: 数据) {
    写锁定 读写锁 {
        共享数据 = 新数据
    }
}

// 原子操作
var 计数器 = 原子<整数>(0)
计数器.增加(1)
计数器.减少(1)
var 值 = 计数器.加载()
```

---

## 20. 混合内存管理

### 20.1 自动指针（默认）

```御程
// 所有普通变量都是自动管理的
var 用户 = 用户("张三", 25)
var 列表 = [1, 2, 3]
var 数据 = {"名字": "李四"}

// 离开作用域自动释放，无需手动管理
```

### 20.2 手动指针

```御程
// 使用 手动指针 关键字声明
var ptr: 手动指针<整数> = 分配(100)  // 分配 100 字节

// 解引用
var 值 = *ptr

// 赋值
*ptr = 42

// 手动释放
释放(ptr)
ptr = 空  // 建议：释放后置空
```

### 20.3 智能指针

```御程
// 显式声明智能指针（引用计数）
var smart: 智能指针<用户> = 智能指针(用户("张三", 25))

// 共享所有权
var smart2 = smart  // 引用计数 +1

// 离开作用域自动释放
```

### 20.4 defer 语句

```御程
// 使用 defer 确保释放
副作用 func 处理() {
    var ptr = 分配(100)
    defer 释放(ptr)  // 函数结束时自动执行
    
    // 无论如何返回，都会执行 defer
    如果 条件 {
        返回  // defer 仍会执行
    }
}
```

### 20.5 析构函数

```御程
// 自定义缓冲区类型
类型 缓冲区 {
    数据: 手动指针<字节>
    大小: 整数
}

// 析构函数（自动调用）
析构 func 缓冲区.释放() {
    如果 自己.数据 <> 空 {
        释放(自己.数据)
        自己.数据 = 空
    }
}

// 使用
副作用 func 主函数() {
    var buf = 缓冲区 { 数据: 分配(100), 大小: 0 }
    // 离开作用域时，析构函数自动调用
}
```

### 20.6 内存管理函数

| 函数 | 说明 | 示例 |
|------|------|------|
| `分配(大小)` | 分配内存 | `var ptr = 分配(100)` |
| `释放(指针)` | 释放内存 | `释放(ptr)` |
| `重新分配(指针, 新大小)` | 调整内存大小 | `ptr = 重新分配(ptr, 200)` |
| `复制内存(目标, 源, 大小)` | 复制内存块 | `复制内存(dst, src, 100)` |
| `清零(指针, 大小)` | 清零内存 | `清零(ptr, 100)` |
| `智能指针(值)` | 创建智能指针 | `var sp = 智能指针(数据)` |
| `引用计数(指针)` | 获取引用计数 | `var count = 引用计数(sp)` |

---

## 21. 语义检查规则

YuCheng 编译器实现了**编译期 100% 拦截非法代码**的目标，达到 C/C++ 级别的严谨性。

### 21.1 编译期检查（已实现）

以下检查在编译期执行，确保代码在运行前就是正确的：

#### 1. 未定义变量/函数检查 ✅

**规则**：所有变量和函数在使用前必须已定义。

```御程
// ❌ 错误：未定义变量
副作用 func 测试() {
    var x = 未定义变量  // 编译错误：未定义的变量 '未定义变量'
}

// ❌ 错误：未定义函数
副作用 func 测试() {
    未定义函数()  // 编译错误：未定义的函数 '未定义函数'
}

// ✅ 正确：先定义后使用
副作用 func 测试() {
    var x = 10
    var y = x  // 正确：x 已定义
}
```

#### 2. 作用域检查 ✅

**规则**：变量只能在其声明的作用域及嵌套作用域内访问。

```御程
// ❌ 错误：访问超出作用域的变量
副作用 func 测试() {
    {
        var x = 10
    }
    var y = x  // 编译错误：未定义的变量 'x'（x 在作用域外）
}

// ✅ 正确：嵌套作用域可以访问外层变量
副作用 func 测试() {
    var x = 10
    {
        var y = x  // 正确：可以访问外层变量
    }
}

// ✅ 正确：变量遮蔽
副作用 func 测试() {
    var x = 10
    {
        var x = 20  // 正确：内层作用域遮蔽外层变量
    }
}
```

#### 3. 常量修改检查 ✅

**规则**：使用 `const` 声明的常量不能被修改。

```御程
// ❌ 错误：修改常量
副作用 func 测试() {
    const PI = 3.14
    PI = 3.0  // 编译错误：不能修改常量 'PI'
}

// ✅ 正确：修改变量
副作用 func 测试() {
    var x = 10
    x = 20  // 正确：变量可以修改
}
```

#### 4. 函数分类约束检查 ✅

**规则**：函数调用必须遵守分类约束。

| 调用者类型 | 可调用类型 | 说明 |
|-----------|-----------|------|
| 纯函数 | 纯函数 | 只能调用纯函数 |
| 查询函数 | 纯函数、查询函数 | 不能调用副作用函数 |
| 副作用函数 | 任何函数 | 无限制 |

```御程
// ❌ 错误：纯函数调用副作用函数
副作用 func 写入(x: 整数) {}

纯函数 func 计算(a: 整数) -> 整数 {
    写入(a)  // 编译错误：纯函数 '计算' 不能调用副作用函数 '写入'
    返回 a
}

// ❌ 错误：查询函数调用副作用函数
副作用 func 写入() {}

查询 func 读取() -> 整数 {
    写入()  // 编译错误：查询函数 '读取' 不能调用副作用函数 '写入'
    返回 42
}

// ✅ 正确：纯函数调用纯函数
纯函数 func 加法(a: 整数, b: 整数) -> 整数 {
    返回 a + b
}

纯函数 func 计算(x: 整数) -> 整数 {
    返回 加法(x, 10)  // 正确：纯函数可以调用纯函数
}

// ✅ 正确：查询函数调用纯函数
纯函数 func 加法(a: 整数, b: 整数) -> 整数 {
    返回 a + b
}

查询 func 计算(x: 整数) -> 整数 {
    返回 加法(x, 10)  // 正确：查询函数可以调用纯函数
}

// ✅ 正确：副作用函数调用任何函数
纯函数 func 加法(a: 整数) -> 整数 { 返回 a }
查询 func 读取() -> 整数 { 返回 42 }

副作用 func 处理() {
    var x = 加法(1)  // 正确
    var y = 读取()   // 正确
}
```

#### 5. 循环控制检查 ✅

**规则**：`中断` 和 `继续` 只能在循环内使用。

```御程
// ❌ 错误：在循环外使用 break
副作用 func 测试() {
    中断  // 编译错误：break/continue 只能在循环内使用
}

// ❌ 错误：在循环外使用 continue
副作用 func 测试() {
    继续  // 编译错误：break/continue 只能在循环内使用
}

// ✅ 正确：在循环内使用 break
副作用 func 测试() {
    循环 i 在 0..10 {
        如果 i == 5 {
            中断  // 正确
        }
    }
}

// ✅ 正确：在循环内使用 continue
副作用 func 测试() {
    循环 i 在 0..10 {
        如果 i == 5 {
            继续  // 正确
        }
    }
}
```

#### 6. 重复声明检查 ✅

**规则**：同一作用域内不能重复声明变量或函数。

```御程
// ❌ 错误：同一作用域内重复声明变量
副作用 func 测试() {
    var x = 10
    var x = 20  // 编译错误：变量 'x' 在当前作用域内重复声明
}

// ❌ 错误：重复定义函数
纯函数 func 加法(a: 整数) -> 整数 { 返回 a }
纯函数 func 加法(b: 整数) -> 整数 { 返回 b }  // 编译错误：函数 '加法' 重复定义

// ✅ 正确：嵌套作用域内的变量遮蔽
副作用 func 测试() {
    var x = 10
    {
        var x = 20  // 正确：内层作用域可以遮蔽外层变量
    }
}
```

#### 7. 返回值检查 ✅

**规则**：有返回类型的函数必须返回值。

```御程
// ❌ 错误：需要返回值但未返回
纯函数 func 计算() -> 整数 {
    返回  // 编译错误：函数 '计算' 需要返回值
}

// ✅ 正确：返回正确的值
纯函数 func 计算() -> 整数 {
    返回 42  // 正确
}
```

#### 8. 类型检查系统 ✅

**规则**：御程语言**禁止隐式类型转换**，所有类型必须精确匹配。

##### 8.1 禁止隐式类型转换 ✅

```御程
// ❌ 错误：整数到小数的隐式转换
纯函数 func 测试(x: 小数) -> 小数 { 返回 x }
副作用 func 主函数() {
    var a: 整数 = 5
    var b = 测试(a)  // 编译错误：类型不匹配，期望 小数，但得到 整数
}

// ✅ 正确：显式转换
纯函数 func 转小数(x: 整数) -> 小数 { 返回 3.14 }
纯函数 func 测试(x: 小数) -> 小数 { 返回 x }
副作用 func 主函数() {
    var a: 整数 = 5
    var b = 测试(转小数(a))  // 正确：显式转换
}
```

##### 8.2 参数类型检查 ✅

```御程
// ❌ 错误：参数数量不匹配
纯函数 func 加法(a: 整数, b: 整数) -> 整数 { 返回 a + b }
副作用 func 主函数() {
    var x = 加法(1)  // 编译错误：参数数量不匹配，期望 2 个，但得到 1 个
}

// ❌ 错误：参数类型不匹配
纯函数 func 加法(a: 整数, b: 整数) -> 整数 { 返回 a + b }
副作用 func 主函数() {
    var x: 文本 = "hello"
    var y = 加法(x, 2)  // 编译错误：参数 1 (a) 类型不匹配
}

// ✅ 正确：参数类型匹配
纯函数 func 加法(a: 整数, b: 整数) -> 整数 { 返回 a + b }
副作用 func 主函数() {
    var x: 整数 = 1
    var y: 整数 = 2
    var z = 加法(x, y)  // 正确
}
```

##### 8.3 返回类型检查 ✅

```御程
// ❌ 错误：返回类型不匹配
纯函数 func 获取数字() -> 整数 {
    返回 "不是整数"  // 编译错误：类型不匹配，期望 整数，但得到 文本
}

// ✅ 正确：返回类型匹配
纯函数 func 获取数字() -> 整数 {
    返回 42  // 正确
}
```

##### 8.4 赋值类型检查 ✅

```御程
// ❌ 错误：赋值类型不匹配
副作用 func 测试() {
    var x: 整数 = 0
    x = "字符串"  // 编译错误：类型不匹配
}

// ✅ 正确：赋值相同类型
副作用 func 测试() {
    var x: 整数 = 0
    x = 42  // 正确
}
```

##### 8.5 二元运算类型检查 ✅

```御程
// ❌ 错误：整数和字符串相加
副作用 func 测试() {
    var x: 整数 = 5
    var y: 文本 = "hello"
    var z = x + y  // 编译错误：类型不匹配
}

// ✅ 正确：相同类型运算
副作用 func 测试() {
    var x: 整数 = 5
    var y: 整数 = 10
    var z = x + y  // 正确
}
```

#### 9. 控制流分析系统 ✅

**规则**：有返回类型的函数必须确保所有代码路径都有返回值。

##### 9.1 缺少返回值检查 ✅

```御程
// ❌ 错误：缺少返回值
纯函数 func 计算() -> 整数 {
    var x = 10  // 编译错误：函数 '计算' 的某些代码路径缺少返回值
}

// ❌ 错误：if 中缺少返回值
纯函数 func 计算(x: 整数) -> 整数 {
    如果 x > 0 {
        返回 x
    }
    // 编译错误：缺少返回值（else 分支没有返回）
}

// ✅ 正确：所有分支都返回
纯函数 func 计算(x: 整数) -> 整数 {
    如果 x > 0 {
        返回 x
    } 否则 {
        返回 0
    }
}
```

##### 9.2 if-else 分支完整性检查 ✅

```御程
// ❌ 错误：缺少 else 分支
纯函数 func 绝对值(x: 整数) -> 整数 {
    如果 x >= 0 {
        返回 x
    }
    // 编译错误：缺少返回值
}

// ✅ 正确：if-else 都返回
纯函数 func 绝对值(x: 整数) -> 整数 {
    如果 x >= 0 {
        返回 x
    } 否则 {
        返回 -x
    }
}
```

##### 9.3 嵌套 if 检查 ✅

```御程
// ❌ 错误：嵌套 if 缺少返回
纯函数 func 测试(x: 整数, y: 整数) -> 整数 {
    如果 x > 0 {
        如果 y > 0 {
            返回 1
        }
    }
    // 编译错误：缺少返回值
}

// ✅ 正确：嵌套 if 都返回
纯函数 func 测试(x: 整数, y: 整数) -> 整数 {
    如果 x > 0 {
        如果 y > 0 {
            返回 1
        } 否则 {
            返回 2
        }
    } 否则 {
        返回 3
    }
}
```

##### 9.4 循环中的返回 ✅

```御程
// ❌ 错误：只在循环中返回
纯函数 func 测试() -> 整数 {
    循环 i 在 0..10 {
        返回 i
    }
    // 编译错误：循环不保证执行，缺少返回值
}

// ✅ 正确：循环后返回
纯函数 func 测试() -> 整数 {
    循环 i 在 0..10 {
        var x = i
    }
    返回 0  // 正确
}
```

##### 9.5 提前返回 ✅

```御程
// ✅ 正确：提前返回
纯函数 func 测试(x: 整数) -> 整数 {
    如果 x < 0 {
        返回 0  // 提前返回
    }
    返回 x  // 正常返回
}

// ✅ 正确：多个提前返回
纯函数 func 测试(x: 整数) -> 整数 {
    如果 x < 0 {
        返回 0
    }
    如果 x == 0 {
        返回 1
    }
    返回 x
}
```

#### 10. 支持的基本类型 ✅

| 类型 | 中文名 | 英文名 | 说明 |
|------|--------|--------|------|
| 整数 | 整数 | int | 64位整数 |
| 小数 | 小数 | float | 64位浮点数 |
| 文本 | 文本 | string | UTF-8字符串 |
| 布尔 | 布尔 | bool | true/false |
| 空 | 空 | void/null | 空值 |

**类型名称支持中英双语**：
```御程
// 中文类型名
纯函数 func 加法(a: 整数, b: 整数) -> 整数 { 返回 a + b }

// 英文类型名
纯函数 func add(a: int, b: int) -> int { 返回 a + b }

// 混合使用
纯函数 func 测试(x: int) -> 整数 { 返回 x }
```

### 21.2 编译期检查（待实现）

以下检查计划在后续版本中实现：

#### 高级类型系统 (部分已实现 v0.4.0)
- ✅ **可选类型检查** - 已实现
  - T 可以赋值给 T?
  - T? 不能隐式转换为 T
  - 支持嵌套可选类型 T??
  
- ✅ **泛型类型检查** - 已实现
  - 列表<T> 类型参数检查
  - 映射<K,V> 类型参数检查
  - Result<T,E> 类型参数检查
  - 类型参数数量验证
  - 嵌套泛型类型支持
  
- ✅ **函数类型检查** - 已实现
  - func(T) -> R 类型声明
  - 多参数函数类型
  
- ❌ **泛型约束检查** - 待实现
  - 类型参数约束 (T: 可比较)
  - 完整的泛型实例化
  
- ✅ **类型别名** - 已实现
  - 类型别名注册和解析已实现（`register_type_alias`）
  - 类型别名检查已实现（`check_type_alias`）
  - 类型别名在类型解析中的使用已实现

#### 高级控制流
- ❌ **死代码检测**
- ❌ **未使用变量警告**
- ❌ **无限循环检测**
  纯函数 func 计算(x: 整数) -> 整数 {
      返回 加法(x, 10)  // ✅ 正确
  }
  ```

#### 作用域检查
- ❌ **不能访问作用域外的变量**
  ```御程
  func main() {
      {
          var x = 1
      }
      var y = x  // ❌ 编译错误：x 在作用域外
  }
  ```

#### 常量检查
- ❌ **不能修改常量**
  ```御程
  func main() {
      const PI = 3.14159
      PI = 3.14  // ❌ 编译错误：不能修改常量
  }
  ```

#### 未定义检查
- ❌ **不能使用未定义的变量**
  ```御程
  func main() {
      var x = 未定义的变量  // ❌ 编译错误：未定义变量
  }
  ```

- ❌ **不能调用未定义的函数**
  ```御程
  func main() {
      var x = 未定义的函数()  // ❌ 编译错误：未定义函数
  }
  ```

#### 参数检查
- ❌ **参数数量必须匹配**
  ```御程
  func add(a: 整数, b: 整数) -> 整数 { 返回 a + b }
  
  func main() {
      var x = add(1)  // ❌ 编译错误：参数数量不匹配
      var y = add(1, 2, 3)  // ❌ 编译错误：参数数量过多
  }
  ```

#### 控制流检查
- ❌ **中断/继续必须在循环内**
  ```御程
  func main() {
      中断  // ❌ 编译错误：中断必须在循环内
      继续  // ❌ 编译错误：继续必须在循环内
  }
  ```

### 21.3 运行时检查

以下检查在运行时执行：

#### 数组边界检查
- ❌ **负数索引**
  ```御程
  var arr = [1, 2, 3]
  var x = arr[-1]  // ❌ 运行时错误：负数索引
  ```

- ❌ **越界访问**
  ```御程
  var arr = [1, 2, 3]
  var x = arr[10]  // ❌ 运行时错误：数组越界
  ```

#### 除零检查
- ❌ **除数为零**
  ```御程
  var x = 10 / 0  // ❌ 运行时错误：除数为零
  ```

#### 契约检查
- ❌ **违反前置条件**
  ```御程
  纯函数 func 平方根(x: 小数) -> 小数
      要求 x >= 0.0
  {
      返回 内置_平方根(x)
  }
  
  var r = 平方根(-1.0)  // ❌ 运行时错误：违反前置条件
  ```

#### 空指针检查
- ❌ **解引用空指针**
  ```御程
  var ptr: 手动指针<整数> = 空
  var x = *ptr  // ❌ 运行时错误：空指针解引用
  ```

### 21.4 内存安全检查

#### 释放后使用
- ❌ **访问已释放的指针**
  ```御程
  var ptr = 分配(100)
  释放(ptr)
  var x = *ptr  // ❌ 编译错误：释放后使用
  ```

#### 重复释放
- ❌ **同一指针释放两次**
  ```御程
  var ptr = 分配(100)
  释放(ptr)
  释放(ptr)  // ❌ 编译错误：重复释放
  ```

#### 未释放检查
- ⚠️ **手动指针未释放**
  ```御程
  func leak() {
      var ptr = 分配(100)
      // ⚠️ 警告：ptr 未释放
  }
  ```

### 21.4 并发安全检查

#### 数据竞争检测
- ⚠️ **并行修改共享状态**
  ```御程
  var 共享计数 = 0
  
  并行 {
      任务 => 共享计数 += 1  // ⚠️ 警告：潜在数据竞争
      任务 => 共享计数 += 1
  }
  ```

#### 协程泄漏检测
- ⚠️ **未管理的后台任务**
  ```御程
  启动 => 后台任务()  // ⚠️ 警告：协程泄漏风险
  ```

### 21.5 错误处理检查

#### 错误忽略检测
- ⚠️ **Result类型未处理**
  ```御程
  读取文件("config.json")  // ⚠️ 警告：Result未处理
  ```

#### 恐慌检测
- ⚠️ **可能恐慌的操作**
  ```御程
  var x = 解包(结果)  // ⚠️ 警告：失败时会恐慌
  ```

---

## 22. 标准库函数

### 22.1 输入输出函数

```御程
// 打印到控制台（自动换行）
打印("Hello, World!")
打印("CPU使用率: " + 转文本(使用率) + "%")

// 输出到控制台（不换行）
输出("结果: ")
输出(值)

// 读取输入
变量 输入 = 读取输入()
变量 提示输入 = 读取输入("请输入: ")
```

### 22.2 类型转换函数

```御程
// 转换为文本
变量 文本 = 转文本(123)        // "123"
变量 文本2 = 转文本(3.14)       // "3.14"

// 转换为整数
变量 整数 = 转整数("123")      // 123
变量 整数2 = 转整数(3.14)       // 3

// 转换为小数
变量 小数 = 转小数("3.14")      // 3.14
变量 小数2 = 转小数(123)        // 123.0

// 转换为布尔
变量 布尔 = 转布尔("true")      // 真
变量 布尔2 = 转布尔(1)          // 真
```

### 22.3 类型查询函数

```御程
// 获取值的类型
变量 类型 = 获取类型(值)        // 返回类型名称字符串

// 类型检查
如果 是整数(值) { ... }
如果 是小数(值) { ... }
如果 是文本(值) { ... }
如果 是布尔(值) { ... }
如果 是列表(值) { ... }
如果 是字典(值) { ... }
```

---

## 23. 语言特性完整性对比

### 23.1 与其他主流语言对比

| 特性 | YuCheng | Python | JavaScript | Rust | Go | Java | C++ |
|------|---------|--------|------------|------|-----|------|-----|
| **基础语法** |
| 变量声明 | ✅ `变量`/`var` | ✅ `var` | ✅ `let`/`const` | ✅ `let`/`mut` | ✅ `var` | ✅ 类型声明 | ✅ 类型声明 |
| 类型推断 | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ |
| 可选分号 | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ |
| 中英文双语 | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **类型系统** |
| 静态类型 | ✅ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ |
| 类型检查 | ✅ 严格 | ❌ | ❌ | ✅ 严格 | ✅ | ✅ | ✅ |
| 泛型 | ✅ | ✅ (3.9+) | ❌ | ✅ | ✅ (1.18+) | ✅ | ✅ |
| 可选类型 | ✅ `T?` | ✅ | ❌ | ✅ `Option<T>` | ❌ | ❌ | ❌ |
| Result类型 | ✅ | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ |
| 类型别名 | ✅ | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ |
| **控制流** |
| if-else | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| switch/match | ✅ `匹配` | ❌ | ✅ `switch` | ✅ `match` | ✅ `switch` | ✅ `switch` | ✅ `switch` |
| for循环 | ✅ `循环` | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| while循环 | ✅ `当` | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 模式匹配 | ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ (C++17) |
| **函数** |
| 函数定义 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 高阶函数 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 闭包 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ (C++11) |
| 函数重载 | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| 默认参数 | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ✅ |
| **错误处理** |
| try-catch | ✅ `尝试-捕获` | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| Result类型 | ✅ | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ |
| Option类型 | ✅ | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ |
| 错误传播 | ✅ `?` | ❌ | ❌ | ✅ `?` | ❌ | ❌ | ❌ |
| **内存管理** |
| 自动管理 | ✅ 默认 | ✅ | ✅ | ❌ | ✅ | ✅ | ❌ |
| 手动管理 | ✅ `手动指针` | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |
| 智能指针 | ✅ | ❌ | ❌ | ✅ | ❌ | ❌ | ✅ |
| 引用计数 | ✅ | ✅ | ❌ | ✅ `Rc` | ❌ | ❌ | ❌ |
| 垃圾回收 | ✅ (可选) | ✅ | ✅ | ❌ | ✅ | ✅ | ❌ |
| **并发** |
| 协程/异步 | ✅ `异步` | ✅ `async/await` | ✅ `async/await` | ✅ `async/await` | ✅ `goroutine` | ❌ | ❌ (C++20) |
| 通道 | ✅ | ❌ | ❌ | ✅ | ✅ | ❌ | ❌ |
| 线程 | ✅ | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ |
| 互斥锁 | ✅ | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ |
| **面向对象** |
| 类 | ✅ | ✅ | ✅ (ES6) | ❌ | ❌ | ✅ | ✅ |
| 继承 | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| 接口 | ✅ | ❌ | ❌ | ✅ `trait` | ✅ | ✅ | ❌ |
| 多态 | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ | ✅ |
| **元编程** |
| 宏系统 | ✅ | ❌ | ❌ | ✅ | ❌ | ❌ | ✅ |
| 反射 | ✅ | ✅ | ✅ | ❌ | ✅ | ✅ | ❌ |
| 代码生成 | ✅ | ❌ | ❌ | ✅ | ❌ | ❌ | ✅ |
| **特殊特性** |
| 函数分类 | ✅ `纯函数/查询/副作用` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| 契约编程 | ✅ `要求/保证` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| 模块系统 | ✅ `.yc/.yci/.ycl` | ✅ | ✅ (ES6) | ✅ | ✅ | ✅ | ❌ |
| 单文件模式 | ✅ `.ycs` | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |

### 23.2 YuCheng 独特优势

1. **中英文双语支持** - 唯一支持中英文关键字混用的现代语言
2. **函数分类系统** - 编译期强制区分纯函数、查询函数、副作用函数
3. **契约编程** - 内置前置条件和后置条件支持
4. **混合内存管理** - 同时支持自动管理和手动管理
5. **单文件模式** - 适合教学和快速原型开发
6. **严格的类型系统** - 禁止隐式类型转换，编译期100%类型安全

### 23.3 待实现特性

以下特性计划在后续版本中实现：

- [ ] 泛型约束（`T: 可比较`）
- [ ] 完整的 trait 系统
- [ ] 宏系统增强
- [ ] 包管理系统
- [ ] 增量编译
- [ ] 热重载
- [ ] 调试器集成
- [ ] IDE 插件支持

---

*最后更新: 2026-01-18*
