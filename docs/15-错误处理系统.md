# YuCheng 语言 - 错误处理系统

> **实现状态**: ✅ 完整实现 (2026-02-08)
> - ✅ Result类型完整实现（标准库）
> - ✅ 错误传播机制（?操作符语法糖）
> - ✅ 友好错误提示（`friendly_errors.rs`）
> - ✅ 错误链追踪
> - ✅ AST支持（TryExpr节点）
> - ✅ 解释器支持（自动错误传播）
> 
> **示例代码**: `examples/29-error-propagation.ycs`

## 1. 设计理念

YuCheng 的错误处理系统基于以下原则：

- **显式优于隐式**：错误必须被显式处理，不能被忽略
- **契约驱动**：契约违反是编译期/运行期错误的主要来源
- **类型安全**：使用 `结果<T, E>` 类型而非异常
- **零成本抽象**：错误处理不应有运行时开销

---

## 2. 错误类型层次

### 2.1 内置错误类型

```御程
// 错误基类
类型 错误 {
    消息: 文本
    位置: 源码位置?
    原因: 错误?
}

// 具体错误类型
类型 契约错误 继承 错误 {
    契约类型: 文本      // "要求" 或 "保证"
    表达式: 文本        // 失败的契约表达式
}

类型 类型错误 继承 错误 {
    期望类型: 文本
    实际类型: 文本
}

类型 空指针错误 继承 错误 {
    指针名: 文本
}

类型 越界错误 继承 错误 {
    索引: 整数
    长度: 整数
}

类型 IO错误 继承 错误 {
    操作: 文本          // "读取" / "写入" / "打开"
    路径: 文本?
}

类型 网络错误 继承 错误 {
    状态码: 整数?
    地址: 文本
}
```

### 2.2 错误层次图

```
错误
├── 契约错误
│   ├── 前置条件失败
│   └── 后置条件失败
├── 类型错误
│   ├── 类型不匹配
│   └── 转换失败
├── 内存错误
│   ├── 空指针错误
│   ├── 越界错误
│   └── 内存泄漏错误
├── IO错误
│   ├── 文件不存在
│   ├── 权限不足
│   └── 磁盘已满
└── 网络错误
    ├── 连接超时
    ├── 连接拒绝
    └── HTTP错误
```

---

## 3. 结果类型

### 3.1 定义

```御程
// 结果类型：成功或失败（通过标准库函数实现）
// Result<T, E> 是一个映射类型，包含：
// - { 类型: "成功", 值: T }
// - { 类型: "失败", 错误: E }

// 创建Result
var 成功结果 = 成功(42)        // 标准库函数
var 失败结果 = 失败("错误")    // 标准库函数
}

// 可选类型：有值或无值
类型 可选<T> {
    有(值: T)
    无
}
```

### 3.2 使用示例

```御程
// 返回结果类型的函数
查询 func 读取文件(路径: 文本) -> 结果<文本, IO错误>

副作用 func 处理文件(路径: 文本) {
    var 内容 = 读取文件(路径)
    
    // 使用if-else检查Result
    如果 是成功(内容) {
        var 文本 = 解包(内容)
        控制台 => "文件内容: ", 文本
    } 否则 {
        控制台 => "读取失败"
    }
}
```

### 3.3 链式处理

```御程
// 使用 ? 操作符传播错误
副作用 func 处理配置() -> 结果<配置, 错误> {
    var 内容 = 读取文件("config.json")?  // 失败时自动返回
    var 配置 = JSON解析(内容)?            // 失败时自动返回
    返回 成功(配置)
}

// 使用 map 转换成功值
var 长度 = 读取文件("data.txt")
    .map(内容 => 内容.长度)
    
// 使用 map_err 转换错误
var 结果 = 读取文件("data.txt")
    .map_err(e => 自定义错误("读取失败: " + e.消息))

// 使用 unwrap_or 提供默认值
var 内容 = 读取文件("config.json").unwrap_or("{}")

// 使用 and_then 链式操作
var 配置 = 读取文件("config.json")
    .and_then(内容 => JSON解析(内容))
    .and_then(json => 验证配置(json))
```

---

## 4. 契约错误处理

### 4.1 前置条件违反

```御程
纯函数 func 平方根(x: 小数) -> 小数
    要求 x >= 0.0
{
    返回 内置_平方根(x)
}

// 调用时违反前置条件
var 结果 = 平方根(-1.0)  // 运行时错误：前置条件失败: x >= 0.0
```

### 4.2 后置条件违反

```御程
纯函数 func 绝对值(x: 整数) -> 整数
    保证 返回值 >= 0
{
    返回 x  // 如果 x < 0，后置条件失败
}
```

### 4.3 契约检查模式

```bash
# 开发模式：启用所有契约检查
yucheng build --contracts=full

# 测试模式：仅检查前置条件
yucheng build --contracts=requires

# 发布模式：关闭契约检查
yucheng build --contracts=none --release
```

### 4.4 软契约（返回结果而非崩溃）

```御程
// 使用 尝试要求 返回结果类型
纯函数 func 安全平方根(x: 小数) -> 结果<小数, 契约错误>
    尝试要求 x >= 0.0
{
    返回 成功(内置_平方根(x))
}

// 调用
var 结果 = 安全平方根(-1.0)
匹配 结果 {
    成功(值) => 控制台 => "结果: ", 值
    失败(错误) => 控制台 => "无效输入: ", 错误.表达式
}
```

---

## 5. 尝试-捕获语法

### 5.1 基本语法

```御程
尝试 {
    var 内容 = 读取文件("data.txt").unwrap()
    var 数据 = JSON解析(内容).unwrap()
    处理数据(数据)
} 捕获 IO错误 as e {
    控制台 => "IO错误: ", e.消息
} 捕获 类型错误 as e {
    控制台 => "解析错误: ", e.消息
} 捕获 错误 as e {
    控制台 => "未知错误: ", e.消息
} 最终 {
    清理资源()
}
```

### 5.2 捕获特定错误

```御程
尝试 {
    var 响应 = HTTP_GET("https://api.example.com/data").unwrap()
} 捕获 网络错误 as e 当 e.状态码 == 404 {
    控制台 => "资源不存在"
} 捕获 网络错误 as e 当 e.状态码 == 500 {
    控制台 => "服务器错误"
} 捕获 网络错误 as e {
    控制台 => "网络错误: ", e.消息
}
```

### 5.3 重新抛出

```御程
副作用 func 加载数据() -> 结果<数据, 错误> {
    尝试 {
        var 内容 = 读取文件("data.json").unwrap()
        返回 成功(JSON解析(内容).unwrap())
    } 捕获 错误 as e {
        // 包装错误并重新抛出
        返回 失败(错误 {
            消息: "加载数据失败",
            原因: e
        })
    }
}
```

---

## 6. 自定义错误类型

### 6.1 定义自定义错误

```御程
// 定义业务错误
类型 用户错误 继承 错误 {
    用户ID: 整数?
    错误码: 文本
}

// 构造函数
纯函数 func 用户不存在(id: 整数) -> 用户错误 {
    返回 用户错误 {
        消息: "用户不存在: " + 转文本(id),
        用户ID: id,
        错误码: "USER_NOT_FOUND"
    }
}

纯函数 func 密码错误() -> 用户错误 {
    返回 用户错误 {
        消息: "密码不正确",
        用户ID: 空,
        错误码: "INVALID_PASSWORD"
    }
}
```

### 6.2 使用自定义错误

```御程
副作用 func 登录(用户名: 文本, 密码: 文本) -> 结果<用户, 用户错误> {
    var 用户 = 查找用户(用户名)
    
    如果 用户 == 空 {
        返回 失败(用户不存在(0))
    }
    
    如果 !验证密码(用户, 密码) {
        返回 失败(密码错误())
    }
    
    返回 成功(用户)
}
```

---

## 7. 错误传播

### 7.1 ? 操作符

```御程
// ? 操作符自动传播错误
副作用 func 处理订单(订单ID: 整数) -> 结果<收据, 错误> {
    var 订单 = 获取订单(订单ID)?           // 失败时返回
    var 用户 = 获取用户(订单.用户ID)?       // 失败时返回
    var 支付结果 = 处理支付(订单, 用户)?    // 失败时返回
    
    返回 成功(生成收据(订单, 支付结果))
}

// 等价于
副作用 func 处理订单(订单ID: 整数) -> 结果<收据, 错误> {
    var 订单结果 = 获取订单(订单ID)
    如果 订单结果.是失败() {
        返回 订单结果.转换错误()
    }
    var 订单 = 订单结果.unwrap()
    
    // ... 后续类似
}
```

### 7.2 错误转换

```御程
// 自动转换兼容的错误类型
副作用 func 加载配置() -> 结果<配置, 应用错误> {
    // IO错误 自动转换为 应用错误
    var 内容 = 读取文件("config.json")?
    
    // 解析错误 自动转换为 应用错误
    var 配置 = JSON解析(内容)?
    
    返回 成功(配置)
}

// 手动转换
副作用 func 加载配置() -> 结果<配置, 应用错误> {
    var 内容 = 读取文件("config.json")
        .map_err(e => 应用错误 { 消息: "配置文件读取失败", 原因: e })?
    
    返回 成功(JSON解析(内容).unwrap())
}
```

---

## 8. 断言与调试

### 8.1 断言

```御程
// 开发时断言（发布版自动移除）
断言(用户 != 空, "用户不能为空")
断言(金额 > 0, "金额必须为正数")

// 始终检查的断言
断言_始终(关键条件, "关键条件必须满足")
```

### 8.2 调试输出

```御程
// 调试模式下输出
调试 => "当前状态: ", 状态变量

// 条件调试
调试_如果(详细模式) => "详细信息: ", 详细数据
```

### 8.3 不可达代码

```御程
匹配 状态 {
    "运行中" => 处理运行()
    "停止" => 处理停止()
    其他 => 不可达("无效状态: " + 状态)
}
```

---

## 9. 函数分类与错误

### 9.1 纯函数的错误处理

```御程
// 纯函数不能抛出异常，必须返回结果类型
纯函数 func 安全除法(a: 小数, b: 小数) -> 结果<小数, 文本> {
    如果 b == 0.0 {
        返回 失败("除数不能为零")
    }
    返回 成功(a / b)
}

// 或使用可选类型
纯函数 func 安全除法(a: 小数, b: 小数) -> 小数? {
    如果 b == 0.0 {
        返回 空
    }
    返回 a / b
}
```

### 9.2 查询函数的错误处理

```御程
// 查询函数可以返回结果类型
查询 func 获取用户(id: 整数) -> 结果<用户, 用户错误> {
    var 用户 = 数据库.查找(id)
    如果 用户 == 空 {
        返回 失败(用户不存在(id))
    }
    返回 成功(用户)
}
```

### 9.3 副作用函数的错误处理

```御程
// 副作用函数可以使用尝试-捕获或返回结果
副作用 func 保存文件(路径: 文本, 内容: 文本) -> 结果<空, IO错误> {
    尝试 {
        内置_写入文件(路径, 内容)
        返回 成功(空)
    } 捕获 IO错误 as e {
        返回 失败(e)
    }
}
```

---

## 10. 最佳实践

### 10.1 优先使用结果类型

```御程
// ✅ 推荐：返回结果类型
查询 func 解析整数(文本值: 文本) -> 结果<整数, 类型错误>

// ❌ 避免：使用异常
查询 func 解析整数(文本值: 文本) -> 整数  // 可能抛出异常
```

### 10.2 提供有意义的错误信息

```御程
// ✅ 推荐：详细的错误信息
返回 失败(IO错误 {
    消息: "无法打开文件 '" + 路径 + "': 权限不足",
    操作: "打开",
    路径: 路径
})

// ❌ 避免：模糊的错误信息
返回 失败(错误 { 消息: "操作失败" })
```

### 10.3 错误链

```御程
// ✅ 推荐：保留错误链
返回 失败(应用错误 {
    消息: "加载配置失败",
    原因: 原始错误  // 保留原始错误
})

// ❌ 避免：丢失原始错误
返回 失败(应用错误 { 消息: "加载配置失败" })
```

### 10.4 早期返回

```御程
// ✅ 推荐：早期返回，减少嵌套
副作用 func 处理请求(请求: 请求) -> 结果<响应, 错误> {
    var 用户 = 验证令牌(请求.令牌)?
    var 权限 = 检查权限(用户, 请求.资源)?
    var 数据 = 获取数据(请求.资源)?
    返回 成功(响应 { 数据: 数据 })
}

// ❌ 避免：深层嵌套
副作用 func 处理请求(请求: 请求) -> 结果<响应, 错误> {
    匹配 验证令牌(请求.令牌) {
        成功(用户) => {
            匹配 检查权限(用户, 请求.资源) {
                成功(权限) => {
                    // ... 更多嵌套
                }
                失败(e) => 返回 失败(e)
            }
        }
        失败(e) => 返回 失败(e)
    }
}
```

---

## 11. 与审计系统集成

错误处理与审计系统紧密集成：

```bash
$ yucheng audit --contract

⚠️  math.yci:20: 函数 '除法' 缺少对除数为零的处理
    |
 20 |     返回 a / b
    |            ^ 当 b == 0 时可能导致运行时错误
    |
    = 建议: 添加 '要求 b <> 0' 或返回 结果<小数, 错误>

❌  user.yci:15: 错误被忽略
    |
 15 |     读取文件("config.json")
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 结果类型未被处理
    |
    = 建议: 使用 ? 传播错误或显式处理
```
