# 优化器详解

## 概述

优化器模块 (`optimizer.rs`) 提供多种代码优化技术，在编译时提升程序性能。

## 架构设计

```rust
/// 优化器
pub struct Optimizer {
    /// 优化级别
    level: OptimizationLevel,
    /// 优化统计
    stats: OptimizationStats,
    /// 是否启用特定优化
    enabled_passes: HashSet<OptimizationPass>,
}

/// 优化级别
pub enum OptimizationLevel {
    None,       // O0 - 不优化
    Basic,      // O1 - 基本优化
    Standard,   // O2 - 标准优化
    Aggressive, // O3 - 激进优化
    Size,       // Os - 优化大小
}

/// 优化 Pass
pub enum OptimizationPass {
    ConstantFolding,      // 常量折叠
    DeadCodeElimination,  // 死代码消除
    CommonSubexpression,  // 公共子表达式消除
    LoopInvariantMotion,  // 循环不变量外提
    InlineExpansion,      // 内联展开
    TailCallOptimization, // 尾调用优化
    StrengthReduction,    // 强度削减
    CopyPropagation,      // 复制传播
    ConstantPropagation,  // 常量传播
    BranchSimplification, // 分支简化
}
```

## 优化统计

```rust
/// 优化统计
pub struct OptimizationStats {
    /// 常量折叠次数
    pub constants_folded: usize,
    /// 死代码消除次数
    pub dead_code_eliminated: usize,
    /// 公共子表达式消除次数
    pub cse_eliminated: usize,
    /// 内联展开次数
    pub functions_inlined: usize,
    /// 尾调用优化次数
    pub tail_calls_optimized: usize,
    /// 循环优化次数
    pub loops_optimized: usize,
}
```

## 常量折叠

在编译时计算常量表达式的值。

```rust
impl Optimizer {
    /// 常量折叠
    pub fn fold_constants(&mut self, expr: &Expr) -> Expr {
        match expr {
            Expr::BinaryOp { left, op, right, span } => {
                let left = self.fold_constants(left);
                let right = self.fold_constants(right);
                
                // 尝试在编译时计算
                if let (Expr::Integer(l, _), Expr::Integer(r, _)) = (&left, &right) {
                    let result = match op.as_str() {
                        "+" => Some(l + r),
                        "-" => Some(l - r),
                        "*" => Some(l * r),
                        "/" if *r != 0 => Some(l / r),
                        "%" if *r != 0 => Some(l % r),
                        _ => None,
                    };
                    
                    if let Some(value) = result {
                        self.stats.constants_folded += 1;
                        return Expr::Integer(value, span.clone());
                    }
                }
                
                // 浮点数常量折叠
                if let (Expr::Float(l, _), Expr::Float(r, _)) = (&left, &right) {
                    let result = match op.as_str() {
                        "+" => Some(l + r),
                        "-" => Some(l - r),
                        "*" => Some(l * r),
                        "/" if *r != 0.0 => Some(l / r),
                        _ => None,
                    };
                    
                    if let Some(value) = result {
                        self.stats.constants_folded += 1;
                        return Expr::Float(value, span.clone());
                    }
                }
                
                // 布尔常量折叠
                if let (Expr::Bool(l, _), Expr::Bool(r, _)) = (&left, &right) {
                    let result = match op.as_str() {
                        "&&" | "且" => Some(*l && *r),
                        "||" | "或" => Some(*l || *r),
                        _ => None,
                    };
                    
                    if let Some(value) = result {
                        self.stats.constants_folded += 1;
                        return Expr::Bool(value, span.clone());
                    }
                }
                
                Expr::BinaryOp {
                    left: Box::new(left),
                    op: op.clone(),
                    right: Box::new(right),
                    span: span.clone(),
                }
            }
            
            Expr::UnaryOp { op, operand, span } => {
                let operand = self.fold_constants(operand);
                
                match (&operand, op.as_str()) {
                    (Expr::Integer(n, _), "-") => {
                        self.stats.constants_folded += 1;
                        Expr::Integer(-n, span.clone())
                    }
                    (Expr::Bool(b, _), "!" | "非") => {
                        self.stats.constants_folded += 1;
                        Expr::Bool(!b, span.clone())
                    }
                    _ => Expr::UnaryOp {
                        op: op.clone(),
                        operand: Box::new(operand),
                        span: span.clone(),
                    }
                }
            }
            
            _ => expr.clone(),
        }
    }
}
```

## 死代码消除

移除永远不会执行的代码。

```rust
impl Optimizer {
    /// 死代码消除
    pub fn eliminate_dead_code(&mut self, stmts: &[Stmt]) -> Vec<Stmt> {
        let mut result = Vec::new();
        let mut reachable = true;
        
        for stmt in stmts {
            if !reachable {
                self.stats.dead_code_eliminated += 1;
                continue;
            }
            
            match stmt {
                Stmt::Return(_, _) => {
                    result.push(stmt.clone());
                    reachable = false;
                }
                
                Stmt::Break(_, _) | Stmt::Continue(_, _) => {
                    result.push(stmt.clone());
                    reachable = false;
                }
                
                Stmt::If(if_stmt) => {
                    // 检查条件是否为常量
                    if let Expr::Bool(cond, _) = &if_stmt.condition {
                        if *cond {
                            // 条件恒为真，只保留 then 分支
                            let then_stmts = self.eliminate_dead_code(&if_stmt.then_branch.statements);
                            result.extend(then_stmts);
                            self.stats.dead_code_eliminated += 1;
                        } else if let Some(else_branch) = &if_stmt.else_branch {
                            // 条件恒为假，只保留 else 分支
                            match else_branch.as_ref() {
                                ElseBranch::Else(block) => {
                                    let else_stmts = self.eliminate_dead_code(&block.statements);
                                    result.extend(else_stmts);
                                }
                                ElseBranch::ElseIf(elif) => {
                                    result.push(Stmt::If(elif.clone()));
                                }
                            }
                            self.stats.dead_code_eliminated += 1;
                        }
                    } else {
                        result.push(stmt.clone());
                    }
                }
                
                Stmt::While(while_stmt) => {
                    // 检查条件是否恒为假
                    if let Expr::Bool(false, _) = &while_stmt.condition {
                        self.stats.dead_code_eliminated += 1;
                        continue;
                    }
                    result.push(stmt.clone());
                }
                
                _ => {
                    result.push(stmt.clone());
                }
            }
        }
        
        result
    }
}
```

## 公共子表达式消除

避免重复计算相同的表达式。

```rust
impl Optimizer {
    /// 公共子表达式消除
    pub fn eliminate_common_subexpressions(&mut self, stmts: &mut [Stmt]) {
        let mut expr_cache: HashMap<String, String> = HashMap::new();
        
        for stmt in stmts {
            self.cse_stmt(stmt, &mut expr_cache);
        }
    }
    
    fn cse_stmt(&mut self, stmt: &mut Stmt, cache: &mut HashMap<String, String>) {
        match stmt {
            Stmt::VarDecl(var) => {
                if let Some(ref mut init) = var.initializer {
                    self.cse_expr(init, cache);
                    
                    // 记录表达式到变量的映射
                    let expr_key = self.expr_to_key(init);
                    cache.insert(expr_key, var.name.clone());
                }
            }
            
            Stmt::Expr(expr) => {
                self.cse_expr(expr, cache);
            }
            
            _ => {}
        }
    }
    
    fn cse_expr(&mut self, expr: &mut Expr, cache: &mut HashMap<String, String>) {
        let expr_key = self.expr_to_key(expr);
        
        // 检查是否已经计算过
        if let Some(var_name) = cache.get(&expr_key) {
            if !matches!(expr, Expr::Identifier(_, _)) {
                *expr = Expr::Identifier(var_name.clone(), expr.span().clone());
                self.stats.cse_eliminated += 1;
            }
        }
        
        // 递归处理子表达式
        match expr {
            Expr::BinaryOp { left, right, .. } => {
                self.cse_expr(left, cache);
                self.cse_expr(right, cache);
            }
            Expr::UnaryOp { operand, .. } => {
                self.cse_expr(operand, cache);
            }
            Expr::Call { args, .. } => {
                for arg in args {
                    self.cse_expr(arg, cache);
                }
            }
            _ => {}
        }
    }
    
    fn expr_to_key(&self, expr: &Expr) -> String {
        match expr {
            Expr::Integer(n, _) => format!("int:{}", n),
            Expr::Float(f, _) => format!("float:{}", f),
            Expr::Bool(b, _) => format!("bool:{}", b),
            Expr::Identifier(name, _) => format!("id:{}", name),
            Expr::BinaryOp { left, op, right, .. } => {
                format!("binop:{}:{}:{}", self.expr_to_key(left), op, self.expr_to_key(right))
            }
            Expr::UnaryOp { op, operand, .. } => {
                format!("unop:{}:{}", op, self.expr_to_key(operand))
            }
            _ => format!("other:{:?}", expr),
        }
    }
}
```

## 内联展开

将小函数的调用替换为函数体。

```rust
impl Optimizer {
    /// 内联展开
    pub fn inline_functions(&mut self, program: &mut Program) {
        // 收集可内联的函数
        let inline_candidates: HashMap<String, &Function> = program.functions.iter()
            .filter(|f| self.should_inline(f))
            .map(|f| (f.name.clone(), f))
            .collect();
        
        // 对每个函数进行内联
        for func in &mut program.functions {
            self.inline_in_function(func, &inline_candidates);
        }
    }
    
    fn should_inline(&self, func: &Function) -> bool {
        // 内联条件：
        // 1. 函数体小于阈值
        // 2. 是纯函数
        // 3. 没有递归调用
        func.body.len() <= 5 && func.kind == FunctionKind::Pure
    }
    
    fn inline_in_function(&mut self, func: &mut Function, candidates: &HashMap<String, &Function>) {
        for stmt in &mut func.body {
            self.inline_in_stmt(stmt, candidates);
        }
    }
    
    fn inline_in_stmt(&mut self, stmt: &mut Stmt, candidates: &HashMap<String, &Function>) {
        match stmt {
            Stmt::Expr(expr) => {
                self.inline_in_expr(expr, candidates);
            }
            Stmt::VarDecl(var) => {
                if let Some(ref mut init) = var.initializer {
                    self.inline_in_expr(init, candidates);
                }
            }
            Stmt::Return(Some(expr), _) => {
                self.inline_in_expr(expr, candidates);
            }
            _ => {}
        }
    }
    
    fn inline_in_expr(&mut self, expr: &mut Expr, candidates: &HashMap<String, &Function>) {
        if let Expr::Call { callee, args, span } = expr {
            if let Expr::Identifier(name, _) = callee.as_ref() {
                if let Some(target_func) = candidates.get(name) {
                    // 执行内联
                    if let Some(inlined) = self.perform_inline(target_func, args, span) {
                        *expr = inlined;
                        self.stats.functions_inlined += 1;
                    }
                }
            }
        }
    }
    
    fn perform_inline(&self, func: &Function, args: &[Expr], span: &Span) -> Option<Expr> {
        // 简单情况：函数只有一个 return 语句
        if func.body.len() == 1 {
            if let Stmt::Return(Some(ret_expr), _) = &func.body[0] {
                // 替换参数
                let mut result = ret_expr.clone();
                for (i, param) in func.params.iter().enumerate() {
                    if let Some(arg) = args.get(i) {
                        self.substitute_var(&mut result, &param.name, arg);
                    }
                }
                return Some(result);
            }
        }
        None
    }
    
    fn substitute_var(&self, expr: &mut Expr, var_name: &str, replacement: &Expr) {
        match expr {
            Expr::Identifier(name, _) if name == var_name => {
                *expr = replacement.clone();
            }
            Expr::BinaryOp { left, right, .. } => {
                self.substitute_var(left, var_name, replacement);
                self.substitute_var(right, var_name, replacement);
            }
            Expr::UnaryOp { operand, .. } => {
                self.substitute_var(operand, var_name, replacement);
            }
            _ => {}
        }
    }
}
```

## 尾调用优化

将尾递归转换为循环。

```rust
impl Optimizer {
    /// 尾调用优化
    pub fn optimize_tail_calls(&mut self, func: &mut Function) {
        if !self.is_tail_recursive(func) {
            return;
        }
        
        // 将尾递归转换为循环
        let loop_body = self.convert_to_loop(func);
        
        func.body = vec![
            Stmt::While(WhileStmt {
                condition: Expr::Bool(true, Span::dummy()),
                body: Block { statements: loop_body },
                span: Span::dummy(),
            })
        ];
        
        self.stats.tail_calls_optimized += 1;
    }
    
    fn is_tail_recursive(&self, func: &Function) -> bool {
        // 检查函数是否包含尾递归调用
        for stmt in &func.body {
            if let Stmt::Return(Some(Expr::Call { callee, .. }), _) = stmt {
                if let Expr::Identifier(name, _) = callee.as_ref() {
                    if name == &func.name {
                        return true;
                    }
                }
            }
        }
        false
    }
    
    fn convert_to_loop(&self, func: &Function) -> Vec<Stmt> {
        // 转换逻辑...
        vec![]
    }
}
```

## 强度削减

用更快的操作替换慢操作。

```rust
impl Optimizer {
    /// 强度削减
    pub fn reduce_strength(&mut self, expr: &mut Expr) {
        match expr {
            Expr::BinaryOp { left, op, right, span } => {
                // x * 2 -> x << 1
                if op == "*" {
                    if let Expr::Integer(2, _) = right.as_ref() {
                        *expr = Expr::BinaryOp {
                            left: left.clone(),
                            op: "<<".to_string(),
                            right: Box::new(Expr::Integer(1, span.clone())),
                            span: span.clone(),
                        };
                        return;
                    }
                }
                
                // x / 2 -> x >> 1
                if op == "/" {
                    if let Expr::Integer(2, _) = right.as_ref() {
                        *expr = Expr::BinaryOp {
                            left: left.clone(),
                            op: ">>".to_string(),
                            right: Box::new(Expr::Integer(1, span.clone())),
                            span: span.clone(),
                        };
                        return;
                    }
                }
                
                // x * 0 -> 0
                if op == "*" {
                    if let Expr::Integer(0, _) = right.as_ref() {
                        *expr = Expr::Integer(0, span.clone());
                        return;
                    }
                }
                
                // x + 0 -> x
                if op == "+" {
                    if let Expr::Integer(0, _) = right.as_ref() {
                        *expr = *left.clone();
                        return;
                    }
                }
                
                // x * 1 -> x
                if op == "*" {
                    if let Expr::Integer(1, _) = right.as_ref() {
                        *expr = *left.clone();
                        return;
                    }
                }
                
                // 递归处理
                self.reduce_strength(left);
                self.reduce_strength(right);
            }
            _ => {}
        }
    }
}
```

## 使用示例

```rust
fn optimize_program(program: &mut Program, level: OptimizationLevel) {
    let mut optimizer = Optimizer::new(level);
    
    // 应用优化
    optimizer.optimize(program);
    
    // 打印统计
    let stats = optimizer.stats();
    println!("优化统计:");
    println!("  常量折叠: {}", stats.constants_folded);
    println!("  死代码消除: {}", stats.dead_code_eliminated);
    println!("  公共子表达式消除: {}", stats.cse_eliminated);
    println!("  函数内联: {}", stats.functions_inlined);
    println!("  尾调用优化: {}", stats.tail_calls_optimized);
}
```
