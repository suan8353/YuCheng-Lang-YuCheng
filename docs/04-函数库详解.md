# YuCheng 语言 - 函数库详解

> **实现状态**: ✅ 完整实现
> - ✅ 基础标准库函数完整（1270行代码）
> - ✅ Lambda表达式和闭包已实现
> - ✅ 高级函数式编程特性已实现（组合、管道、柯里化、偏应用、记忆化）
> - ✅ 高阶函数完整实现

## 1. Lambda表达式和闭包

### 1.1 Lambda表达式语法

YuCheng 支持 Lambda 表达式（匿名函数），语法简洁：

```御程
// 基本语法：参数 => 表达式
变量 平方 = x => x * x
变量 结果 = 平方(5)  // 25

// 多参数Lambda
变量 加法 = (a, b) => a + b
变量 和 = 加法(3, 5)  // 8

// 无参数Lambda
变量 获取时间 = () => 当前时间戳()
变量 时间 = 获取时间()

// 多行Lambda（使用代码块）
变量 处理 = x => {
    变量 加倍 = x * 2
    返回 加倍 + 1
}
变量 结果 = 处理(5)  // 11
```

### 1.2 闭包（捕获外部变量）

Lambda 表达式可以捕获外部作用域的变量：

```御程
// 捕获外部变量
变量 倍数 = 2
变量 乘以 = x => x * 倍数  // 捕获 倍数
变量 结果 = 乘以(5)  // 10

// 修改捕获的变量
变量 计数 = 0
变量 增加 = () => {
    计数 += 1
    返回 计数
}
变量 值1 = 增加()  // 1
变量 值2 = 增加()  // 2

// 捕获多个变量
变量 a = 10
变量 b = 20
变量 计算 = x => x + a + b
变量 结果 = 计算(5)  // 35
```

### 1.3 Lambda作为函数参数

Lambda 表达式常用于高阶函数：

```御程
// 映射函数
变量 结果 = 映射([1, 2, 3], x => x * 2)  // [2, 4, 6]

// 过滤函数
变量 结果 = 过滤([1, 2, 3, 4, 5], x => x > 2)  // [3, 4, 5]

// 自定义高阶函数
纯函数 func 应用函数(值: 整数, 函数: func(整数) -> 整数) -> 整数 {
    返回 函数(值)
}
变量 结果 = 应用函数(5, x => x * 3)  // 15
```

### 1.4 函数类型

Lambda 表达式可以赋值给函数类型的变量：

```御程
// 函数类型声明
变量 计算函数: func(整数, 整数) -> 整数 = (a, b) => a + b
变量 结果 = 计算函数(3, 5)  // 8

// 函数类型作为参数
纯函数 func 执行操作(值: 整数, 操作: func(整数) -> 整数) -> 整数 {
    返回 操作(值)
}
变量 结果 = 执行操作(10, x => x * 2)  // 20

// 函数类型作为返回值
纯函数 func 创建乘法器(倍数: 整数) -> func(整数) -> 整数 {
    返回 x => x * 倍数
}
变量 乘以3 = 创建乘法器(3)
变量 结果 = 乘以3(5)  // 15
```

---

## 2. 函数分类体系

### 1.1 三域分类法（关键字声明）

| 关键字 | 英文 | 代号 | 特点 | AI处理方式 |
|--------|------|------|------|-----------|
| `纯函数` | `compute` | Pure | 无副作用，可缓存 | 可缓存、可并行 |
| `查询` | `query` | Getter | 只读，不修改状态 | 安全调用 |
| `副作用` | `effect` | Action | 可修改状态 | 需检查内存变化 |

### 1.2 编译器强制约束

| 函数类型 | 允许调用 | 禁止调用 |
|---------|---------|---------|
| `纯函数` | 其他 `纯函数` | `查询`、`副作用` |
| `查询` | `纯函数`、其他 `查询` | `副作用` |
| `副作用` | 所有类型 | 无限制 |

### 1.3 分类规则

```御程
// ✅ 正确：纯函数只做计算
纯函数 func 面积(长: 小数, 宽: 小数) -> 小数 {
    返回 长 * 宽
}

// ❌ 编译错误：纯函数不能有副作用
纯函数 func 面积(长: 小数, 宽: 小数) -> 小数 {
    打印("计算中...")  // 错误：纯函数内禁止调用副作用函数
    返回 长 * 宽
}

// ✅ 正确：副作用函数可以有副作用
副作用 func 保存用户(用户数据: 用户) {
    文件.写入(用户数据)
    日志.记录("用户已保存")
}
```

## 3. 核心函数库

### 2.1 输入输出函数 (副作用)

#### 打印

```御程
// 函数签名
副作用 func 打印(内容: 任意...)
副作用 func print(内容: 任意...)  // 英文别名

// 用法（单个参数）
打印("你好，世界")
打印("结果是：" + 转文本(计算结果))

// 多个参数需要字符串拼接
打印("姓名：" + 名字 + "，年龄：" + 转文本(年龄))

// 英文别名
print("Hello, World")
print("Result: " + to_string(result))
```

**说明**：
- `打印` 函数支持多个参数，会自动转换为文本并拼接
- 输出后自动换行
- 支持中英文函数名混用
- **注意**：如果遇到语法错误，可以使用字符串拼接方式：`打印("文本" + 转文本(值))`

#### 输出

```御程
// 函数签名
副作用 func 输出(内容: 任意...)
副作用 func output(内容: 任意...)  // 英文别名

// 用法（单个参数）
输出("结果: ")
输出(值)
输出("\n")  // 手动换行

// 多个参数需要字符串拼接
输出("CPU: " + 转文本(cpu使用率) + "%")

// 英文别名
output("Result: ")
output(value)
```

**说明**：
- `输出` 函数支持多个参数，会自动转换为文本并拼接
- 与 `打印` 不同，`输出` **不自动换行**
- 适合需要连续输出的场景
- 多个 `输出` 调用会在同一行显示
- **注意**：如果遇到语法错误，可以使用字符串拼接方式：`输出("文本" + 转文本(值))`

#### 日志函数

```御程
// 日志级别（从低到高）
副作用 func 追踪(内容: 任意...)   // [追踪] 最详细的调试信息
副作用 func 调试(内容: 任意...)   // [调试] 调试信息
副作用 func 信息(内容: 任意...)   // [信息] 一般信息（默认）
副作用 func 日志(内容: 任意...)   // [信息] 同上，别名
副作用 func 警告(内容: 任意...)   // [警告] 警告信息
副作用 func 错误日志(内容: 任意...) // [错误] 错误信息（输出到stderr）

// 用法示例
追踪("进入函数 计算总价")
调试("参数值：", 单价, 数量)
信息("开始处理订单")
日志("用户登录：", 用户名)
警告("库存不足，剩余：", 库存数量)
错误日志("数据库连接失败：", 错误信息)
```

#### 输入

```御程
// 函数签名
副作用 func 输入(提示文字: 文本) -> 文本

// 用法
var 名字 = 输入("请输入你的名字：")
var 年龄文本 = 输入("请输入你的年龄：")
var 年龄 = 转整数(年龄文本)  // 显式类型转换
```

#### 写入文件

```御程
// 函数签名
副作用 func 写入文件(路径: 文本, 内容: 文本, 模式: 文本 = "覆盖")

// 用法
写入文件("data.txt", "Hello World")
写入文件("log.txt", 日志内容, "追加")
```

#### 读取文件

```御程
// 函数签名
查询 func 读取文件(路径: 文本) -> 文本

// 用法
var 内容 = 读取文件("data.txt")
var 配置 = JSON解析(读取文件("config.json"))
```

### 2.2 数学函数 (纯函数)

```御程
// 绝对值
纯函数 func 绝对值(x: 小数) -> 小数
var 结果 = 绝对值(-5)  // 5

// 四舍五入
纯函数 func 四舍五入(x: 小数, 精度: 整数 = 0) -> 小数
var 结果 = 四舍五入(3.7)  // 4
var 结果 = 四舍五入(3.14159, 2)  // 3.14

// 最大值/最小值
纯函数 func 最大值(数值列表: 列表<小数>) -> 小数
纯函数 func 最小值(数值列表: 列表<小数>) -> 小数
var 结果 = 最大值([1, 5, 3])  // 5
var 结果 = 最小值([1, 5, 3])  // 1

// 幂运算
纯函数 func 幂(底数: 小数, 指数: 小数) -> 小数
var 结果 = 幂(2, 10)  // 1024

// 平方根（带契约）
纯函数 func 平方根(x: 小数) -> 小数
    要求 x >= 0.0
    保证 返回值 >= 0.0
var 结果 = 平方根(16)  // 4

// 随机数
副作用 func 随机整数(最小: 整数, 最大: 整数) -> 整数
副作用 func 随机小数() -> 小数
var 结果 = 随机整数(1, 100)
```

### 2.3 文本函数

```御程
// 长度
纯函数 func 文本长度(文本值: 文本) -> 整数
var 长度 = 文本长度("你好世界")  // 4

// 拼接
纯函数 func 文本拼接(文本列表: 列表<文本>) -> 文本
var 结果 = 文本拼接(["你好", "世界"])  // "你好世界"

// 截取
纯函数 func 文本截取(文本值: 文本, 起始: 整数, 长度: 整数) -> 文本
var 结果 = 文本截取("Hello World", 0, 5)  // "Hello"

// 替换
纯函数 func 文本替换(文本值: 文本, 旧值: 文本, 新值: 文本) -> 文本
var 结果 = 文本替换("Hello World", "World", "YuCheng")

// 分割
纯函数 func 文本分割(文本值: 文本, 分隔符: 文本) -> 列表<文本>
var 结果 = 文本分割("a,b,c", ",")  // ["a", "b", "c"]

// 查找
查询 func 文本位置(文本值: 文本, 搜索值: 文本) -> 整数  ✅ (P-1阶段)
查询 func 文本包含(文本值: 文本, 搜索值: 文本) -> 布尔
var 位置 = 文本位置("Hello World", "World")  // 6
var 包含 = 文本包含("Hello World", "World")  // 真
```

### 2.4 列表函数

```御程
// 排序
纯函数 func 排序<T>(列表值: 列表<T>) -> 列表<T>  ✅ (P-1阶段)
var 结果 = 排序([3, 1, 4, 1, 5])  // [1, 1, 3, 4, 5]

// 反转
纯函数 func 反转<T>(列表值: 列表<T>) -> 列表<T>
var 结果 = 反转([1, 2, 3])  // [3, 2, 1]

// 去重
纯函数 func 去重<T>(列表值: 列表<T>) -> 列表<T>  ✅ (P-1阶段)
var 结果 = 去重([1, 2, 2, 3, 3, 3])  // [1, 2, 3]

// 映射
纯函数 func 映射<T, R>(列表值: 列表<T>, 转换: (T) -> R) -> 列表<R>  ✅ (P-1阶段，简化实现)
var 结果 = 映射([1, 2, 3], x => x * 2)  // [2, 4, 6]

// 过滤
纯函数 func 过滤<T>(列表值: 列表<T>, 条件: (T) -> 布尔) -> 列表<T>  ✅ (P-1阶段，简化实现)
var 结果 = 过滤([1, 2, 3, 4, 5], x => x > 2)  // [3, 4, 5]

// 长度
查询 func 列表长度<T>(列表值: 列表<T>) -> 整数
var 长度 = 列表长度([1, 2, 3])  // 3

// 添加/删除
副作用 func 列表添加<T>(列表值: 列表<T>, 元素: T)
副作用 func 列表删除<T>(列表值: 列表<T>, 索引: 整数)
```

### 2.5 时间函数 ✅ 已实现 (P-1阶段)

```御程
// 当前时间
查询 func 当前时间戳() -> 整数
查询 func 当前时间() -> 时间  ✅
查询 func 当前日期() -> 文本  // "2026-01-10"  ✅

// 格式化
纯函数 func 时间格式化(时间戳: 整数, 格式: 文本) -> 文本  ✅
var 文本 = 时间格式化(时间戳, "YYYY-MM-DD HH:mm:ss")

// 时间计算
纯函数 func 时间加(时间戳: 整数, 数量: 整数, 单位: 文本) -> 整数  ✅
纯函数 func 时间差(时间1: 整数, 时间2: 整数, 单位: 文本) -> 整数  ✅
var 新时间 = 时间加(时间戳, 7, "天")
var 差值 = 时间差(时间1, 时间2, "小时")
```

### 2.6 JSON 函数 ✅ 已实现 (P-1阶段)

```御程
// 序列化
纯函数 func JSON序列化(对象: 任意, 缩进: 整数 = 0) -> 文本  ✅
var json文本 = JSON序列化(对象)
var json文本 = JSON序列化(对象, 2)

// 解析
纯函数 func JSON解析(json文本: 文本) -> 任意  ✅
var 对象 = JSON解析(json文本)

// 路径查询
查询 func JSON路径(对象: 任意, 路径: 文本) -> 任意  ✅
var 值 = JSON路径(对象, "user.name")
```

### 2.7 网络函数 (副作用) ✅ 已实现 (P-1阶段)

```御程
// GET 请求
副作用 func HTTP_GET(地址: 文本) -> 文本
副作用 func HTTP_GET(地址: 文本, 请求头: 字典) -> 文本
副作用 func http_get(地址: 文本) -> 文本  // 英文别名
var 响应 = HTTP_GET("https://api.example.com/data")
var 响应 = HTTP_GET("https://api.example.com/data", {"Authorization": "Bearer token"})

// POST 请求
副作用 func HTTP_POST(地址: 文本, 数据: 任意) -> 文本  ✅
副作用 func http_post(地址: 文本, 数据: 任意) -> 文本  // 英文别名
var 响应 = HTTP_POST("https://api.example.com/data", {"key": "value"})

// 下载文件
副作用 func 下载文件(地址: 文本, 保存路径: 文本)  ✅
副作用 func download_file(地址: 文本, 保存路径: 文本)  // 英文别名
下载文件("https://example.com/file.zip", "./file.zip")
```

## 4. 内存管理函数

```御程
// 申请内存（作用域绑定，自动释放）
var 数据指针 = 申请(整数, 100)  // 申请100个整数的空间

// 显式延长生命周期
var p = 持有(数据指针)  // 延长生命周期
// ... 使用 p ...
释放(p)  // 必须手动释放

// 查询
查询 func 内存大小(指针: 指针<任意>) -> 整数
查询 func 指针状态(指针: 指针<任意>) -> 文本  // "有效"/"悬垂"/"空"/"未初始化"

var 大小 = 内存大小(指针)
var 状态 = 指针状态(指针)

// 内存快照
查询 func 内存快照() -> 内存报告
var 快照 = 内存快照()
```

## 5. 图表更新函数 (副作用)

```御程
// 更新内存图表
副作用 func 更新图表(类型: 文本, 数据: 任意)
更新图表("折线图", 内存占用历史)
更新图表("柱状图", 变量大小列表)
更新图表("堆栈图", 内存快照())
```

## 6. 类型转换函数 (纯函数)

```御程
// 显式类型转换（禁止隐式转换）
纯函数 func 转整数(值: 任意) -> 整数
纯函数 func 转小数(值: 任意) -> 小数
纯函数 func 转文本(值: 任意) -> 文本
纯函数 func 转布尔(值: 任意) -> 布尔

// 用法（必须显式转换）
var a: 整数 = 5
var b: 小数 = 转小数(a)  // 必须显式转换

var 结果 = 转整数("123")  // 123
var 结果 = 转整数(3.7)    // 3（截断）
var 结果 = 转小数("3.14") // 3.14
var 结果 = 转文本(123)    // "123"
var 结果 = 转布尔(1)      // 真
var 结果 = 转布尔(0)      // 假

// 安全转换（返回可选类型）
纯函数 func 尝试_转整数(文本值: 文本) -> 整数?
纯函数 func 尝试_转小数(文本值: 文本) -> 小数?

var 结果 = 尝试_转整数("abc")  // 返回 空

// 类型检查
查询 func 获取类型(值: 任意) -> 文本  // "整数"/"小数"/"文本"/"布尔"/"列表"/"映射"/"空"
查询 func type_of(值: 任意) -> 文本  // 英文别名
变量 类型名 = 获取类型(变量)

// 类型判断函数 ✅ 已实现
查询 func 是整数(值: 任意) -> 布尔
查询 func is_int(值: 任意) -> 布尔  // 英文别名
查询 func 是小数(值: 任意) -> 布尔
查询 func is_float(值: 任意) -> 布尔  // 英文别名
查询 func 是文本(值: 任意) -> 布尔
查询 func is_string(值: 任意) -> 布尔  // 英文别名
查询 func 是布尔(值: 任意) -> 布尔
查询 func is_bool(值: 任意) -> 布尔  // 英文别名
查询 func 是列表(值: 任意) -> 布尔
查询 func is_list(值: 任意) -> 布尔  // 英文别名
查询 func 是字典(值: 任意) -> 布尔
查询 func 是映射(值: 任意) -> 布尔  // 别名
查询 func is_map(值: 任意) -> 布尔  // 英文别名
查询 func is_dict(值: 任意) -> 布尔  // 英文别名

// 用法示例
如果 是整数(值) {
    打印("这是一个整数")
} 否则如果 是列表(值) {
    打印("这是一个列表")
} 否则如果 是字典(值) {
    打印("这是一个字典/映射")
}

// 空值检查
查询 func 是空(值: 任意) -> 布尔
查询 func is_null(值: 任意) -> 布尔  // 英文别名
如果 是空(值) {
    打印("值为空")
}
```

## 7. 系统函数

```御程
// 环境变量
查询 func 环境变量(名称: 文本) -> 文本?
查询 func env_var(名称: 文本) -> 文本?  // 英文别名
var 值 = 环境变量("PATH")

// 系统信息
查询 func 获取操作系统() -> 文本  // "Windows"/"Linux"/"macOS"
查询 func get_os() -> 文本
查询 func 获取架构() -> 文本  // "x86_64"/"aarch64"/...
查询 func get_arch() -> 文本
查询 func 获取主机名() -> 文本
查询 func get_hostname() -> 文本
查询 func 获取用户名() -> 文本
查询 func get_username() -> 文本
查询 func 获取主目录() -> 文本
查询 func get_home() -> 文本
查询 func 获取临时目录() -> 文本
查询 func get_temp_dir() -> 文本

// 进程信息
查询 func 获取进程ID() -> 整数
查询 func get_pid() -> 整数
查询 func 获取命令行参数() -> 列表<文本>
查询 func get_args() -> 列表<文本>
查询 func 获取当前目录() -> 文本
查询 func get_cwd() -> 文本

// 执行命令
副作用 func 执行命令(命令: 文本) -> 文本
副作用 func exec_command(命令: 文本) -> 文本
var 结果 = 执行命令("dir")

// 延时
副作用 func 延时(毫秒: 整数)  ✅
副作用 func sleep(毫秒: 整数)  // 英文别名
副作用 func delay(毫秒: 整数)  // 英文别名
延时(1000)

// 退出
副作用 func 退出(代码: 整数 = 0)  ✅
副作用 func exit(代码: 整数 = 0)  // 英文别名
退出(0)
```


## 8. 多语言互操作函数

御程支持直接调用 Python 和 JavaScript/Node.js 的功能，弥补生态不足。

### 7.1 Python 互操作

```御程
// 检查 Python 是否可用
查询 func Python可用() -> 布尔
查询 func python_available() -> 布尔  // 英文别名

// 执行 Python 代码
副作用 func Python执行(代码: 文本) -> 文本
副作用 func python_exec(代码: 文本) -> 文本  // 英文别名

// 调用 Python 模块函数
副作用 func Python调用(模块: 文本, 函数: 文本, 参数: 列表) -> 任意
副作用 func python_call(模块: 文本, 函数: 文本, 参数: 列表) -> 任意  // 英文别名

// 使用示例
如果 Python可用() {
    // 执行 Python 代码
    let 结果 = Python执行("print(1 + 2 + 3)")
    控制台 => 结果  // "6"
    
    // 调用 math 模块的 sqrt 函数
    let 平方根 = Python调用("math", "sqrt", [16])
    控制台 => 平方根  // 4.0
    
    // 调用字符串方法
    let 大写 = Python执行("print('hello'.upper())")
    控制台 => 大写  // "HELLO"
}
```

### 7.2 JavaScript/Node.js 互操作

```御程
// 检查 Node.js 是否可用
查询 func JS可用() -> 布尔
查询 func js_available() -> 布尔  // 英文别名

// 执行 JavaScript 代码
副作用 func JS执行(代码: 文本) -> 文本
副作用 func js_exec(代码: 文本) -> 文本  // 英文别名

// 调用 Node.js 模块函数
副作用 func JS调用(模块: 文本, 函数: 文本, 参数: 列表) -> 任意
副作用 func js_call(模块: 文本, 函数: 文本, 参数: 列表) -> 任意  // 英文别名

// 使用示例
如果 JS可用() {
    // 执行 JavaScript 代码
    let 结果 = JS执行("console.log(Math.sqrt(25))")
    控制台 => 结果  // "5"
    
    // 调用 Node.js 内置模块
    let 路径 = JS调用("path", "join", ["/home", "user", "docs"])
    控制台 => 路径  // "/home/user/docs"
    
    // 使用 JavaScript 数组方法
    let 数组结果 = JS执行("console.log([1,2,3].reduce((a,b)=>a+b))")
    控制台 => 数组结果  // "6"
}
```

### 7.3 类型映射

| 御程类型 | Python 类型 | JavaScript 类型 |
|----------|-------------|-----------------|
| `整数` | `int` | `number` |
| `小数` | `float` | `number` |
| `文本` | `str` | `string` |
| `布尔` | `bool` | `boolean` |
| `空` | `None` | `null` |
| `列表` | `list` | `Array` |

### 7.4 注意事项

1. **前提条件**：需要系统安装对应的运行时
   - Python: 需要 `python` 或 `python3` 命令可用
   - JavaScript: 需要 `node` 命令可用

2. **性能考虑**：每次调用都会启动子进程，不适合高频调用

3. **错误处理**：如果运行时不可用或代码执行失败，会抛出运行时错误

4. **安全性**：执行的代码来自用户输入时需要注意安全风险

---

## 9. 硬件控制函数 ⚠️ 需要权限

硬件控制函数提供对CPU、GPU、内存等硬件的底层访问和控制。**警告**：控制类函数需要管理员权限，不当使用可能导致系统不稳定。

### 8.1 CPU控制函数 ✅ 已实现

#### 查询类函数（无需权限）

**注意**：部分函数需要启用 `sysinfo` 特性才能获取实时数据，否则返回基础信息或默认值。

```御程
// 获取CPU基本信息
查询 func 获取CPU信息() -> 字典
查询 func get_cpu_info() -> 字典  // 英文别名
变量 cpu信息 = 获取CPU信息()
// 返回: {
//   "品牌": "Intel(R) Xeon(R) CPU...",
//   "型号": "CPU 1",
//   "架构": "x86_64",
//   "物理核心数": 24,
//   "逻辑线程数": 48,
//   "频率": 2501
// }

// 获取CPU核心数（物理核心数）
查询 func 获取CPU核心数() -> 整数
查询 func get_cpu_cores() -> 整数
变量 核心数 = 获取CPU核心数()

// 获取CPU线程数（逻辑核心数）
查询 func 获取CPU线程数() -> 整数
查询 func get_cpu_threads() -> 整数
变量 线程数 = 获取CPU线程数()

// 获取CPU使用率（0.0-1.0，需要 sysinfo 特性）
查询 func 获取CPU使用率() -> 小数
查询 func get_cpu_usage() -> 小数
变量 使用率 = 获取CPU使用率()

// 获取每个核心的CPU使用率（需要 sysinfo 特性）✅
查询 func 获取每个核心CPU使用率() -> 列表<小数>
查询 func get_cpu_usage_per_core() -> 列表<小数>
变量 各核心使用率 = 获取每个核心CPU使用率()
// 返回: [0.5, 0.3, 0.7, ...]  // 每个核心的使用率（0.0-1.0）

// 获取CPU频率（MHz，需要 sysinfo 特性）
查询 func 获取CPU频率() -> 整数
查询 func get_cpu_frequency() -> 整数
变量 频率 = 获取CPU频率()

// 获取CPU温度（°C，需要 sysinfo 特性，可能不支持）
查询 func 获取CPU温度() -> 小数
查询 func get_cpu_temperature() -> 小数
尝试 {
    变量 温度 = 获取CPU温度()
    打印("CPU温度: " + 转文本(温度) + "°C")
} 捕获 错误 {
    打印("当前平台不支持CPU温度读取")
}

// 获取CPU详细信息（需要 sysinfo 特性）✅
查询 func 获取CPU详细信息() -> 字典
查询 func get_cpu_detailed_info() -> 字典
变量 详细信息 = 获取CPU详细信息()
// 返回: {
//   "品牌": "...",
//   "型号": "...",
//   "架构": "x86_64",
//   "物理核心数": 24,
//   "逻辑线程数": 48,
//   "频率": 2501,
//   "核心列表": [
//     {"索引": 0, "名称": "CPU 1", "品牌": "...", "频率": 2501, "使用率": 0.5},
//     ...
//   ],
//   "总内存": 整数,
//   "已用内存": 整数,
//   "可用内存": 整数
// }
```

#### 控制类函数（需要管理员权限）⚠️

```御程
// 设置CPU频率（MHz）
副作用 func 设置CPU频率(频率: 整数)
副作用 func set_cpu_frequency(频率: 整数)
尝试 {
    设置CPU频率(2400)
    打印("CPU频率设置成功")
} 捕获 错误 {
    打印("权限不足: " + 转文本(错误))
}

// 设置CPU亲和性（绑定进程到特定核心）
副作用 func 设置CPU亲和性(进程ID: 整数, 核心列表: 列表<整数>)
副作用 func set_cpu_affinity(进程ID: 整数, 核心列表: 列表<整数>)
设置CPU亲和性(1234, [0, 1])  // 绑定进程到核心0和1

// 设置CPU核心状态（启用/禁用核心）
副作用 func 设置CPU核心状态(核心索引: 整数, 启用: 布尔)
副作用 func set_cpu_core_state(核心索引: 整数, 启用: 布尔)
设置CPU核心状态(0, 真)  // 启用核心0

// 设置CPU调度策略
副作用 func 设置CPU调度策略(进程ID: 整数, 策略: 文本)
副作用 func set_cpu_scheduler(进程ID: 整数, 策略: 文本)
设置CPU调度策略(1234, "FIFO")

// 设置CPU功耗模式
副作用 func 设置CPU功耗模式(模式: 文本)
副作用 func set_cpu_power_mode(模式: 文本)
设置CPU功耗模式("性能")  // 或 "省电"、"平衡"

// 绑定进程到CPU核心
副作用 func 绑定进程到CPU核心(进程ID: 整数, 核心列表: 列表<整数>)
副作用 func bind_process_to_core(进程ID: 整数, 核心列表: 列表<整数>)
绑定进程到CPU核心(1234, [0, 1])

// 设置CPU缓存策略
副作用 func 设置CPU缓存策略(地址: 整数, 策略: 文本)
副作用 func set_cpu_cache_policy(地址: 整数, 策略: 文本)
设置CPU缓存策略(0x1000000, "WRITE_BACK")
```

### 8.2 GPU控制函数

#### 查询类函数（无需权限）

```御程
// 获取GPU信息
查询 func 获取GPU信息() -> 字典
查询 func get_gpu_info() -> 字典
变量 gpu信息 = 获取GPU信息()

// 获取GPU列表
查询 func 获取GPU列表() -> 列表<字典>
查询 func get_gpu_list() -> 列表<字典>
变量 gpu列表 = 获取GPU列表()

// 获取GPU使用率（0.0-1.0）
查询 func 获取GPU使用率() -> 小数
查询 func get_gpu_usage() -> 小数
尝试 {
    变量 使用率 = 获取GPU使用率()
    打印("GPU使用率: " + 转文本(使用率 * 100) + "%")
} 捕获 错误 {
    打印("GPU使用率获取失败")
}

// 获取GPU温度（°C）
查询 func 获取GPU温度() -> 小数
查询 func get_gpu_temperature() -> 小数
尝试 {
    变量 温度 = 获取GPU温度()
    打印("GPU温度: " + 转文本(温度) + "°C")
} 捕获 错误 {
    打印("GPU温度获取失败")
}

// 获取GPU内存信息
查询 func 获取GPU内存() -> 字典
查询 func get_gpu_memory() -> 字典
尝试 {
    变量 内存 = 获取GPU内存()
    打印("GPU内存: " + 转文本(内存))
} 捕获 错误 {
    打印("GPU内存获取失败")
}
```

#### 控制类函数（需要管理员权限）⚠️

```御程
// 设置GPU频率（MHz）
副作用 func 设置GPU频率(频率: 整数)
副作用 func set_gpu_frequency(频率: 整数)
设置GPU频率(1500)

// 设置GPU功耗限制（W）
副作用 func 设置GPU功耗限制(功耗: 整数)
副作用 func set_gpu_power_limit(功耗: 整数)
设置GPU功耗限制(200)

// 分配GPU内存（字节）
副作用 func 分配GPU内存(大小: 整数) -> 整数
副作用 func allocate_gpu_memory(大小: 整数) -> 整数
变量 地址 = 分配GPU内存(1024 * 1024)

// 释放GPU内存
副作用 func 释放GPU内存(地址: 整数)
副作用 func free_gpu_memory(地址: 整数)
释放GPU内存(0x1000000)

// 提交GPU计算任务
副作用 func 提交GPU计算任务(着色器代码: 文本, 工作组大小: 列表<整数>)
副作用 func submit_gpu_compute(着色器代码: 文本, 工作组大小: 列表<整数>)
提交GPU计算任务("shader_code", [256, 256])

// 提交GPU渲染任务
副作用 func 提交GPU渲染任务(顶点数: 整数, 实例数: 整数)
副作用 func submit_gpu_render(顶点数: 整数, 实例数: 整数)
提交GPU渲染任务(1000, 1)

// 设置GPU渲染管线
副作用 func 设置GPU渲染管线(管线ID: 整数)
副作用 func set_gpu_pipeline(管线ID: 整数)
设置GPU渲染管线(1)

// 同步GPU操作
副作用 func 同步GPU()
副作用 func sync_gpu()
同步GPU()

// 设置GPU时钟分频
副作用 func 设置GPU时钟分频(分频比: 整数)
副作用 func set_gpu_clock_divider(分频比: 整数)
设置GPU时钟分频(2)
```

### 8.3 内存控制函数

#### 查询类函数（无需权限）

```御程
// 获取内存信息
查询 func 获取内存信息() -> 字典
查询 func get_memory_info() -> 字典
变量 内存信息 = 获取内存信息()
// 返回: {"总内存": ..., "已用内存": ..., "可用内存": ..., ...}

// 获取内存使用率（0.0-1.0）
查询 func 获取内存使用率() -> 小数
查询 func get_memory_usage() -> 小数
变量 使用率 = 获取内存使用率()
打印("内存使用率: " + 转文本(使用率 * 100) + "%")
```

#### 控制类函数（需要管理员权限）⚠️

```御程
// 清理内存缓存
副作用 func 清理内存()
副作用 func clear_memory()
清理内存()

// 直接内存访问
副作用 func 直接内存访问(地址: 整数, 大小: 整数) -> 列表<字节>
副作用 func direct_memory_access(地址: 整数, 大小: 整数) -> 列表<字节>
变量 数据 = 直接内存访问(0x1000000, 1024)

// 内存映射IO
副作用 func 内存映射IO(地址: 整数, 大小: 整数)
副作用 func memory_mapped_io(地址: 整数, 大小: 整数)
内存映射IO(0x1000000, 4096)

// 设置内存保护
副作用 func 设置内存保护(地址: 整数, 大小: 整数, 保护模式: 文本)
副作用 func set_memory_protection(地址: 整数, 大小: 整数, 保护模式: 文本)
设置内存保护(0x1000000, 4096, "READ_WRITE")

// 刷新缓存行
副作用 func 刷新缓存行(地址: 整数)
副作用 func flush_cache_line(地址: 整数)
刷新缓存行(0x1000000)

// 预取内存
副作用 func 预取内存(地址: 整数)
副作用 func prefetch_memory(地址: 整数)
预取内存(0x1000000)
```

### 8.4 DMA控制函数（需要管理员权限）⚠️

```御程
// 启动DMA传输
副作用 func 启动DMA传输(源地址: 整数, 目标地址: 整数, 大小: 整数) -> 整数
副作用 func start_dma_transfer(源地址: 整数, 目标地址: 整数, 大小: 整数) -> 整数
变量 传输ID = 启动DMA传输(0x1000000, 0x2000000, 1024)

// 停止DMA传输
副作用 func 停止DMA传输(传输ID: 整数)
副作用 func stop_dma_transfer(传输ID: 整数)
停止DMA传输(1)

// 查询DMA状态（无需权限）
查询 func 查询DMA状态(传输ID: 整数) -> 字典
查询 func query_dma_status(传输ID: 整数) -> 字典
尝试 {
    变量 状态 = 查询DMA状态(1)
    打印(状态)
} 捕获 错误 {
    打印("DMA传输不存在")
}
```

### 8.5 中断控制函数（需要管理员权限）⚠️

```御程
// 注册中断处理器
副作用 func 注册中断处理器(中断号: 整数, 处理器函数: 文本)
副作用 func register_interrupt_handler(中断号: 整数, 处理器函数: 文本)
注册中断处理器(1, "handler_function")

// 启用中断
副作用 func 启用中断(中断号: 整数)
副作用 func enable_interrupt(中断号: 整数)
启用中断(1)

// 禁用中断
副作用 func 禁用中断(中断号: 整数)
副作用 func disable_interrupt(中断号: 整数)
禁用中断(1)

// 触发软中断
副作用 func 触发软中断(中断号: 整数)
副作用 func trigger_soft_interrupt(中断号: 整数)
触发软中断(1)
```

### 8.6 网络控制函数 ✅ 已实现（需要 sysinfo 特性）

**注意**：网络相关函数需要启用 `sysinfo` 特性才能正常工作。默认构建不包含此特性，需要使用 `--features sysinfo` 编译。

```御程
// 获取网络状态
查询 func 获取网络状态() -> 字典
查询 func get_network_status() -> 字典
变量 状态 = 获取网络状态()
// 返回: {"已连接": 布尔, "接口列表": 列表<字典>}

// 获取网络接口列表
查询 func 获取网络接口列表() -> 列表<文本>
查询 func get_network_interfaces() -> 列表<文本>
变量 接口列表 = 获取网络接口列表()
// 返回: ["以太网", "WiFi", ...]

// 获取网络接口信息
查询 func 获取网络接口信息(接口名: 文本) -> 字典
查询 func get_network_interface_info(接口名: 文本) -> 字典
变量 信息 = 获取网络接口信息("以太网")
// 返回: {
//   "名称": "以太网",
//   "接收字节数": 整数,
//   "发送字节数": 整数,
//   "总接收字节数": 整数,
//   "总发送字节数": 整数,
//   ...
// }

// 打开链接（系统默认浏览器）
副作用 func 打开链接(URL: 文本)
副作用 func open_url(URL: 文本)
打开链接("https://example.com")
```

**编译方式**：
```bash
# 启用 sysinfo 特性编译
cargo build --features sysinfo

# 或运行时启用
cargo run --features sysinfo --bin yucheng -- run 程序.ycs
```

### 8.7 权限说明和特性要求

| 函数类型 | 权限要求 | 特性要求 | 说明 |
|---------|---------|---------|------|
| 查询类函数 | 无需权限 | 部分需要 `sysinfo` | 只读取硬件信息，安全 |
| 控制类函数 | 管理员权限 | 需要 `sysinfo` | 修改硬件设置，需要谨慎使用 |

**特性要求**：
- **sysinfo 特性**：部分硬件查询函数（如 `获取每个核心CPU使用率`、`获取CPU详细信息`、`获取网络接口列表` 等）需要启用 `sysinfo` 特性
- 默认构建不包含此特性，需要使用 `--features sysinfo` 编译
- 未启用特性时，相关函数可能返回空值或基础信息

**编译方式**：
```bash
# 启用 sysinfo 特性编译
cargo build --features sysinfo

# 或运行时启用
cargo run --features sysinfo --bin yucheng -- run 程序.ycs
```

**权限检查**：
- 用户级权限下，控制类函数会抛出错误
- 需要使用 `尝试-捕获` 处理权限错误
- 管理员权限下，控制类函数才能正常执行

**安全建议**：
1. 优先使用查询类函数获取信息
2. 控制类函数使用前务必确认权限
3. 不当使用可能导致系统不稳定
4. 建议在测试环境中验证后再用于生产环境
5. 使用硬件控制函数时，确保已启用 `sysinfo` 特性

---

## 10. Result类型函数

Result类型用于表示可能成功或失败的操作结果。

### 10.1 创建Result值

```御程
// 创建成功结果
纯函数 func 成功(值: 任意) -> Result<任意>
纯函数 func ok(值: 任意) -> Result<任意>  // 英文别名
变量 结果 = 成功(42)
变量 结果2 = ok("操作成功")

// 创建失败结果
纯函数 func 失败(错误: 任意) -> Result<任意>
纯函数 func err(错误: 任意) -> Result<任意>  // 英文别名
变量 错误结果 = 失败("操作失败")
变量 错误结果2 = err("权限不足")
```

### 10.2 检查Result类型

```御程
// 检查是否为成功
纯函数 func 是成功(结果: Result<任意>) -> 布尔
纯函数 func is_ok(结果: Result<任意>) -> 布尔  // 英文别名
如果 是成功(结果) {
    打印("操作成功")
}

// 检查是否为失败
纯函数 func 是失败(结果: Result<任意>) -> 布尔
纯函数 func is_err(结果: Result<任意>) -> 布尔  // 英文别名
如果 是失败(结果) {
    打印("操作失败")
}
```

### 10.3 解包Result值

```御程
// 解包Result（失败时panic）
副作用 func 解包(结果: Result<任意>) -> 任意
副作用 func unwrap(结果: Result<任意>) -> 任意  // 英文别名
变量 值 = 解包(结果)  // 如果失败会抛出错误

// 解包Result（失败时返回默认值）
纯函数 func 解包或(结果: Result<任意>, 默认值: 任意) -> 任意
纯函数 func unwrap_or(结果: Result<任意>, 默认值: 任意) -> 任意  // 英文别名
变量 值 = 解包或(结果, "默认值")

// 解包Result（失败时显示自定义消息）
副作用 func 期望(结果: Result<任意>, 错误消息: 文本) -> 任意
副作用 func expect(结果: Result<任意>, 错误消息: 文本) -> 任意  // 英文别名
变量 值 = 期望(结果, "操作应该成功")
```

### 10.4 Result类型使用示例

```御程
// 安全设置CPU频率函数
副作用 func 安全设置CPU频率(频率: 整数) -> Result<文本> {
    尝试 {
        设置CPU频率(频率)
        返回 成功("CPU频率设置成功")
    } 捕获 错误 {
        返回 失败("权限不足: " + 转文本(错误))
    }
}

// 使用Result类型
变量 结果 = 安全设置CPU频率(2400)
如果 是成功(结果) {
    变量 消息 = 解包或(结果, "")
    打印("成功: " + 消息)
} 否则如果 是失败(结果) {
    变量 错误消息 = 解包或(结果, "未知错误")
    打印("失败: " + 错误消息)
}
```

### 10.5 Result类型结构

Result类型在内部表示为字典：

```御程
// 成功结果结构
{
    "类型": "成功",
    "值": <实际值>
}

// 失败结果结构
{
    "类型": "失败",
    "错误": <错误信息>
}
```

**注意**：虽然Result类型内部是字典，但应该使用提供的函数来操作，而不是直接访问字典字段。

---

## 11. 函数式编程工具

### 11.1 列表高阶函数

```御程
// 映射 - 将列表中的每个元素转换为新值
纯函数 func 映射<T, R>(列表: 列表<T>, 转换: func(T) -> R) -> 列表<R>
变量 结果 = 映射([1, 2, 3], x => x * 2)  // [2, 4, 6]

// 过滤 - 筛选满足条件的元素
纯函数 func 过滤<T>(列表: 列表<T>, 条件: func(T) -> 布尔) -> 列表<T>
变量 结果 = 过滤([1, 2, 3, 4, 5], x => x > 2)  // [3, 4, 5]

// 排序 - 对列表进行排序
纯函数 func 排序<T>(列表: 列表<T>) -> 列表<T>
变量 结果 = 排序([3, 1, 4, 1, 5])  // [1, 1, 3, 4, 5]

// 反转 - 反转列表顺序
纯函数 func 反转<T>(列表: 列表<T>) -> 列表<T>
变量 结果 = 反转([1, 2, 3])  // [3, 2, 1]

// 去重 - 移除重复元素
纯函数 func 去重<T>(列表: 列表<T>) -> 列表<T>
变量 结果 = 去重([1, 2, 2, 3, 3, 3])  // [1, 2, 3]
```

### 11.2 链式调用

虽然不支持方法链，但可以通过嵌套调用实现：

```御程
// 链式处理：先映射，再过滤
变量 结果 = 过滤(
    映射([1, 2, 3, 4, 5], x => x * 2),
    x => x > 5
)  // [6, 8, 10]

// 更复杂的链式处理
变量 最终结果 = 去重(
    排序(
        过滤(
            映射([1, 2, 3, 4, 5], x => x * 2),
            x => x > 3
        )
    )
)  // [4, 6, 8, 10]
```

### 11.3 函数组合

```御程
// 组合多个函数
纯函数 func 组合<A, B, C>(
    函数1: func(A) -> B,
    函数2: func(B) -> C
) -> func(A) -> C {
    返回 x => 函数2(函数1(x))
}

// 使用组合
变量 平方 = x => x * x
变量 加倍 = x => x * 2
变量 平方后加倍 = 组合(平方, 加倍)
变量 结果 = 平方后加倍(5)  // (5*5)*2 = 50
```

---

## 12. 重要说明

### 12.1 类型检查

YuCheng 语言提供了两种方式进行类型检查：

**方式1：使用类型判断函数（推荐）** ✅
```御程
// ✅ 推荐方式：使用类型判断函数
如果 是列表(值) {
    打印("这是一个列表")
} 否则如果 是字典(值) {
    打印("这是一个字典")
} 否则如果 是整数(值) {
    打印("这是一个整数")
}
```

**方式2：使用获取类型函数**
```御程
// ✅ 也可以使用获取类型函数进行比较
变量 类型 = 获取类型(值)
如果 类型 == "列表" {
    打印("这是一个列表")
} 否则如果 类型 == "映射" {
    打印("这是一个字典")
}
```

**可用的类型判断函数**：
- `是整数` / `is_int`
- `是小数` / `is_float`
- `是文本` / `is_string`
- `是布尔` / `is_bool`
- `是列表` / `is_list`
- `是字典` / `是映射` / `is_map` / `is_dict`

### 12.2 sysinfo 特性

部分硬件和网络相关函数需要启用 `sysinfo` 特性：

**需要 sysinfo 特性的函数**：
- `获取每个核心CPU使用率`
- `获取CPU详细信息`
- `获取网络接口列表`
- `获取网络接口信息`
- `获取网络状态`

**编译方式**：
```bash
cargo build --features sysinfo
cargo run --features sysinfo --bin yucheng -- run 程序.ycs
```

### 12.3 函数参数说明

- `打印` 和 `输出` 函数支持多个参数，会自动转换为文本并拼接
- 如果遇到语法解析问题，可以使用字符串拼接：`打印("文本" + 转文本(值))`

---

*最后更新: 2026-01-18*


## 13. Advanced Functional Programming Features (NEW)

### 13.1 Function Composition (组合)

Compose two functions to create a new function that applies them in sequence.

```yucheng
// Function signature
纯函数 func 组合(函数1: func, 函数2: func) -> func
纯函数 func compose(函数1: func, 函数2: func) -> func  // English alias

// Usage example
纯函数 func 加一(x: 整数) -> 整数 { 返回 x + 1 }
纯函数 func 乘二(x: 整数) -> 整数 { 返回 x * 2 }

变量 组合函数 = 组合(加一, 乘二)
变量 结果 = 组合函数(5)  // (5 + 1) * 2 = 12

// With Lambda expressions
变量 f = 组合(x => x + 1, x => x * 2)
变量 结果 = f(5)  // 12
```

**Execution order**: f2(f1(x)) - applies f1 first, then f2

### 13.2 Pipe Operation (管道)

Similar to compose, but emphasizes left-to-right data flow.

```yucheng
// Function signature
纯函数 func 管道(函数1: func, 函数2: func) -> func
纯函数 func pipe(函数1: func, 函数2: func) -> func  // English alias

// Usage example
变量 管道函数 = 管道(x => x + 1, x => x * 2)
变量 结果 = 管道函数(5)  // (5 + 1) * 2 = 12

// Chain multiple pipes
变量 f1 = 管道(x => x + 1, x => x * 2)
变量 f2 = 管道(f1, x => x - 3)
变量 结果 = f2(5)  // ((5 + 1) * 2) - 3 = 9
```

### 13.3 Currying (柯里化)

Transform a multi-parameter function into a chain of single-parameter functions.

```yucheng
// Function signature
纯函数 func 柯里化(函数: func) -> func
纯函数 func curry(函数: func) -> func  // English alias

// Usage example
纯函数 func 加法(a: 整数, b: 整数) -> 整数 { 返回 a + b }

变量 柯里化加法 = 柯里化(加法)
变量 加五 = 柯里化加法(5)
变量 结果 = 加五(3)  // 5 + 3 = 8

// Three parameters
纯函数 func 三数相加(a: 整数, b: 整数, c: 整数) -> 整数 { 
    返回 a + b + c 
}

变量 柯里化函数 = 柯里化(三数相加)
变量 f1 = 柯里化函数(1)
变量 f2 = f1(2)
变量 结果 = f2(3)  // 1 + 2 + 3 = 6
```

### 13.4 Partial Application (偏应用)

Fix some parameters of a function, creating a new function with fewer parameters.

```yucheng
// Function signature
纯函数 func 偏应用(函数: func, 固定参数: 列表) -> func
纯函数 func partial(函数: func, 固定参数: 列表) -> func  // English alias
纯函数 func partial_apply(函数: func, 固定参数: 列表) -> func  // English alias

// Usage example
纯函数 func 乘法(a: 整数, b: 整数) -> 整数 { 返回 a * b }

变量 乘以三 = 偏应用(乘法, [3])
变量 结果 = 乘以三(5)  // 3 * 5 = 15

// Multiple fixed parameters
纯函数 func 四数相加(a: 整数, b: 整数, c: 整数, d: 整数) -> 整数 { 
    返回 a + b + c + d 
}

变量 部分函数 = 偏应用(四数相加, [1, 2])
变量 结果 = 部分函数(3, 4)  // 1 + 2 + 3 + 4 = 10
```

### 13.5 Memoization (记忆化)

Cache function results to avoid redundant computations.

```yucheng
// Function signature
纯函数 func 记忆化(函数: func) -> func
纯函数 func memoize(函数: func) -> func  // English alias

// Usage example
纯函数 func 斐波那契(n: 整数) -> 整数 {
    如果 n <= 1 { 返回 n }
    返回 斐波那契(n - 1) + 斐波那契(n - 2)
}

变量 记忆化斐波那契 = 记忆化(斐波那契)

// First call computes the result
变量 结果1 = 记忆化斐波那契(10)  // Computes: 55

// Second call retrieves from cache
变量 结果2 = 记忆化斐波那契(10)  // From cache: 55

// Multi-parameter memoization
纯函数 func 计算(a: 整数, b: 整数) -> 整数 {
    返回 a * b + a + b
}

变量 记忆化计算 = 记忆化(计算)
变量 结果1 = 记忆化计算(5, 3)  // Computes: 23
变量 结果2 = 记忆化计算(5, 3)  // From cache: 23
变量 结果3 = 记忆化计算(4, 2)  // New params, computes: 14
```

### 13.6 Combining Functional Features

You can combine these features for powerful functional programming:

```yucheng
纯函数 func 双倍(x: 整数) -> 整数 { 返回 x * 2 }
纯函数 func 加十(x: 整数) -> 整数 { 返回 x + 10 }

// Compose + Memoize
变量 组合函数 = 组合(双倍, 加十)
变量 记忆化组合 = 记忆化(组合函数)

变量 结果1 = 记忆化组合(5)  // (5 * 2) + 10 = 20
变量 结果2 = 记忆化组合(5)  // From cache: 20

// Curry + Partial
纯函数 func 格式化(前缀: 文本, 数字: 整数) -> 文本 { 
    返回 前缀 + 转文本(数字)
}

变量 柯里化格式化 = 柯里化(格式化)
变量 添加前缀 = 柯里化格式化("数字:")
变量 结果 = 添加前缀(42)  // "数字:42"
```

---

*Last Updated: 2026-02-08*
*Added: Advanced functional programming features (compose, pipe, curry, partial, memoize)*
