# 字节码虚拟机

## 概述

御程编译器包含一个完整的栈式字节码虚拟机（Stack-based Bytecode VM），用于高效执行编译后的程序。字节码是一种中间表示，比直接遍历 AST 更高效，同时保持了跨平台的可移植性。

> **注意**：字节码虚拟机与树遍历解释器（`interpreter.rs`）是两个不同的执行引擎：
> - **树遍历解释器**：直接遍历 AST 执行，实现简单，启动快，适合开发和调试
> - **字节码虚拟机**：将 AST 编译为字节码后执行，性能更高，适合生产环境
> 
> 两者共享相同的 `Value` 类型系统和标准库，确保行为一致性。

## 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                    BytecodeVM 执行引擎                       │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │   Stack     │  │ Call Stack  │  │    Instruction      │ │
│  │  操作数栈    │  │   调用栈    │  │    Pointer (IP)     │ │
│  │  Vec<Value> │  │ Vec<Frame>  │  │       usize         │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐  ┌─────────────────────────────┐  │
│  │   Local Variables   │  │     Global Variables        │  │
│  │      局部变量        │  │        全局变量             │  │
│  │     Vec<Value>      │  │       Vec<Value>            │  │
│  └─────────────────────┘  └─────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Constant Pool                       │   │
│  │                    常量池                            │   │
│  │              Vec<Value> (不可变)                     │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 Standard Library                     │   │
│  │                   标准库绑定                          │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

## 指令集详解

### 栈操作指令

| 操作码 | 操作数 | 说明 | 栈效果 |
|--------|--------|------|--------|
| `Push` | Constant(idx) | 将常量池中的值压入栈 | [...] → [..., value] |
| `Pop` | - | 弹出栈顶值并丢弃 | [..., a] → [...] |
| `Dup` | - | 复制栈顶值 | [..., a] → [..., a, a] |

### 变量操作指令

| 操作码 | 操作数 | 说明 | 栈效果 |
|--------|--------|------|--------|
| `LoadLocal` | Local(idx) | 加载局部变量到栈顶 | [...] → [..., value] |
| `StoreLocal` | Local(idx) | 将栈顶值存入局部变量 | [..., value] → [...] |
| `LoadGlobal` | Global(idx) | 加载全局变量到栈顶 | [...] → [..., value] |
| `StoreGlobal` | Global(idx) | 将栈顶值存入全局变量 | [..., value] → [...] |
| `Load` | - | 从指针加载值（解引用） | [..., ptr] → [..., value] |
| `Store` | - | 存储值到指针 | [..., ptr, value] → [...] |

### 算术运算指令

| 操作码 | 说明 | 栈效果 | 支持类型 |
|--------|------|--------|----------|
| `Add` | 加法 | [..., a, b] → [..., a+b] | 整数、浮点、字符串拼接 |
| `Sub` | 减法 | [..., a, b] → [..., a-b] | 整数、浮点 |
| `Mul` | 乘法 | [..., a, b] → [..., a*b] | 整数、浮点 |
| `Div` | 除法 | [..., a, b] → [..., a/b] | 整数、浮点（除零返回Null） |
| `Mod` | 取模 | [..., a, b] → [..., a%b] | 整数 |
| `Pow` | 幂运算 | [..., a, b] → [..., a^b] | 整数、浮点 |
| `Neg` | 取负 | [..., a] → [..., -a] | 整数、浮点 |

### 比较运算指令

| 操作码 | 说明 | 栈效果 |
|--------|------|--------|
| `Eq` | 等于 | [..., a, b] → [..., a==b] |
| `Ne` | 不等于 | [..., a, b] → [..., a!=b] |
| `Lt` | 小于 | [..., a, b] → [..., a<b] |
| `Le` | 小于等于 | [..., a, b] → [..., a<=b] |
| `Gt` | 大于 | [..., a, b] → [..., a>b] |
| `Ge` | 大于等于 | [..., a, b] → [..., a>=b] |

### 逻辑运算指令

| 操作码 | 说明 | 栈效果 |
|--------|------|--------|
| `And` | 逻辑与 | [..., a, b] → [..., a&&b] |
| `Or` | 逻辑或 | [..., a, b] → [..., a\|\|b] |
| `Not` | 逻辑非 | [..., a] → [..., !a] |

### 控制流指令

| 操作码 | 操作数 | 说明 |
|--------|--------|------|
| `Jump` | Offset(n) | 无条件跳转，IP += n + 1 |
| `JumpIfFalse` | Offset(n) | 栈顶为假时跳转 |
| `JumpIfTrue` | Offset(n) | 栈顶为真时跳转 |
| `Call` | Count(argc) | 调用函数，argc 为参数数量 |
| `Return` | - | 从函数返回 |
| `Halt` | - | 停止执行 |

### 数据结构指令

| 操作码 | 操作数 | 说明 | 栈效果 |
|--------|--------|------|--------|
| `MakeList` | Count(n) | 创建列表 | [..., v1..vn] → [..., [v1..vn]] |
| `MakeMap` | Count(n) | 创建映射 | [..., k1,v1..kn,vn] → [..., {k1:v1..}] |
| `MakeStruct` | Count(n) | 创建结构体 | [..., fields, name] → [..., struct] |
| `GetIndex` | - | 索引访问 | [..., obj, idx] → [..., obj[idx]] |
| `SetIndex` | - | 索引赋值 | [..., val, obj, idx] → [...] |
| `GetField` | Name(field) | 字段访问 | [..., obj] → [..., obj.field] |
| `SetField` | Name(field) | 字段赋值 | [..., val, obj] → [...] |

### I/O 指令

| 操作码 | 操作数 | 说明 |
|--------|--------|------|
| `Print` | Count(n) | 打印 n 个值 |
| `Input` | - | 读取输入 |

## 字节码块结构

```rust
pub struct BytecodeChunk {
    /// 指令序列
    pub instructions: Vec<Instruction>,
    /// 常量池 - 存储字面量和函数引用
    pub constants: Vec<Value>,
    /// 局部变量名到索引的映射
    pub locals: HashMap<String, u32>,
    /// 函数名
    pub name: String,
    /// 参数数量
    pub arity: usize,
}

pub struct Instruction {
    pub opcode: OpCode,
    pub operand: Option<Operand>,
    pub span: Span,  // 源码位置，用于调试
}

pub enum Operand {
    Constant(u32),   // 常量池索引
    Local(u32),      // 局部变量索引
    Global(u32),     // 全局变量索引
    Offset(i32),     // 跳转偏移（可正可负）
    Count(u32),      // 参数/元素数量
    Name(String),    // 字段名
}
```

## 编译后程序结构

```rust
pub struct CompiledProgram {
    /// 主代码块（全局初始化 + main 调用）
    pub main: BytecodeChunk,
    /// 函数代码块映射
    pub functions: HashMap<String, BytecodeChunk>,
    /// 全局变量名到索引的映射
    pub globals: HashMap<String, u32>,
    /// 类型定义
    pub type_defs: HashMap<String, TypeDef>,
}
```

## 编译示例

### 源代码

```yucheng
函数 加法(a: 整数, b: 整数) -> 整数 {
    返回 a + b
}

函数 主函数() {
    变量 结果 = 加法(10, 20)
    打印(结果)
}
```

### 编译后字节码

```asm
; ===== 函数: 加法 (arity=2) =====
.function 加法
.locals: a=0, b=1
    LoadLocal 0          ; 加载参数 a
    LoadLocal 1          ; 加载参数 b
    Add                  ; 执行加法
    Return               ; 返回结果

; ===== 函数: 主函数 (arity=0) =====
.function 主函数
.locals: 结果=0
    Push #10             ; 压入常量 10
    Push #20             ; 压入常量 20
    Push @加法           ; 压入函数引用
    Call 2               ; 调用函数，2个参数
    StoreLocal 0         ; 存储到局部变量 "结果"
    LoadLocal 0          ; 加载 "结果"
    Print 1              ; 打印1个值
    Push #null           ; 压入 null
    Return               ; 返回

; ===== 主代码块 =====
.main
    Push @主函数         ; 压入主函数引用
    Call 0               ; 调用主函数
    Halt                 ; 停止执行
```

## 虚拟机执行流程

```rust
impl BytecodeVM {
    pub fn execute(&mut self, program: &CompiledProgram) -> Result<Value> {
        // 1. 初始化全局变量空间
        self.globals.resize(program.globals.len(), Value::Null);
        
        // 2. 执行主代码块
        self.run_chunk(&program.main, program)?;
        
        // 3. 返回栈顶值
        Ok(self.stack.pop().unwrap_or(Value::Null))
    }
    
    fn run_chunk(&mut self, chunk: &BytecodeChunk, program: &CompiledProgram) -> Result<()> {
        let mut ip = 0;  // 指令指针
        
        while ip < chunk.instructions.len() {
            let instr = &chunk.instructions[ip];
            
            match instr.opcode {
                OpCode::Call => {
                    // 函数调用处理
                    let callee = self.stack.pop()?;
                    let args = self.pop_args(argc);
                    
                    if let Value::Function(name) = callee {
                        // 检查标准库
                        if let Some(func) = self.stdlib.get(&name) {
                            let result = func(&args)?;
                            self.stack.push(result);
                        } 
                        // 用户定义函数
                        else if let Some(func_chunk) = program.functions.get(&name) {
                            // 保存调用帧
                            self.call_stack.push(CallFrame {
                                return_ip: ip + 1,
                                locals_start: self.locals.len(),
                                function_name: name,
                            });
                            
                            // 设置参数为局部变量
                            for arg in args {
                                self.locals.push(arg);
                            }
                            
                            // 递归执行函数
                            self.run_chunk(func_chunk, program)?;
                            
                            // 恢复调用帧
                            let frame = self.call_stack.pop()?;
                            self.locals.truncate(frame.locals_start);
                        }
                    }
                }
                // ... 其他指令处理
            }
            
            ip += 1;
        }
        Ok(())
    }
}
```

## 类型系统支持

VM 支持以下值类型：

```rust
pub enum Value {
    Null,                              // 空值
    Bool(bool),                        // 布尔
    Integer(i64),                      // 64位整数
    Float(f64),                        // 64位浮点
    String(String),                    // UTF-8 字符串
    List(Vec<Value>),                  // 动态列表
    Map(HashMap<String, Value>),       // 字符串键映射
    Struct(String, HashMap<String, Value>), // 结构体
    Function(String),                  // 函数引用
    Ok(Box<Value>),                    // 成功结果
    Err(Box<Value>),                   // 错误结果
}
```

## 编译选项集成

字节码编译器支持编译选项控制：

```rust
let options = CompileOptions::new()
    .with_mode(CompileMode::Release)
    .disable_feature(CompileFeature::Assert)
    .enable_feature(CompileFeature::ExecutionTrace);

let mut compiler = BytecodeCompiler::with_options(options);
let program = compiler.compile(&ast)?;
```

### 可裁剪特性

- `Assert` - 断言语句（Release 模式自动裁剪）
- `ExecutionTrace` - 执行追踪
- `DebugSymbols` - 调试符号

## 使用示例

```rust
use yucheng_compiler::{BytecodeCompiler, BytecodeVM, Lexer, Parser};

// 1. 解析源代码
let source = r#"
    函数 斐波那契(n: 整数) -> 整数 {
        如果 n <= 1 {
            返回 n
        }
        返回 斐波那契(n - 1) + 斐波那契(n - 2)
    }
    
    函数 主函数() {
        打印(斐波那契(10))
    }
"#;

let mut lexer = Lexer::new(source);
let tokens = lexer.tokenize()?;
let mut parser = Parser::new(tokens);
let ast = parser.parse()?;

// 2. 编译为字节码
let mut compiler = BytecodeCompiler::new();
let program = compiler.compile(&ast)?;

// 3. 执行字节码
let mut vm = BytecodeVM::new();
let result = vm.execute(&program)?;

// 4. 获取输出
println!("{}", vm.get_output());  // 输出: 55
```

## 性能特点

1. **常量池去重** - 相同常量只存储一次
2. **局部变量索引** - O(1) 变量访问
3. **跳转偏移** - 相对跳转，无需地址重定位
4. **栈式执行** - 无需寄存器分配
5. **标准库内联** - 常用函数直接调用

## 与其他后端对比

| 特性 | 字节码 VM | 树遍历解释器 | LLVM | WebAssembly |
|------|-----------|--------------|------|-------------|
| 启动速度 | 快 | 最快 | 慢 | 中等 |
| 执行速度 | 中等 | 慢 | 最快 | 快 |
| 内存占用 | 低 | 最低 | 高 | 中等 |
| 调试支持 | 好 | 最好 | 一般 | 一般 |
| 跨平台 | 是 | 是 | 需重编译 | 是 |
