# YuCheng 语言 - 安全边界与 MVP 定义

> 本文档回应项目评审中提出的关键结构性问题，明确语言的安全边界、责任划分和最小可行产品定义。

## 1. 安全保证的边界声明

### 1.1 我们承诺什么

> **YuCheng 在语言定义范围内提供内存安全保证。**

具体而言：

| 层级 | 保证内容 | 实现方式 |
|------|----------|----------|
| 语言层 | 作用域绑定、自动释放 | 编译器强制 |
| 类型层 | 空值安全、类型匹配 | 静态检查 |
| 运行时 | 边界检查、空指针防护 | 运行时检查 |

### 1.2 我们不承诺什么

- ❌ 不承诺"100% 内存安全"（这是不可能的）
- ❌ 不承诺 FFI 调用的安全性
- ❌ 不承诺 `不安全` 块内的行为
- ❌ 不承诺外部库的正确性

### 1.3 责任划分

```
┌─────────────────────────────────────────────────────────┐
│                    语言层（编译器保证）                    │
│  • 变量作用域绑定                                        │
│  • 类型安全                                             │
│  • 函数分类约束（纯函数不能调用副作用函数）                  │
│  • 契约静态验证（可判定子集）                              │
├─────────────────────────────────────────────────────────┤
│                    运行时层（动态检查）                    │
│  • 数组边界检查                                          │
│  • 空值访问防护                                          │
│  • 契约动态验证                                          │
├─────────────────────────────────────────────────────────┤
│                    观察层（不做保证）                      │
│  • Memory Simulator = 事实记录器，非正确性裁判             │
│  • 用于教学、调试、AI 分析                                │
│  • 报告问题，但不阻止执行                                 │
├─────────────────────────────────────────────────────────┤
│                    不安全区（用户责任）                    │
│  • 不安全 { ... } 块                                    │
│  • FFI 调用                                             │
│  • 原始指针操作                                          │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 不安全边界的语法标记

### 2.1 不安全块

```御程
// 显式标记不安全代码
不安全 {
    // 这里可以：
    // - 使用原始指针
    // - 调用外部 C 函数
    // - 绕过借用检查
    var 原始指针 = 申请(1024)
    // ... 手动管理内存
    释放(原始指针)
}
```

### 2.2 不安全函数

```御程
// 整个函数标记为不安全
不安全 副作用 func 底层操作(地址: 指针) {
    // 调用者必须在 不安全 块中调用此函数
}

// 调用
不安全 {
    底层操作(某地址)
}
```

### 2.3 FFI 自动标记

```御程
// 所有外部函数调用自动视为不安全
外部 库 "libc" func malloc(size: 整数) -> 指针

// 必须在不安全块中调用
不安全 {
    var 内存 = malloc(1024)
}
```

---

## 3. 契约等级系统

### 3.1 契约分类

```御程
// @checkable - 可静态/动态验证（编译器会检查）
纯函数 func 除法(a: 整数, b: 整数) -> 整数
    @checkable 要求 b <> 0  // 编译器可验证
{
    返回 a / b
}

// @runtime - 仅运行时验证
纯函数 func 查找(列表: 列表<整数>, 值: 整数) -> 整数
    @runtime 要求 长度(列表) > 0  // 运行时检查
{
    // ...
}

// @assume - 文档级，不参与验证
纯函数 func 复杂计算(数据: 列表<整数>) -> 整数
    @assume 要求 数据已排序  // 仅文档说明
{
    // ...
}

// @unsafe - 跳过所有验证
不安全 func 危险操作()
    @unsafe  // 不做任何检查
{
    // ...
}
```

### 3.2 最小可判定子集（MVP 契约）

第一版只支持以下可静态验证的契约：

| 契约类型 | 示例 | 验证方式 |
|----------|------|----------|
| 非空 | `要求 x <> 空` | 静态 |
| 数值比较 | `要求 x > 0` | 静态/动态 |
| 数值区间 | `要求 x >= 0 且 x < 100` | 静态/动态 |
| 长度检查 | `要求 长度(列表) > 0` | 动态 |
| 类型检查 | `要求 类型(x) == "整数"` | 静态 |

**不支持**（第一版）：
- 复杂逻辑表达式
- 量词（所有、存在）
- 递归定义的契约
- 依赖外部状态的契约

---

## 4. Memory Simulator 定位澄清

### 4.1 它是什么

```
Memory Simulator = 观察工具 + 事实记录器
```

- ✅ 记录内存分配/释放事件
- ✅ 检测潜在问题（泄漏、双重释放、悬空指针）
- ✅ 生成 JSON 报告供 AI/人类分析
- ✅ 教学演示内存行为

### 4.2 它不是什么

- ❌ 不是正确性证明器
- ❌ 不是安全保证
- ❌ 不阻止程序执行
- ❌ 不替代语言层的安全机制

### 4.3 报告解读

```json
{
  "type": "memory_report",
  "status": "observation",  // 注意：是"观察"，不是"判决"
  "issues": [
    {
      "type": "potential_leak",  // "潜在"泄漏
      "severity": "warning",     // 警告，不是错误
      "message": "观察到未释放的内存块",
      "suggestion": "请检查是否需要手动释放"
    }
  ]
}
```
## 5. 架构解耦原则

### 5.1 核心与前端分离

```
┌─────────────────┐     JSON      ┌─────────────────┐
│   YuCheng CLI   │ ──────────▶  │   任意前端       │
│   (核心编译器)   │              │   (IDE/Web/...)  │
└─────────────────┘              └─────────────────┘
        │
        │ 输出
        ▼
   • 编译错误 JSON
   • 运行结果 JSON
   • 内存报告 JSON
   • 测试报告 JSON
```

### 5.2 IDE 是可选的

当前 Tauri IDE 的定位：

- 是 JSON 输出的**消费者**
- 是**可替换的**前端实现
- 不是语言的必要组成部分

这意味着：

- 即使 IDE 开发停滞，语言核心仍可用
- 社区可以开发替代前端（VS Code 插件等）
- 降低项目整体风险

---

## 6. 文档修正清单

根据评审意见，以下文档需要修正：

| 文档 | 修正内容 |
|------|----------|
| README.md | 移除"100% 内存安全"表述 |
| 01-架构文档.md | 添加安全边界说明 |
| 03-语法详解.md | 添加 `不安全` 块语法 |
| 06-内存透视详解.md | 明确"观察工具"定位 |


---

## 7. 总结

### 做对的事情（继续保持）

1. ✅ 四文件强制闭环 - 编译器强制执行
2. ✅ 可实现的编译器架构 - 不是 PPT
3. ✅ Memory Simulator 定位清醒 - 观察而非保证

### 需要修正的事情（立即执行）

1. ⚠️ 停止使用"100% 内存安全"
2. ⚠️ 明确不安全边界语法
3. ⚠️ 定义契约可判定子集
4. ⚠️ 澄清 Memory Simulator 定位
5. ⚠️ 定义并坚守 MVP 范围

### 核心原则

> **语言的可信性是可以被观察、审计、推理的，而不是一句口号。**

YuCheng 的目标不是"绝对安全"，而是：

- **透明**：所有行为可观察
- **诚实**：明确说明保证什么、不保证什么
- **务实**：先做能做的，再扩展边界

---