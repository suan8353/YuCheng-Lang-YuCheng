# YuCheng 语言 - 并发与异步系统

> **实现状态**: ✅ 核心功能完整实现 (2026-02-08)
> - ✅ 基础通道（Channel）完整实现（创建、发送、接收、尝试操作）
> - ✅ select表达式完整实现（多通道监听、默认分支）
> - ✅ 超时机制完整实现（启动超时、超时已到）
> - ✅ 原子操作完整实现（原子整数、加载、存储、加法等）
> - ✅ 关键字支持（select、默认）
> - ✅ 解释器支持（select表达式求值）
> - ✅ 异步运行时基础实现（集成 Tokio，支持 `Value::Future`）
> - ✅ 解释器异步支持（`tokio_runtime`、`tokio_local` 字段，延迟初始化）
> - ⚠️ 高级并发特性（任务组、取消传播等）部分实现
> 
> **完成报告**: `.project-reports/implementation-status/16-CONCURRENCY-COMPLETION.md`  
> **示例代码**: `examples/35-select-simple.ycs`, `examples/36-timeout-test.ycs`

## 1. 设计理念

YuCheng 的并发模型基于以下原则：

- **确定性优先**：纯函数天然支持并行，无数据竞争
- **显式并发**：所有并发操作必须显式声明
- **结构化并发**：并发任务有明确的生命周期边界
- **通道通信**：通过消息传递而非共享内存

---

## 2. 协程基础

### 2.1 协程定义

```御程
// 使用 异步 关键字定义协程
异步 func 获取数据(url: 文本) -> 结果<文本, 网络错误> {
    var 响应 = 等待 HTTP_GET(url)
    返回 响应.内容
}

// 调用协程
副作用 func 主函数() {
    var 数据 = 等待 获取数据("https://api.example.com")
    控制台 => 数据
}
```

### 2.2 等待操作

```御程
// 等待单个协程
var 结果 = 等待 异步操作()

// 等待多个协程（全部完成）
var (a, b, c) = 等待_全部(
    获取用户(),
    获取订单(),
    获取配置()
)

// 等待任一完成
var 首个 = 等待_任一(
    从服务器A获取(),
    从服务器B获取()
)

// 带超时等待
var 结果 = 等待_超时(获取数据(), 5000毫秒)
匹配 结果 {
    成功(数据) => 处理(数据)
    超时 => 控制台 => "请求超时"
}
```

### 2.3 协程与函数分类

```御程
// 纯函数不能是异步的（无副作用）
// ❌ 错误
异步 纯函数 func 计算() -> 整数

// 查询函数可以是异步的（读取外部状态）
// ✅ 正确
异步 查询 func 获取温度() -> 小数 {
    返回 等待 传感器.读取()
}

// 副作用函数可以是异步的
// ✅ 正确
异步 副作用 func 保存数据(数据: 文本) {
    等待 文件.写入("data.txt", 数据)
}
```

---

## 3. 通道通信

### 3.1 通道定义

```御程
// 创建通道
var 消息通道 = 通道<文本>()           // 无缓冲通道
var 数据通道 = 通道<整数>(容量: 10)   // 缓冲通道

// 发送数据
消息通道 <- "Hello"

// 接收数据
var 消息 = <- 消息通道
```

### 3.2 通道操作

```御程
// 非阻塞发送
如果 消息通道.尝试发送("Hello") {
    控制台 => "发送成功"
} 否则 {
    控制台 => "通道已满"
}

// 非阻塞接收
匹配 消息通道.尝试接收() {
    有(消息) => 控制台 => "收到: ", 消息
    无 => 控制台 => "通道为空"
}

// 关闭通道
消息通道.关闭()

// 检查通道状态
如果 消息通道.已关闭 {
    控制台 => "通道已关闭"
}
```

### 3.3 选择器（多通道监听）

```御程
选择 {
    当 消息 <- 消息通道 => {
        控制台 => "收到消息: ", 消息
    }
    当 数据 <- 数据通道 => {
        处理数据(数据)
    }
    当 超时(1000毫秒) => {
        控制台 => "等待超时"
    }
    默认 => {
        控制台 => "无数据可用"
    }
}
```

---

## 4. 并行计算

### 4.1 纯函数并行

```御程
// 纯函数可以安全并行执行
纯函数 func 计算平方(x: 整数) -> 整数 {
    返回 x * x
}

// 并行映射
var 数据 = [1, 2, 3, 4, 5, 6, 7, 8]
var 结果 = 并行_映射(数据, 计算平方)  // 自动分配到多核

// 并行归约
var 总和 = 并行_归约(数据, 0, (a, b) => a + b)
```

### 4.2 并行区块

```御程
// 显式并行区块
并行 {
    任务 "下载图片" {
        var 图片 = 等待 下载("image.png")
    }
    
    任务 "处理数据" {
        var 数据 = 等待 加载数据()
    }
    
    任务 "发送通知" {
        等待 发送邮件("完成")
    }
}
// 所有任务完成后继续

// 带结果收集
var (图片, 数据, _) = 并行 {
    任务 => 下载("image.png")
    任务 => 加载数据()
    任务 => 发送邮件("完成")
}
```

### 4.3 工作池

```御程
// 创建工作池
var 池 = 工作池<任务, 结果>(
    工作者数量: 4,
    处理函数: 处理任务
)

// 提交任务
循环 任务 在 任务列表 {
    池.提交(任务)
}

// 收集结果
var 结果列表 = 池.等待全部()

// 关闭工作池
池.关闭()
```

---

## 5. 结构化并发

### 5.1 任务组

```御程
// 任务组确保所有子任务在退出前完成
异步 副作用 func 处理批量请求(urls: 列表<文本>) -> 列表<响应> {
    var 结果 = 列表<响应>()
    
    任务组 组 {
        循环 url 在 urls {
            组.启动 {
                var 响应 = 等待 HTTP_GET(url)
                结果.添加(响应)
            }
        }
    }
    // 任务组结束时，所有任务已完成
    
    返回 结果
}
```

### 5.2 取消传播

```御程
// 取消令牌
异步 副作用 func 长时间操作(取消: 取消令牌) -> 结果<数据, 错误> {
    循环 i 在 0..100 {
        如果 取消.已请求 {
            返回 失败(取消错误("操作被取消"))
        }
        等待 处理步骤(i)
    }
    返回 成功(数据)
}

// 使用取消
var 令牌源 = 取消令牌源()
var 任务 = 启动 长时间操作(令牌源.令牌)

// 5秒后取消
等待 延迟(5000毫秒)
令牌源.取消()

var 结果 = 等待 任务
```

### 5.3 超时控制

```御程
// 带超时的操作
异步 副作用 func 安全获取(url: 文本) -> 结果<文本, 错误> {
    带超时(5000毫秒) {
        返回 等待 HTTP_GET(url)
    } 超时后 {
        返回 失败(超时错误("请求超时"))
    }
}
```

---

## 6. 同步原语

### 6.1 互斥锁

```御程
// 创建互斥锁
var 锁 = 互斥锁()

// 使用锁
副作用 func 安全更新() {
    锁定 锁 {
        // 临界区代码
        共享数据 += 1
    }
}

// 尝试锁定
如果 锁.尝试锁定() {
    // 获得锁
    共享数据 += 1
    锁.解锁()
} 否则 {
    // 锁被占用
}
```

### 6.2 读写锁

```御程
var 读写锁 = 读写锁()

// 读取（允许多个读者）
查询 func 读取数据() -> 数据 {
    读锁定 读写锁 {
        返回 共享数据.克隆()
    }
}

// 写入（独占）
副作用 func 写入数据(新数据: 数据) {
    写锁定 读写锁 {
        共享数据 = 新数据
    }
}
```

### 6.3 原子操作

```御程
// 原子整数
var 计数器 = 原子<整数>(0)

// 原子操作
计数器.增加(1)
计数器.减少(1)
var 值 = 计数器.加载()
计数器.存储(100)

// 比较并交换
var 旧值 = 计数器.比较交换(期望: 100, 新值: 200)
```

### 6.4 信号量

```御程
// 创建信号量（限制并发数）
var 信号量 = 信号量(许可数: 3)

异步 副作用 func 受限操作() {
    信号量.获取()
    尝试 {
        等待 执行操作()
    } 最终 {
        信号量.释放()
    }
}
```

---

## 7. 异步迭代器

### 7.1 异步生成器

```御程
// 定义异步生成器
异步 生成器 func 分页获取(url: 文本) -> 生成 数据 {
    var 页码 = 1
    循环 {
        var 响应 = 等待 HTTP_GET(url + "?page=" + 转文本(页码))
        如果 响应.数据.为空 {
            中断
        }
        生成 响应.数据
        页码 += 1
    }
}

// 使用异步迭代
异步 副作用 func 处理所有数据() {
    异步循环 数据 在 分页获取("https://api.example.com/items") {
        处理(数据)
    }
}
```

### 7.2 流处理

```御程
// 创建数据流
var 流 = 异步流<整数>()

// 生产者
启动 {
    循环 i 在 1..100 {
        流.发送(i)
        等待 延迟(100毫秒)
    }
    流.关闭()
}

// 消费者（带背压）
异步循环 值 在 流 {
    控制台 => "收到: ", 值
}
```

---

## 8. 错误处理

### 8.1 异步错误传播

```御程
// 使用 ? 传播异步错误
异步 副作用 func 完整流程() -> 结果<数据, 错误> {
    var 用户 = 等待 获取用户()?
    var 订单 = 等待 获取订单(用户.ID)?
    var 支付 = 等待 处理支付(订单)?
    返回 成功(支付.收据)
}
```

### 8.2 并行错误收集

```御程
// 收集所有错误而非快速失败
var 结果列表 = 等待_全部_收集错误(
    操作1(),
    操作2(),
    操作3()
)

循环 结果 在 结果列表 {
    匹配 结果 {
        成功(值) => 处理成功(值)
        失败(错误) => 记录错误(错误)
    }
}
```

### 8.3 恐慌恢复

```御程
// 捕获协程中的恐慌
var 任务 = 启动_安全 {
    // 可能恐慌的代码
    危险操作()
}

匹配 等待 任务 {
    正常(结果) => 处理(结果)
    恐慌(信息) => 控制台 => "任务恐慌: ", 信息
}
```

---

## 9. 调度器

### 9.1 调度器配置

```御程
// 配置全局调度器
调度器.配置 {
    工作线程数: 4
    IO线程数: 2
    任务队列大小: 1000
}

// 自定义调度器
var 专用调度器 = 调度器 {
    名称: "IO调度器"
    线程数: 8
    优先级: 高
}

// 在特定调度器上运行
在调度器(专用调度器) {
    等待 IO密集型操作()
}
```

### 9.2 优先级

```御程
// 设置任务优先级
var 高优先任务 = 启动(优先级: 高) {
    等待 紧急操作()
}

var 低优先任务 = 启动(优先级: 低) {
    等待 后台操作()
}
```

---

## 10. 最佳实践

### 10.1 避免共享可变状态

```御程
// ❌ 避免：共享可变状态
var 共享计数 = 0

并行 {
    任务 => 共享计数 += 1  // 数据竞争！
    任务 => 共享计数 += 1
}

// ✅ 推荐：使用通道
var 结果通道 = 通道<整数>(2)

并行 {
    任务 => 结果通道 <- 1
    任务 => 结果通道 <- 1
}

var 总计 = (<- 结果通道) + (<- 结果通道)
```

### 10.2 优先使用纯函数并行

```御程
// ✅ 推荐：纯函数天然线程安全
纯函数 func 处理项(项: 数据) -> 结果 {
    // 无副作用，可安全并行
    返回 计算(项)
}

var 结果 = 并行_映射(数据列表, 处理项)
```

### 10.3 结构化并发

```御程
// ✅ 推荐：使用任务组管理生命周期
任务组 组 {
    组.启动 => 任务1()
    组.启动 => 任务2()
}
// 所有任务在此处已完成

// ❌ 避免：无管理的后台任务
启动 => 后台任务()  // 可能泄漏
```

### 10.4 超时保护

```御程
// ✅ 推荐：所有外部调用都应有超时
var 结果 = 等待_超时(外部API调用(), 5000毫秒)

// ❌ 避免：无限等待
var 结果 = 等待 外部API调用()  // 可能永远阻塞
```

---

## 11. 与审计系统集成

```bash
$ yucheng audit --concurrency

⚠️  worker.yci:25: 检测到潜在数据竞争
    |
 25 |     共享变量 += 1
    |     ^^^^^^^^ 在并行区块中修改共享状态
    |
    = 建议: 使用原子操作或通道通信

❌  server.yci:42: 协程泄漏风险
    |
 42 |     启动 => 处理请求(请求)
    |     ^^^^^ 未使用任务组管理
    |
    = 建议: 使用 任务组 确保协程生命周期可控

⚠️  api.yci:18: 缺少超时保护
    |
 18 |     var 响应 = 等待 HTTP_GET(url)
    |                ^^^^^^^^^^^^^^^^^ 外部调用无超时
    |
    = 建议: 使用 等待_超时(HTTP_GET(url), 超时时间)
```
