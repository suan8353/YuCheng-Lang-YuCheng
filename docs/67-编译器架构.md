# 编译器架构详解

## 整体架构

御程编译器采用经典的多阶段编译架构，支持多种后端目标：

```
┌─────────────────────────────────────────────────────────────┐
│                        源代码                                │
│              .ycs / .yc + .yci / .ycv / .ycl                │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                     预处理器 (preprocessor.rs)               │
│  - 处理 #规格/#实现 分区                                      │
│  - 合并多文件项目                                            │
│  - 处理条件编译                                              │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                     词法分析器 (lexer.rs)                    │
│  - 字符流 → Token 流                                         │
│  - 中英文关键字识别                                          │
│  - 字符串/数字/标识符解析                                     │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                     语法分析器 (parser.rs)                   │
│  - Token 流 → AST                                           │
│  - 递归下降解析                                              │
│  - 错误恢复                                                  │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                     语义分析器 (analyzer.rs)                 │
│  - 类型检查                                                  │
│  - 作用域分析                                                │
│  - 函数分类验证                                              │
│  - 契约检查                                                  │
└─────────────────────────┬───────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┬───────────────┐
          │               │               │               │
          ▼               ▼               ▼               ▼
┌─────────────┐   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│   解释器    │   │  字节码VM   │   │  LLVM后端   │   │  Wasm后端   │
│ interpreter │   │  bytecode   │   │ llvm21_backend│   │ wasm_backend│
│             │   │             │   │ (生成exe)   │   │             │
└─────────────┘   └─────────────┘   └─────────────┘   └─────────────┘
```

## 词法分析器 (Lexer)

### Token 类型

```rust
// token.rs
#[derive(Debug, Clone, PartialEq)]
pub enum TokenKind {
    // 字面量
    Integer(i64),
    Float(f64),
    String(String),
    Bool(bool),
    
    // 标识符
    Identifier(String),
    
    // 关键字
    Func, Var, Let, Struct, Enum, Type,
    If, Else, ElseIf, For, While, Match,
    Return, Break, Continue,
    Pure, Query, Effect,
    Requires, Ensures, Assert,
    Try, Catch, Finally, Throw,
    Unsafe, Defer,
    True, False, Null,
    And, Or, Not, In,
    Async, Await,
    
    // 运算符
    Plus, Minus, Star, Slash, Percent,
    Eq, Ne, Lt, Gt, Le, Ge,
    Assign, Arrow, FatArrow, Pipe,
    
    // 分隔符
    LParen, RParen, LBrace, RBrace, LBracket, RBracket,
    Comma, Colon, Semicolon, Dot, DotDot,
    
    // 特殊
    Eof, Newline, Comment,
}
```

### Lexer 实现

```rust
// lexer.rs
pub struct Lexer<'a> {
    source: &'a str,
    chars: Peekable<CharIndices<'a>>,
    filename: String,
    line: usize,
    column: usize,
}

impl<'a> Lexer<'a> {
    pub fn new(source: &'a str, filename: &str) -> Self {
        Self {
            source,
            chars: source.char_indices().peekable(),
            filename: filename.to_string(),
            line: 1,
            column: 1,
        }
    }
    
    pub fn tokenize(&mut self) -> Result<Vec<Token>> {
        let mut tokens = Vec::new();
        
        while let Some(token) = self.next_token()? {
            if token.kind != TokenKind::Comment {
                tokens.push(token);
            }
        }
        
        tokens.push(Token {
            kind: TokenKind::Eof,
            span: self.current_span(),
        });
        
        Ok(tokens)
    }
    
    fn next_token(&mut self) -> Result<Option<Token>> {
        self.skip_whitespace();
        
        let (start, ch) = match self.chars.next() {
            Some(pair) => pair,
            None => return Ok(None),
        };
        
        let kind = match ch {
            // 数字
            '0'..='9' => self.scan_number(ch)?,
            
            // 字符串
            '"' => self.scan_string()?,
            
            // 标识符或关键字
            'a'..='z' | 'A'..='Z' | '_' | '\u{4e00}'..='\u{9fff}' => {
                self.scan_identifier(ch)?
            }
            
            // 运算符
            '+' => TokenKind::Plus,
            '-' => self.scan_minus_or_arrow()?,
            '*' => TokenKind::Star,
            '/' => self.scan_slash_or_comment()?,
            '%' => TokenKind::Percent,
            '=' => self.scan_eq_or_arrow()?,
            '!' => self.scan_ne()?,
            '<' => self.scan_lt()?,
            '>' => self.scan_gt()?,
            '|' => self.scan_pipe()?,
            '&' => self.scan_and()?,
            
            // 分隔符
            '(' => TokenKind::LParen,
            ')' => TokenKind::RParen,
            '{' => TokenKind::LBrace,
            '}' => TokenKind::RBrace,
            '[' => TokenKind::LBracket,
            ']' => TokenKind::RBracket,
            ',' => TokenKind::Comma,
            ':' => TokenKind::Colon,
            ';' => TokenKind::Semicolon,
            '.' => self.scan_dot()?,
            
            _ => return Err(self.error(&format!("未知字符: {}", ch))),
        };
        
        Ok(Some(Token {
            kind,
            span: Span::new(start, self.current_pos(), &self.filename),
        }))
    }
    
    fn scan_identifier(&mut self, first: char) -> Result<TokenKind> {
        let mut name = String::new();
        name.push(first);
        
        while let Some(&(_, ch)) = self.chars.peek() {
            if ch.is_alphanumeric() || ch == '_' || is_chinese(ch) {
                name.push(ch);
                self.chars.next();
            } else {
                break;
            }
        }
        
        // 检查是否为关键字
        Ok(KEYWORDS.get(name.as_str())
            .cloned()
            .unwrap_or(TokenKind::Identifier(name)))
    }
}
```

## 语法分析器 (Parser)

### AST 节点定义

```rust
// ast.rs

/// 程序
pub struct Program {
    pub functions: Vec<Function>,
    pub structs: Vec<StructDef>,
    pub enums: Vec<EnumDef>,
    pub type_aliases: Vec<TypeAlias>,
    pub imports: Vec<Import>,
}

/// 函数定义
pub struct Function {
    pub name: String,
    pub kind: FunctionKind,
    pub params: Vec<Parameter>,
    pub return_type: Option<TypeExpr>,
    pub requires: Vec<Expr>,
    pub ensures: Vec<Expr>,
    pub body: Vec<Stmt>,
    pub is_async: bool,
    pub span: Span,
}

/// 函数分类
pub enum FunctionKind {
    Pure,   // 纯函数
    Query,  // 查询
    Effect, // 副作用
}

/// 语句
pub enum Stmt {
    VarDecl(VarDecl),
    Expr(Expr),
    Return(Option<Expr>, Span),
    If(IfStmt),
    While(WhileStmt),
    For(ForStmt),
    Match(MatchStmt),
    Block(Block),
    Break(Option<String>, Span),
    Continue(Option<String>, Span),
    Assert(Expr, Option<Expr>, Span),
    TryCatch(TryCatchStmt),
    Unsafe(UnsafeBlock),
    Defer(Expr, Span),
    Throw(Expr, Span),
}

/// 表达式
pub enum Expr {
    Integer(i64, Span),
    Float(f64, Span),
    Bool(bool, Span),
    String(String, Span),
    Null(Span),
    Identifier(String, Span),
    BinaryOp { left: Box<Expr>, op: String, right: Box<Expr>, span: Span },
    UnaryOp { op: String, operand: Box<Expr>, span: Span },
    Call { callee: Box<Expr>, args: Vec<Expr>, span: Span },
    Index { object: Box<Expr>, index: Box<Expr>, span: Span },
    Member { object: Box<Expr>, field: String, span: Span },
    Lambda { params: Vec<Parameter>, body: Box<Expr>, span: Span },
    Conditional { condition: Box<Expr>, then_expr: Box<Expr>, else_expr: Box<Expr>, span: Span },
    List { elements: Vec<Expr>, span: Span },
    Struct { name: String, fields: Vec<(String, Expr)>, span: Span },
    Range { start: Box<Expr>, end: Box<Expr>, inclusive: bool, span: Span },
    Pipe { left: Box<Expr>, right: Box<Expr>, span: Span },
    Await(Box<Expr>, Span),
}
```

### Parser 实现

```rust
// parser.rs
pub struct Parser {
    tokens: Vec<Token>,
    pos: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }
    
    pub fn parse(&mut self) -> Result<Program> {
        let mut program = Program::default();
        
        while !self.is_at_end() {
            match self.peek().kind {
                TokenKind::Func | TokenKind::Pure | TokenKind::Query | TokenKind::Effect => {
                    program.functions.push(self.parse_function()?);
                }
                TokenKind::Struct => {
                    program.structs.push(self.parse_struct()?);
                }
                TokenKind::Enum => {
                    program.enums.push(self.parse_enum()?);
                }
                TokenKind::Type => {
                    program.type_aliases.push(self.parse_type_alias()?);
                }
                _ => {
                    return Err(self.error("期望函数、结构体或枚举定义"));
                }
            }
        }
        
        Ok(program)
    }
    
    fn parse_function(&mut self) -> Result<Function> {
        let is_async = self.match_token(TokenKind::Async);
        
        // 解析函数分类
        let kind = match self.peek().kind {
            TokenKind::Pure => { self.advance(); FunctionKind::Pure }
            TokenKind::Query => { self.advance(); FunctionKind::Query }
            TokenKind::Effect => { self.advance(); FunctionKind::Effect }
            _ => FunctionKind::Effect, // 默认为副作用
        };
        
        self.expect(TokenKind::Func)?;
        
        let name = self.expect_identifier()?;
        
        // 解析参数
        self.expect(TokenKind::LParen)?;
        let params = self.parse_parameters()?;
        self.expect(TokenKind::RParen)?;
        
        // 解析返回类型
        let return_type = if self.match_token(TokenKind::Arrow) {
            Some(self.parse_type()?)
        } else {
            None
        };
        
        // 解析契约
        let mut requires = Vec::new();
        let mut ensures = Vec::new();
        
        while self.check(TokenKind::Requires) || self.check(TokenKind::Ensures) {
            if self.match_token(TokenKind::Requires) {
                requires.push(self.parse_expression()?);
            } else if self.match_token(TokenKind::Ensures) {
                ensures.push(self.parse_expression()?);
            }
        }
        
        // 解析函数体
        self.expect(TokenKind::LBrace)?;
        let body = self.parse_block_statements()?;
        self.expect(TokenKind::RBrace)?;
        
        Ok(Function {
            name,
            kind,
            params,
            return_type,
            requires,
            ensures,
            body,
            is_async,
            span: self.current_span(),
        })
    }
    
    fn parse_expression(&mut self) -> Result<Expr> {
        self.parse_pipe_expr()
    }
    
    fn parse_pipe_expr(&mut self) -> Result<Expr> {
        let mut left = self.parse_or_expr()?;
        
        while self.match_token(TokenKind::Pipe) {
            let right = self.parse_or_expr()?;
            left = Expr::Pipe {
                left: Box::new(left),
                right: Box::new(right),
                span: self.current_span(),
            };
        }
        
        Ok(left)
    }
    
    // ... 更多解析方法
}
```

## 语义分析器 (Analyzer)

### 类型检查

```rust
// analyzer.rs
pub struct Analyzer {
    /// 作用域栈
    scopes: Vec<Scope>,
    /// 函数表
    functions: HashMap<String, FunctionSignature>,
    /// 类型表
    types: HashMap<String, TypeInfo>,
    /// 当前函数分类
    current_function_kind: Option<FunctionKind>,
    /// 错误列表
    errors: Vec<AnalysisError>,
}

impl Analyzer {
    pub fn analyze(&mut self, program: &Program) -> Result<(), Vec<AnalysisError>> {
        // 第一遍：收集所有声明
        for func in &program.functions {
            self.register_function(func)?;
        }
        for struct_def in &program.structs {
            self.register_struct(struct_def)?;
        }
        
        // 第二遍：分析函数体
        for func in &program.functions {
            self.analyze_function(func)?;
        }
        
        if self.errors.is_empty() {
            Ok(())
        } else {
            Err(std::mem::take(&mut self.errors))
        }
    }
    
    fn analyze_function(&mut self, func: &Function) -> Result<()> {
        self.current_function_kind = Some(func.kind);
        self.push_scope();
        
        // 注册参数
        for param in &func.params {
            self.declare_variable(&param.name, &param.type_expr)?;
        }
        
        // 分析函数体
        for stmt in &func.body {
            self.analyze_stmt(stmt)?;
        }
        
        // 验证函数分类约束
        self.verify_function_kind(func)?;
        
        self.pop_scope();
        self.current_function_kind = None;
        Ok(())
    }
    
    /// 验证函数分类约束
    fn verify_function_kind(&mut self, func: &Function) -> Result<()> {
        match func.kind {
            FunctionKind::Pure => {
                // 纯函数不能调用副作用函数
                // 纯函数不能访问全局状态
                // 纯函数不能有 I/O 操作
                self.check_pure_constraints(&func.body)?;
            }
            FunctionKind::Query => {
                // 查询函数不能修改状态
                self.check_query_constraints(&func.body)?;
            }
            FunctionKind::Effect => {
                // 副作用函数无限制
            }
        }
        Ok(())
    }
}
```

## 编译选项

```rust
// compile_options.rs

/// 编译模式
pub enum CompileMode {
    Dev,     // 开发模式
    Test,    // 测试模式
    Release, // 发布模式
}

/// 编译选项
pub struct CompileOptions {
    pub mode: CompileMode,
    pub optimization_level: u8,
    pub debug_symbols: DebugSymbols,
    pub assertions: AssertionMode,
    pub target: CompileTarget,
}

/// 调试符号
pub enum DebugSymbols {
    None,
    Basic,
    Full,
}

/// 断言模式
pub enum AssertionMode {
    Strip,  // 移除断言
    Keep,   // 保留断言
    Panic,  // 断言失败时 panic
}

/// 编译目标
pub enum CompileTarget {
    Interpreter,
    Bytecode,
    LLVM,
    Wasm,
}

impl CompileOptions {
    pub fn dev() -> Self {
        Self {
            mode: CompileMode::Dev,
            optimization_level: 0,
            debug_symbols: DebugSymbols::Full,
            assertions: AssertionMode::Panic,
            target: CompileTarget::Interpreter,
        }
    }
    
    pub fn release() -> Self {
        Self {
            mode: CompileMode::Release,
            optimization_level: 3,
            debug_symbols: DebugSymbols::None,
            assertions: AssertionMode::Strip,
            target: CompileTarget::LLVM,
        }
    }
    
    pub fn assert_enabled(&self) -> bool {
        !matches!(self.assertions, AssertionMode::Strip)
    }
    
    pub fn debug_symbols_enabled(&self) -> bool {
        !matches!(self.debug_symbols, DebugSymbols::None)
    }
}
```

## 错误处理

```rust
// error.rs

/// 编译错误
pub enum YuChengError {
    /// 词法错误
    LexerError { message: String, span: Span },
    /// 语法错误
    ParseError { message: String, span: Span },
    /// 类型错误
    TypeError { message: String, span: Span },
    /// 类型不匹配
    TypeMismatch { expected: String, found: String, span: Span },
    /// 未定义变量
    UndefinedVariable { name: String, span: Span },
    /// 未定义函数
    UndefinedFunction { name: String, span: Span },
    /// 函数分类违规
    FunctionKindViolation { message: String, span: Span },
    /// 契约违规
    ContractViolation { message: String, span: Span },
    /// 运行时错误
    RuntimeError { message: String, span: Span },
}

impl YuChengError {
    pub fn span(&self) -> &Span {
        match self {
            Self::LexerError { span, .. } => span,
            Self::ParseError { span, .. } => span,
            Self::TypeError { span, .. } => span,
            Self::TypeMismatch { span, .. } => span,
            Self::UndefinedVariable { span, .. } => span,
            Self::UndefinedFunction { span, .. } => span,
            Self::FunctionKindViolation { span, .. } => span,
            Self::ContractViolation { span, .. } => span,
            Self::RuntimeError { span, .. } => span,
        }
    }
}
```

## 位置信息

```rust
// span.rs

/// 源代码位置
#[derive(Debug, Clone)]
pub struct Span {
    pub start: usize,
    pub end: usize,
    pub filename: String,
    pub line: usize,
    pub column: usize,
}

impl Span {
    pub fn new(start: usize, end: usize, filename: &str) -> Self {
        Self {
            start,
            end,
            filename: filename.to_string(),
            line: 0,
            column: 0,
        }
    }
    
    pub fn dummy() -> Self {
        Self {
            start: 0,
            end: 0,
            filename: "<unknown>".to_string(),
            line: 0,
            column: 0,
        }
    }
    
    pub fn merge(&self, other: &Span) -> Span {
        Span {
            start: self.start.min(other.start),
            end: self.end.max(other.end),
            filename: self.filename.clone(),
            line: self.line,
            column: self.column,
        }
    }
}
```

## 树遍历解释器 (Interpreter)

### 概述

树遍历解释器（`interpreter.rs`）是御程语言的默认执行引擎，直接遍历 AST 执行程序。它实现简单、启动快速，适合开发和调试场景。

### 核心数据结构

```rust
// interpreter.rs

/// 运行时值类型
pub enum Value {
    Integer(i64),
    Float(f64),
    String(String),
    Bool(bool),
    Null,
    IndexOutOfBounds,  // 索引越界标记
    List(Vec<Value>),
    Map(HashMap<String, Value>),
    Function(String),
    Struct(String, HashMap<String, Value>),
    Ok(Box<Value>),    // 结果类型 - 成功
    Err(Box<Value>),   // 结果类型 - 失败
    Return(Box<Value>),
    TailCall { callee: String, args: Vec<Value> },  // 尾调用优化
    Break,
    Continue,
    Lambda(Vec<String>, Box<Expr>, HashMap<String, Value>),  // 闭包
    Some(Box<Value>),  // 可选类型
    None,
    BoxPtr(Box<Value>),  // 堆分配指针
    RcPtr(Rc<RefCell<Value>>),  // 引用计数指针
    Mutex(Arc<Mutex<Value>>),  // 互斥锁
    RwLock(Arc<RwLock<Value>>),  // 读写锁
    Channel(Arc<ChannelInner>),  // 通道
    AtomicInt(Arc<AtomicI64>),  // 原子整数
    Thread(Arc<Mutex<Option<JoinHandle<...>>>>),  // 线程句柄
    Future(Arc<Mutex<Option<TokioJoinHandle<...>>>>),  // 异步任务
    TraitObject { object: Box<Value>, vtable: Arc<VTable> },  // Trait对象
}

/// 解释器结构
pub struct Interpreter {
    /// 作用域栈
    scopes: Vec<Scope>,
    /// 函数表（支持函数重载）
    functions: HashMap<String, Function>,
    /// 类型定义表
    type_defs: HashMap<String, TypeDef>,
    /// 标准库
    stdlib: Stdlib,
    /// 输出缓冲区
    output_buffer: Vec<String>,
    /// 是否处于不安全上下文
    in_unsafe_context: bool,
    /// Python 运行时（延迟初始化）
    python_runtime: Option<PythonRuntime>,
    /// 多语言互操作管理器
    lang_manager: Option<LangInteropManager>,
    /// 模块加载器
    module_loader: Option<ModuleLoader>,
    /// 当前递归深度
    call_depth: usize,
    /// 最大递归深度（防止栈溢出，默认32）
    max_call_depth: usize,
    /// 显式调用栈
    call_stack: Vec<CallFrame>,
    /// 内存透视模拟器（可选）
    memory_inspector: Option<MemorySimulator>,
    /// 调试器（可选）
    debugger: Option<Debugger>,
    /// 编译选项
    compile_options: CompileOptions,
    /// 执行追踪记录
    execution_trace: Vec<ExecutionTraceEntry>,
    /// Tokio 异步运行时（延迟初始化）
    tokio_runtime: Option<Runtime>,
    /// VTable 注册表
    vtable_registry: Option<VTableRegistry>,
    /// 内联缓存：变量查找缓存
    inline_cache: HashMap<String, (usize, Value)>,
    /// 全局变量缓存
    global_var_cache: HashMap<String, Value>,
    /// 表达式结果缓存
    expr_cache: HashMap<*const Expr, Value>,
    /// 函数调用频率统计（用于智能内联）
    function_call_frequency: HashMap<String, u64>,
    /// 调用图（用于相互尾调用优化）
    call_graph: HashMap<String, HashSet<String>>,
}
```

### 执行流程

```rust
impl Interpreter {
    /// 执行程序
    pub fn run(&mut self, program: &Program) -> Result<Value> {
        // 第一遍：收集所有函数定义和类型定义
        for item in &program.items {
            match item {
                Item::Function(func) => {
                    // 生成函数签名键（支持重载）
                    let func_key = format!("{}#{}#{}", 
                        func.name, 
                        func.params.len(),
                        param_types.join(",")
                    );
                    self.functions.insert(func_key, func.clone());
                }
                Item::TypeDef(type_def) => {
                    self.type_defs.insert(type_def.name.clone(), type_def.clone());
                }
                // ... 其他项
            }
        }
        
        // 第二遍：执行主程序
        // 查找主函数或执行全局代码
        // ...
    }
    
    /// 执行语句
    fn eval_stmt(&mut self, stmt: &Stmt) -> Result<Value> {
        match stmt {
            Stmt::VarDecl(var) => {
                // 变量声明
                let value = self.eval_expr(&var.initializer)?;
                self.declare_variable(&var.name, value)?;
            }
            Stmt::Expr(expr) => {
                // 表达式语句
                self.eval_expr(expr)?;
            }
            Stmt::Return(expr, _) => {
                // 返回语句
                let value = expr.as_ref()
                    .map(|e| self.eval_expr(e))
                    .transpose()?
                    .unwrap_or(Value::Null);
                return Ok(Value::Return(Box::new(value)));
            }
            Stmt::If(if_stmt) => {
                // 条件语句
                return self.eval_if(if_stmt);
            }
            Stmt::While(while_stmt) => {
                // 循环语句
                return self.eval_while(while_stmt);
            }
            // ... 其他语句类型
        }
        Ok(Value::Null)
    }
    
    /// 执行表达式
    fn eval_expr(&mut self, expr: &Expr) -> Result<Value> {
        match expr {
            Expr::Literal(lit) => Ok(self.literal_to_value(lit)),
            Expr::Identifier(name, _) => self.get_variable(name),
            Expr::BinaryOp { left, op, right, .. } => {
                let left_val = self.eval_expr(left)?;
                let right_val = self.eval_expr(right)?;
                self.eval_binary_op(&left_val, op, &right_val, span)
            }
            Expr::Call { callee, args, .. } => {
                let callee_val = self.eval_expr(callee)?;
                let arg_vals: Vec<Value> = args.iter()
                    .map(|arg| self.eval_expr(arg))
                    .collect::<Result<_>>()?;
                self.call_function(&callee_val, &arg_vals)
            }
            // ... 其他表达式类型
        }
    }
}
```

### 特性支持

#### 1. 函数重载

解释器通过函数签名键（函数名#参数数量#参数类型列表）支持函数重载：

```rust
// 函数签名键格式：函数名#参数数量#参数类型列表#返回类型
let func_key = format!("{}#{}#{}#{}", 
    func.name, 
    func.params.len(), 
    param_types.join(","),
    return_type
);
```

#### 2. 尾调用优化

解释器通过 `TailCall` 变体实现尾调用优化，避免栈溢出：

```rust
Value::TailCall { callee: String, args: Vec<Value> }
```

#### 3. 内联缓存

解释器使用内联缓存加速变量查找：

```rust
inline_cache: HashMap<String, (usize, Value)>
```

#### 4. 表达式结果缓存

解释器缓存常量表达式和计算结果，提升性能：

```rust
expr_cache: HashMap<*const Expr, Value>
```

#### 5. 异步支持

解释器集成 Tokio 运行时，支持异步函数执行：

```rust
tokio_runtime: Option<Runtime>
```

#### 6. 内存透视

解释器可选集成内存模拟器，用于开发期观察：

```rust
memory_inspector: Option<MemorySimulator>
```

### 与字节码虚拟机的对比

| 特性 | 树遍历解释器 | 字节码虚拟机 |
|------|------------|------------|
| 实现复杂度 | 简单 | 中等 |
| 启动速度 | 快 | 中等 |
| 执行速度 | 慢 | 快 |
| 内存占用 | 低 | 中等 |
| 调试支持 | 最好 | 好 |
| 适用场景 | 开发、调试 | 生产环境 |

### 使用示例

```rust
use yucheng_compiler::{Interpreter, Lexer, Parser};

// 1. 解析源代码
let source = r#"
    函数 加法(a: 整数, b: 整数) -> 整数 {
        返回 a + b
    }
    
    函数 主函数() {
        打印(加法(10, 20))
    }
"#;

let mut lexer = Lexer::new(source);
let tokens = lexer.tokenize()?;
let mut parser = Parser::new(tokens);
let ast = parser.parse()?;

// 2. 创建解释器并执行
let mut interpreter = Interpreter::new();
let result = interpreter.run(&ast)?;

// 3. 获取输出
for output in interpreter.get_output() {
    println!("{}", output);
}
```