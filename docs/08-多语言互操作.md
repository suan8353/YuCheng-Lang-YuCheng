# YuCheng 语言 - 多语言互操作

> **实现状态**: ⚠️ 部分完整实现
> - ✅ FFI类型系统定义完整（11种C类型定义）
> - ✅ 真实的C ABI FFI（基于libloading，支持多种函数签名）
> - ✅ 动态库加载和函数调用（支持Int32/Int64/Double/CString，0-4个参数）
> - ✅ 混合类型参数支持（i32+f64等）
> - ✅ 字符串参数支持（strlen-like函数）
> - ❌ **多语言互操作（12种语言通过subprocess）- 未实现**
> - ✅ C头文件和绑定生成（C/Python/Go/Rust）
> - ✅ 23个FFI测试全部通过（100%）
> 
> **支持的函数签名**:
> - ✅ 0-4个参数的函数
> - ✅ Int32, Int64, Double, CString参数类型
> - ✅ 混合类型参数（如i32+f64）
> - ✅ 自动类型转换（Integer→f64）
> - ✅ 多种返回类型（Int32/Int64/Double/Void）
> 
> **限制**:
> - ⚠️ 不支持指针参数（VoidPtr/StructPtr/ArrayPtr）- 需要libffi
> - ⚠️ 不支持函数指针（FuncPtr）- 需要libffi
> - ⚠️ 不支持5个及以上参数的函数
> - ⚠️ 字符串参数仅支持输入（const char*），不支持输出（char**）
> 
> **完成报告**: `.project-reports/implementation-status/08-FFI-COMPLETION.md`  
> **示例代码**: `examples/39-ffi-demo.ycs`

## 1. 设计理念

YuCheng 通过多种方式实现与其他语言的互操作：

1. **C ABI 兼容层** - 编译为动态链接库，任何支持 C FFI 的语言都可调用
2. **多语言互操作** - 直接调用 12 种主流语言的包，弥补生态不足
3. **外部库声明** - 调用外部 C 库函数

```
YuCheng源码 ──▶ 编译器 ──▶ C ABI 兼容库 + 绑定代码
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
           Python            Go             Rust
          (ctypes)          (cgo)          (FFI)

YuCheng源码 ──▶ 多语言互操作 ──▶ 直接调用各语言包
                                    │
        ┌───────┬───────┬───────┬───┴───┬───────┬───────┐
        ▼       ▼       ▼       ▼       ▼       ▼       ▼
       C/C++  Python   JS    Ruby    Lua    Go    Rust
```

## 2. 支持的语言（12种）

| 语言 | 类型 | 检测命令 | 状态 |
|------|------|----------|------|
| C | 编译型 | gcc/clang | ✅ |
| C++ | 编译型 | g++/clang++ | ✅ |
| Python | 解释型 | python/python3 | ✅ |
| JavaScript | 解释型 | node/nodejs | ✅ |
| Ruby | 解释型 | ruby | ✅ |
| PHP | 解释型 | php | ✅ |
| Lua | 解释型 | lua | ✅ |
| Perl | 解释型 | perl | ✅ |
| R | 解释型 | Rscript | ✅ |
| Julia | 解释型 | julia | ✅ |
| Go | 编译型 | go | ✅ |
| Rust | 编译型 | rustc | ✅ |

## 3. 实现状态

| 功能 | 状态 |
|------|------|
| FFI 类型系统 | ✅ 已实现 |
| C 头文件生成 | ✅ 已实现 |
| Python 绑定生成 | ✅ 已实现 |
| Go 绑定生成 | ✅ 已实现 |
| Rust 绑定生成 | ✅ 已实现 |
| 外部库声明 | ✅ 已实现 |
| 模拟外部调用 | ✅ 已实现 |
| **Python 互操作** | ✅ 已实现 |
| **多语言互操作 (12种)** | ✅ 已实现 |
| 实际动态库加载 | ⏳ 待实现 |

## 3. Python 互操作（新功能）

### 3.1 概述

御程语言支持直接调用 Python 包，无需编写绑定代码。这使得御程可以利用 Python 丰富的生态系统来弥补自身生态的不足。

**前提条件**：系统需要安装 Python 3.x

### 3.2 内置函数

| 函数 | 说明 | 状态 |
|------|------|------|
| `Python可用()` | 检查 Python 是否可用 | ✅ 已实现 |
| `Python执行(代码)` | 执行 Python 代码并返回结果 | ✅ 已实现 |
| `Python调用(模块, 函数, 参数列表)` | 调用 Python 模块函数 | ✅ 已实现 |
| `JS可用()` | 检查 Node.js 是否可用 | ✅ 已实现 |
| `JS执行(代码)` | 执行 JavaScript 代码并返回结果 | ✅ 已实现 |
| `JS调用(模块, 函数, 参数列表)` | 调用 Node.js 模块函数 | ✅ 已实现 |

### 3.3 使用示例

```御程
// 检查 Python 环境
副作用 func 检查Python() {
    如果 Python可用() {
        控制台 => "Python 可用"
    } 否则 {
        控制台 => "Python 不可用"
    }
}

// 使用 Python 数学库
副作用 func 数学计算() {
    如果 Python可用() {
        // 调用 math.sqrt
        let 结果 = Python调用("math", "sqrt", [16])
        控制台 => "sqrt(16) = " + 结果  // 输出: 4.0
        
        // 调用 math.sin
        let 正弦值 = Python调用("math", "sin", [1.5708])
        控制台 => "sin(π/2) = " + 正弦值  // 输出: ~1.0
    }
}

// 执行 Python 表达式
副作用 func Python表达式() {
    如果 Python可用() {
        let 结果 = Python执行("print(1 + 2 + 3)")
        控制台 => 结果  // 输出: 6
        
        let 文本 = Python执行("print('hello'.upper())")
        控制台 => 文本  // 输出: HELLO
    }
}

// 使用 JavaScript
副作用 func JS示例() {
    如果 JS可用() {
        // 执行 JS 代码
        let 结果 = JS执行("console.log(Math.sqrt(25))")
        控制台 => 结果  // 输出: 5
        
        // 调用 Node.js 内置模块
        let 路径 = JS调用("path", "join", ["/home", "user"])
        控制台 => 路径  // 输出: /home/user
    }
}
```

### 3.4 类型映射

| 御程类型 | Python 类型 |
|----------|-------------|
| `整数` | `int` |
| `小数` | `float` |
| `文本` | `str` |
| `布尔` | `bool` |
| `空` | `None` |
| `列表` | `list` |
| `映射` | `dict` |

### 3.5 IDE 组件支持

IDE 的组件面板提供 Python SDK 安装选项：

- **Python 互操作支持** - 安装精简版 Python 运行时
- 自动检测系统已安装的 Python
- 支持 `YC_PYTHON_HOME` 环境变量指定 Python 路径

### 3.6 错误处理

```御程
副作用 func 安全调用Python() {
    如果 !Python可用() {
        控制台 => "错误: Python 不可用"
        返回
    }
    
    // Python 调用可能失败，建议使用结果类型
    var 结果 = 调用Python("math", "sqrt", -1)  // 会返回错误
    控制台 => 结果
}
```

## 4. 多语言互操作（通用接口）

### 4.1 通用函数

| 函数 | 说明 |
|------|------|
| `语言可用(语言名)` | 检查指定语言是否可用 |
| `语言版本(语言名)` | 获取指定语言版本 |
| `可用语言列表()` | 列出所有可用语言 |
| `执行语言(语言名, 代码)` | 执行指定语言代码 |
| `调用语言(语言名, 模块, 函数, 参数...)` | 调用指定语言的模块函数 |

### 4.2 各语言快捷函数

| 语言 | 检查可用 | 执行代码 |
|------|----------|----------|
| C | `C可用()` | `执行C(代码)` |
| C++ | `CPP可用()` | `执行CPP(代码)` |
| Python | `Python可用()` | `执行Python(代码)` |
| JavaScript | `JS可用()` | `执行JS(代码)` |
| Ruby | `Ruby可用()` | `执行Ruby(代码)` |
| PHP | `PHP可用()` | `执行PHP(代码)` |
| Lua | `Lua可用()` | `执行Lua(代码)` |
| Perl | `Perl可用()` | `执行Perl(代码)` |
| R | `R可用()` | `执行R(代码)` |
| Julia | `Julia可用()` | `执行Julia(代码)` |
| Go | `Go可用()` | `执行Go(代码)` |
| Rust | `Rust可用()` | `执行Rust(代码)` |

### 4.3 使用示例

```御程
// 检查所有可用语言
副作用 func 检查环境() {
    var 语言列表 = 可用语言列表()
    控制台 => "可用语言: " + 语言列表
}

// 使用 C 语言计算
副作用 func C计算() {
    如果 C可用() {
        var 结果 = 执行C("100 + 200")
        控制台 => "C: 100 + 200 = " + 结果
    }
}

// 使用 C++ 计算
副作用 func CPP计算() {
    如果 CPP可用() {
        var 结果 = 执行CPP("sqrt(16.0)")
        控制台 => "C++: sqrt(16) = " + 结果
    }
}

// 使用 JavaScript
副作用 func JS计算() {
    如果 JS可用() {
        var 结果 = 执行JS("Math.pow(2, 10)")
        控制台 => "JS: 2^10 = " + 结果
    }
}

// 使用 Ruby
副作用 func Ruby计算() {
    如果 Ruby可用() {
        var 结果 = 执行Ruby("[1,2,3,4,5].sum")
        控制台 => "Ruby: sum = " + 结果
    }
}

// 使用 Lua
副作用 func Lua计算() {
    如果 Lua可用() {
        var 结果 = 执行Lua("math.sqrt(25)")
        控制台 => "Lua: sqrt(25) = " + 结果
    }
}

// 使用通用接口
副作用 func 通用调用() {
    如果 语言可用("python") {
        var 版本 = 语言版本("python")
        控制台 => "Python 版本: " + 版本
        
        var 结果 = 执行语言("python", "2 ** 10")
        控制台 => "Python: 2^10 = " + 结果
    }
}
```

### 4.4 C/C++ 特殊说明

C/C++ 是编译型语言，执行时会：
1. 创建临时源文件
2. 调用编译器编译
3. 执行编译后的程序
4. 清理临时文件

```御程
// C 代码会被包装成完整程序
// 执行C("1 + 2") 实际执行:
// #include <stdio.h>
// int main() {
//     printf("%d\n", (int)(1 + 2));
//     return 0;
// }

// C++ 代码会被包装成完整程序
// 执行CPP("sqrt(16.0)") 实际执行:
// #include <iostream>
// #include <cmath>
// using namespace std;
// int main() {
//     cout << (sqrt(16.0)) << endl;
//     return 0;
// }
```

## 5. 导出函数（C ABI）

### 5.1 导出声明

```御程
// mathlib.yc

// 导出的函数
导出 纯函数 func 加法(a: 整数, b: 整数) -> 整数
导出 纯函数 func 乘法(a: 整数, b: 整数) -> 整数
导出 纯函数 func 字符串长度(文本值: 文本) -> 整数

// 内部函数（不导出）
纯函数 func 内部辅助函数()
```

### 5.2 类型映射

| YuCheng类型 | C 类型 |
|------------|--------|
| `整数` | `int32_t` |
| `长整数` | `int64_t` |
| `小数` | `double` |
| `布尔` | `int32_t` |
| `文本` | `char*` |
| `指针` | `void*` |

### 5.3 生成的 C 头文件

```c
// mathlib.h (自动生成)
#ifndef YUCHENG_MATHLIB_H
#define YUCHENG_MATHLIB_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

int32_t yc_加法(int32_t a, int32_t b);
int32_t yc_乘法(int32_t a, int32_t b);
int32_t yc_字符串长度(const char* text);

#ifdef __cplusplus
}
#endif

#endif
```

## 3. 编译为动态库

```bash
# 编译为动态库
yucheng build --lib mathlib.ycl

# 输出文件
# Windows: mathlib.dll + mathlib.h
# Linux:   libmathlib.so + mathlib.h
# macOS:   libmathlib.dylib + mathlib.h
```

## 4. Python 调用

```python
import ctypes

# 加载库
lib = ctypes.CDLL('./libmathlib.so')

# 定义函数签名
lib.yc_加法.argtypes = [ctypes.c_int32, ctypes.c_int32]
lib.yc_加法.restype = ctypes.c_int32

# 调用
result = lib.yc_加法(10, 20)
print(f"10 + 20 = {result}")  # 输出: 30
```

### Python 封装类

```python
class MathLib:
    def __init__(self, lib_path='./libmathlib.so'):
        self._lib = ctypes.CDLL(lib_path)
        self._setup()
    
    def _setup(self):
        self._lib.yc_加法.argtypes = [ctypes.c_int32, ctypes.c_int32]
        self._lib.yc_加法.restype = ctypes.c_int32
    
    def 加法(self, a, b):
        return self._lib.yc_加法(a, b)

# 使用
math = MathLib()
print(math.加法(10, 20))
```

## 5. Go 调用

```go
package main

/*
#cgo LDFLAGS: -L. -lmathlib
#include "mathlib.h"
*/
import "C"
import "fmt"

func main() {
    result := C.yc_加法(C.int32_t(10), C.int32_t(20))
    fmt.Printf("10 + 20 = %d\n", result)
}
```

## 6. Rust 调用

```rust
use std::os::raw::c_int;

#[link(name = "mathlib")]
extern "C" {
    fn yc_加法(a: c_int, b: c_int) -> c_int;
}

fn main() {
    unsafe {
        let result = yc_加法(10, 20);
        println!("10 + 20 = {}", result);
    }
}
```

## 7. C# 调用

```csharp
using System.Runtime.InteropServices;

public static class MathLib
{
    [DllImport("mathlib", CallingConvention = CallingConvention.Cdecl)]
    private static extern int yc_加法(int a, int b);
    
    public static int 加法(int a, int b) => yc_加法(a, b);
}

// 使用
Console.WriteLine($"10 + 20 = {MathLib.加法(10, 20)}");
```

## 8. 复杂数据类型

### 8.1 结构体

```御程
// data.yc
结构体 用户信息 {
    ID: 长整数
    名字: 文本
    年龄: 整数
}

导出 查询 func 获取用户(ID: 长整数) -> 指针<用户信息>
导出 副作用 func 释放用户(用户: 指针<用户信息>)
```

### 8.2 回调函数

```御程
// callback.yc
类型 进度回调 = func(当前: 整数, 总数: 整数)

导出 副作用 func 处理数据(数据: 指针, 回调: 进度回调)
```

## 9. 最佳实践

### 9.1 内存管理

```御程
// 谁分配谁释放
导出 查询 func 获取数据() -> 指针
导出 副作用 func 释放数据(数据: 指针)
```

### 9.2 错误处理

```御程
// 使用错误码
导出 副作用 func 操作() -> 整数  // 0=成功，负数=错误

// 提供错误信息
导出 查询 func 最后错误() -> 文本
```

### 9.3 线程安全

```御程
// 纯函数自动标记为线程安全
导出 纯函数 func 纯计算(a: 整数) -> 整数
```

## 10. 调用外部库

YuCheng 支持调用外部 C 库函数：

### 10.1 外部函数声明

```御程
// 声明外部数学函数
外部 库 "libm" func 正弦(x: 小数) -> 小数
外部 库 "libm" func 余弦(x: 小数) -> 小数
外部 库 "libm" func 平方根(x: 小数) -> 小数
外部 库 "libm" func 幂(底数: 小数, 指数: 小数) -> 小数
```

### 10.2 使用外部函数

```御程
// 使用外部函数计算
var 结果 = 平方根(16.0)  // 4.0
var 面积 = 3.14159 * 幂(半径, 2.0)
```

### 10.3 支持的外部函数（模拟）

当前模拟实现支持以下常用函数：

| 函数 | 说明 |
|------|------|
| sin | 正弦函数 |
| cos | 余弦函数 |
| sqrt | 平方根 |
| pow | 幂运算 |
| strlen | 字符串长度 |

## 11. 编译器模块

FFI 功能由以下模块实现：

- `ffi.rs` - FFI 管理器、类型映射、绑定生成
- `external.rs` - 外部库注册、模拟调用

### 11.1 核心类型

```rust
// C ABI 类型
pub enum CType {
    Void, Int32, Int64, Double, Bool,
    CString, MutableCString, VoidPtr,
    StructPtr(String), FuncPtr(...), ArrayPtr(...)
}

// 导出函数信息
pub struct ExportedFunction {
    name: String,
    export_name: String,  // yc_ 前缀
    kind: FunctionKind,
    params: Vec<(String, CType)>,
    return_type: CType,
    thread_safe: bool,
}
```

### 11.2 使用示例

```rust
use yucheng_compiler::ffi::FfiManager;

let mut manager = FfiManager::new();
// 注册导出函数...

// 生成绑定
let header = manager.generate_header("mathlib");
let python = manager.generate_python_binding("mathlib");
let go = generate_go_binding(&manager, "mathlib");
let rust = generate_rust_binding(&manager, "mathlib");
```


## 12. 真实FFI实现（基于libloading）

### 12.1 动态库加载

御程语言使用`libloading`库实现真实的动态库加载，支持跨平台：

- **Windows**: 加载 `.dll` 文件
- **Linux**: 加载 `.so` 文件  
- **macOS**: 加载 `.dylib` 文件

### 12.2 核心功能

#### 动态库管理
```rust
// 加载动态库
let lib = DynamicLibrary::load("mathlib.dll")?;

// 获取符号
let symbol = lib.get_symbol::<extern "C" fn(i32, i32) -> i32>("yc_add")?;

// 调用函数
let result = symbol(10, 20);

// 卸载库
lib.unload()?;
```

#### FFI调用器
```rust
// 创建FFI调用器
let mut caller = FfiCaller::new();

// 加载库
caller.load_library("mathlib", "mathlib.dll")?;

// 调用函数
let result = caller.call(
    "mathlib",
    "yc_add",
    &[Value::Integer(10), Value::Integer(20)],
    &CType::Int32,
)?;
```

### 12.3 支持的函数签名

当前实现支持以下函数签名组合：

#### 无参数函数（4种）
| 返回类型 | 签名 | 示例 |
|---------|------|------|
| i32 | `fn() -> i32` | `get_version()` |
| i64 | `fn() -> i64` | `get_timestamp()` |
| f64 | `fn() -> f64` | `get_pi()` |
| void | `fn()` | `initialize()` |

#### 单参数函数（6种）
| 参数类型 | 返回类型 | 签名 | 示例 |
|---------|---------|------|------|
| i32 | i32 | `fn(i32) -> i32` | `abs(x)` |
| i32 | i64 | `fn(i32) -> i64` | `to_long(x)` |
| i32 | f64 | `fn(i32) -> f64` | `to_double(x)` |
| f64 | f64 | `fn(f64) -> f64` | `sqrt(x)` |
| f64 | i32 | `fn(f64) -> i32` | `round(x)` |
| string | i32 | `fn(*const char) -> i32` | `strlen(s)` |

#### 双参数函数（5种）
| 参数类型 | 返回类型 | 签名 | 示例 |
|---------|---------|------|------|
| i32, i32 | i32 | `fn(i32, i32) -> i32` | `add(a, b)` |
| i32, i32 | i64 | `fn(i32, i32) -> i64` | `multiply_long(a, b)` |
| f64, f64 | f64 | `fn(f64, f64) -> f64` | `pow(base, exp)` |
| i32, f64 | f64 | `fn(i32, f64) -> f64` | `scale(count, factor)` |
| f64, i32 | f64 | `fn(f64, i32) -> f64` | `round_to(value, digits)` |

#### 三参数函数（3种）
| 参数类型 | 返回类型 | 签名 | 示例 |
|---------|---------|------|------|
| i32, i32, i32 | i32 | `fn(i32, i32, i32) -> i32` | `clamp(value, min, max)` |
| i32, i32, i32 | i64 | `fn(i32, i32, i32) -> i64` | `sum3_long(a, b, c)` |
| f64, f64, f64 | f64 | `fn(f64, f64, f64) -> f64` | `lerp(a, b, t)` |

#### 四参数函数（2种）
| 参数类型 | 返回类型 | 签名 | 示例 |
|---------|---------|------|------|
| i32, i32, i32, i32 | i32 | `fn(i32, i32, i32, i32) -> i32` | `rgba_to_int(r, g, b, a)` |
| f64, f64, f64, f64 | f64 | `fn(f64, f64, f64, f64) -> f64` | `cubic_bezier(p0, p1, p2, p3)` |

**总计**: 20种函数签名组合（从原来的7种扩展到20种）

### 12.4 类型安全

FFI系统提供完整的类型安全检查：

- **编译时检查**: 类型映射在编译时验证
- **运行时检查**: 参数类型在调用前验证
- **自动类型转换**: Integer自动转换为f64（当需要时）
- **错误处理**: 完整的错误类型和错误消息

```rust
pub enum FfiError {
    LibraryNotFound(PathBuf),
    SymbolNotFound(String),
    LoadError(String),
    CallError(String),
    TypeMismatch { expected: CType, found: String },
    LibraryUnloaded,
}
```

### 12.5 内存安全

- **自动清理**: 库句柄在Drop时自动卸载
- **符号缓存**: 避免重复查找符号
- **生命周期管理**: 确保符号在库存在期间有效
- **字符串安全**: CString自动管理内存，防止悬垂指针

### 12.6 平台兼容性

FFI系统自动处理平台差异：

```rust
// 自动添加平台扩展名
#[cfg(target_os = "windows")]
const LIB_EXT: &str = ".dll";

#[cfg(target_os = "linux")]
const LIB_EXT: &str = ".so";

#[cfg(target_os = "macos")]
const LIB_EXT: &str = ".dylib";
```

### 12.7 测试覆盖

FFI系统包含完整的测试套件：

- **单元测试**: 18个测试覆盖核心功能
- **集成测试**: 23个测试验证完整工作流（从14个增加到23个）
- **平台测试**: Windows/Linux/macOS系统库加载测试
- **新增测试**: 3-4参数函数、混合类型、字符串参数、类型转换

```bash
# 运行FFI测试
cargo test ffi --lib
cargo test --test ffi_integration_test

# 测试结果
running 18 tests ... ok (单元测试)
running 23 tests ... ok (集成测试) ✅ 100%通过
```

### 12.8 性能特性

- **零拷贝**: 直接传递原始指针
- **符号缓存**: 避免重复符号查找
- **延迟加载**: 按需加载动态库
- **批量调用**: 支持高频率FFI调用

### 12.9 使用示例

#### 创建C库
```c
// mathlib.c
#ifdef _WIN32
__declspec(dllexport)
#endif
int32_t yc_add(int32_t a, int32_t b) {
    return a + b;
}

#ifdef _WIN32
__declspec(dllexport)
#endif
double yc_pow(double base, double exp) {
    return pow(base, exp);
}

#ifdef _WIN32
__declspec(dllexport)
#endif
int32_t yc_strlen(const char* str) {
    return (int32_t)strlen(str);
}

#ifdef _WIN32
__declspec(dllexport)
#endif
int32_t yc_add3(int32_t a, int32_t b, int32_t c) {
    return a + b + c;
}

#ifdef _WIN32
__declspec(dllexport)
#endif
int32_t yc_add4(int32_t a, int32_t b, int32_t c, int32_t d) {
    return a + b + c + d;
}
```

#### 编译库
```bash
# Windows
gcc -shared -o mathlib.dll mathlib.c

# Linux
gcc -shared -fPIC -o libmathlib.so mathlib.c -lm

# macOS
gcc -shared -fPIC -o libmathlib.dylib mathlib.c
```

#### 在御程中使用
```御程
// 声明外部函数
外部 库 "mathlib" func yc_add(a: 整数, b: 整数) -> 整数
外部 库 "mathlib" func yc_pow(base: 小数, exp: 小数) -> 小数
外部 库 "mathlib" func yc_strlen(s: 文本) -> 整数
外部 库 "mathlib" func yc_add3(a: 整数, b: 整数, c: 整数) -> 整数
外部 库 "mathlib" func yc_add4(a: 整数, b: 整数, c: 整数, d: 整数) -> 整数

// 调用函数
var 结果1 = yc_add(10, 20)
打印("10 + 20 = " + 结果1)  // 输出: 30

var 结果2 = yc_pow(2.0, 10.0)
打印("2^10 = " + 结果2)  // 输出: 1024.0

var 长度 = yc_strlen("hello")
打印("strlen('hello') = " + 长度)  // 输出: 5

var 结果3 = yc_add3(1, 2, 3)
打印("1 + 2 + 3 = " + 结果3)  // 输出: 6

var 结果4 = yc_add4(1, 2, 3, 4)
打印("1 + 2 + 3 + 4 = " + 结果4)  // 输出: 10
```

### 12.10 限制和未来改进

#### 当前限制
- 支持0-4个参数（5个及以上需要libffi）
- 不支持复杂结构体传递
- 不支持回调函数
- 不支持可变参数函数
- 字符串参数仅支持输入（const char*）

#### 未来改进计划
- 使用`libffi`支持任意函数签名
- 支持结构体和联合体
- 支持回调函数
- 支持可变参数
- 支持字符串输出参数（char**）
- 自动生成绑定代码

#### 改进历史
- **2026-02-08**: 从7种签名扩展到20种签名
  * 新增3参数函数支持（3种签名）
  * 新增4参数函数支持（2种签名）
  * 新增混合类型参数支持（i32+f64, f64+i32）
  * 新增字符串参数支持（strlen-like）
  * 新增自动类型转换（Integer→f64）
  * 测试覆盖率从14个增加到23个（+64%）

## 13. 实现状态总结

### 已完成功能 ✅

1. **多语言互操作** (12种语言)
   - Python, JavaScript, C, C++, Ruby, PHP
   - Lua, Perl, R, Julia, Go, Rust
   - 通过subprocess实现，稳定可靠

2. **真实FFI** (基于libloading)
   - 动态库加载和卸载
   - 符号查找和缓存
   - 类型安全的函数调用
   - 跨平台支持

3. **类型系统**
   - 完整的C类型映射
   - 类型安全检查
   - 错误处理

4. **绑定生成**
   - C头文件生成
   - Python绑定生成
   - Go绑定生成
   - Rust绑定生成

### 测试覆盖 ✅

- **单元测试**: 18个测试
- **集成测试**: 14个测试
- **示例代码**: 2个完整示例
- **测试通过率**: 100%

### 文档完整性 ✅

- 使用指南完整
- API文档清晰
- 示例代码充分
- 最佳实践明确

## 14. 运行示例

```bash
# 1. 编译C测试库
cd examples/ffi-test-lib
./build.ps1

# 2. 运行FFI演示
yucheng run examples/39-ffi-demo.ycs

# 3. 运行多语言互操作测试
yucheng run examples/multi-lang-demo.ycs
```

## 15. 参考资料

- [libloading文档](https://docs.rs/libloading/)
- [C ABI规范](https://en.wikipedia.org/wiki/Application_binary_interface)
- [FFI最佳实践](https://doc.rust-lang.org/nomicon/ffi.html)
